{
    "abs": {
        "signature": "genIType abs(genIType x)",
        "purpose": "return the absolute value of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value of which to return the absolute. </para> </listitem>"
        }
    },
    "acos": {
        "signature": "genType acos(genType x)",
        "purpose": "return the arccosine of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose arccosine to return. </para> </listitem>"
        }
    },
    "acosh": {
        "signature": "genType acosh(genType x)",
        "purpose": "return the arc hyperbolic cosine of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose arc hyperbolic cosine to return. </para> </listitem>"
        }
    },
    "all": {
        "signature": "bool all(bvec x)",
        "purpose": "check whether all elements of a boolean vector are true",
        "parameters": {
            "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
        }
    },
    "any": {
        "signature": "bool any(bvec x)",
        "purpose": "check whether any element of a boolean vector is true",
        "parameters": {
            "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
        }
    },
    "asin": {
        "signature": "genType asin(genType x)",
        "purpose": "return the arcsine of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose arcsine to return. </para> </listitem>"
        }
    },
    "asinh": {
        "signature": "genType asinh(genType x)",
        "purpose": "return the arc hyperbolic sine of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose arc hyperbolic sine to return. </para> </listitem>"
        }
    },
    "atan": {
        "signature": "genType atan(genType y_over_x)",
        "purpose": "return the arc-tangent of the parameters",
        "parameters": {
            "y": "<listitem> <para> Specify the numerator of the fraction whose arctangent to return. </para> </listitem>",
            "x": "<listitem> <para> Specify the denominator of the fraction whose arctangent to return. </para> </listitem>",
            "y_over_x": "<listitem> <para> Specify the fraction whose arctangent to return. </para> </listitem>"
        }
    },
    "atanh": {
        "signature": "genType atanh(genType x)",
        "purpose": "return the arc hyperbolic tangent of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose arc hyperbolic tangent to return. </para> </listitem>"
        }
    },
    "ceil": {
        "signature": "genType ceil(genType x)",
        "purpose": "find the nearest integer that is greater than or equal to the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
        }
    },
    "clamp": {
        "signature": "genUType clamp(genUType x, uint minVal, uint maxVal)",
        "purpose": "constrain a value to lie between two further values",
        "parameters": {
            "x": "<listitem> <para> Specify the value to constrain. </para> </listitem>",
            "minVal": "<listitem> <para> Specify the lower end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>",
            "maxVal": "<listitem> <para> Specify the upper end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>"
        }
    },
    "cos": {
        "signature": "genType cos(genType angle)",
        "purpose": "return the cosine of the parameter",
        "parameters": {
            "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the cosine. </para> </listitem>"
        }
    },
    "cosh": {
        "signature": "genType cosh(genType x)",
        "purpose": "return the hyperbolic cosine of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose hyperbolic cosine to return. </para> </listitem>"
        }
    },
    "cross": {
        "signature": "vec3 cross(vec3 x, vec3 y)",
        "purpose": "calculate the cross product of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
            "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
        }
    },
    "degrees": {
        "signature": "genType degrees(genType radians)",
        "purpose": "convert a quantity in radians to degrees",
        "parameters": {
            "radians": "<listitem> <para> Specify the quantity, in radians, to be converted to degrees. </para> </listitem>"
        }
    },
    "determinant": {
        "signature": "float determinant(mat4 m)",
        "purpose": "calculate the determinant of a matrix",
        "parameters": {
            "m": "<listitem> <para> Specifies the matrix of which to take the determinant. </para> </listitem>"
        }
    },
    "dFdx": {
        "signature": "genType dFdx(genType p)",
        "purpose": "return the partial derivative of an argument with respect to x or y",
        "parameters": {
            "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
        }
    },
    "dFdy": {
        "signature": "genType dFdy(genType p)",
        "purpose": "return the partial derivative of an argument with respect to x or y",
        "parameters": {
            "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
        }
    },
    "distance": {
        "signature": "float distance(genType p0, genType p1)",
        "purpose": "calculate the distance between two points",
        "parameters": {
            "p0": "<listitem> <para> Specifies the first of two points </para> </listitem>",
            "p1": "<listitem> <para> Specifies the second of two points </para> </listitem>"
        }
    },
    "dot": {
        "signature": "float dot(genType x, genType y)",
        "purpose": "calculate the dot product of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
            "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
        }
    },
    "equal": {
        "signature": "bvec equal(uvec x, uvec y)",
        "purpose": "perform a component-wise equal-to comparison of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
        }
    },
    "exp": {
        "signature": "genType exp(genType x)",
        "purpose": "return the natural exponentiation of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value to exponentiate. </para> </listitem>"
        }
    },
    "exp2": {
        "signature": "genType exp2(genType x)",
        "purpose": "return 2 raised to the power of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value of the power to which 2 will be raised. </para> </listitem>"
        }
    },
    "faceforward": {
        "signature": "genType faceforward(genType N, genType I, genType Nref)",
        "purpose": "return a vector pointing in the same direction as another",
        "parameters": {
            "N": "<listitem> <para> Specifies the vector to orient. </para> </listitem>",
            "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
            "Nref": "<listitem> <para> Specifies the reference vector. </para> </listitem>"
        }
    },
    "floatBitsToInt": {
        "signature": "genIType floatBitsToInt(genType x)",
        "purpose": "produce the encoding of a floating point value as an integer",
        "parameters": {
            "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
        }
    },
    "floatBitsToUint": {
        "signature": "genUType floatBitsToUint(genType x)",
        "purpose": "produce the encoding of a floating point value as an integer",
        "parameters": {
            "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
        }
    },
    "floor": {
        "signature": "genType floor(genType x)",
        "purpose": "find the nearest integer less than or equal to the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
        }
    },
    "fract": {
        "signature": "genType fract(genType x)",
        "purpose": "compute the fractional part of the argument",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
        }
    },
    "fwidth": {
        "signature": "genType fwidth(genType p)",
        "purpose": "return the sum of the absolute derivatives in x and y",
        "parameters": {
            "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
        }
    },
    "glActiveTexture": {
        "signature": "void glActiveTexture(GLenum texture)",
        "purpose": "select active texture unit",
        "parameters": {
            "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation-dependent, but must be at least 32. <parameter>texture</parameter> must be one of `GL_TEXTURE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`. </para> </listitem>"
        }
    },
    "glAttachShader": {
        "signature": "void glAttachShader(GLuint program, GLuint shader)",
        "purpose": "Attaches a shader object to a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
            "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
        }
    },
    "glBeginQuery": {
        "signature": "void glBeginQuery(GLenum target, GLuint id)",
        "purpose": "delimit the boundaries of a query object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
            "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
        }
    },
    "glEndQuery": {
        "signature": "void glEndQuery(GLenum target)",
        "purpose": "delimit the boundaries of a query object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
            "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
        }
    },
    "glBeginTransformFeedback": {
        "signature": "void glBeginTransformFeedback(GLenum primitiveMode)",
        "purpose": "start transform feedback operation",
        "parameters": {
            "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
        }
    },
    "glEndTransformFeedback": {
        "signature": "void glEndTransformFeedback(void)",
        "purpose": "start transform feedback operation",
        "parameters": {
            "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
        }
    },
    "glBindAttribLocation": {
        "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
        "purpose": "Associates a generic vertex attribute index with a named attribute variable",
        "parameters": {
            "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
            "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
        }
    },
    "glBindBuffer": {
        "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
        "purpose": "bind a named buffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target to which the buffer object is bound. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
        }
    },
    "glBindBufferBase": {
        "signature": "void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)",
        "purpose": "bind a buffer object to an indexed buffer target",
        "parameters": {
            "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be either `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
            "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>"
        }
    },
    "glBindBufferRange": {
        "signature": "void glBindBufferRange(GLenumtarget, GLuintindex, GLuintbuffer, GLintptroffset, GLsizeiptrsize)",
        "purpose": "bind a range within a buffer object to an indexed buffer target",
        "parameters": {
            "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be either `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
            "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>",
            "offset": "<listitem> <para> The starting offset in basic machine units into the buffer object <parameter>buffer</parameter>. </para> </listitem>",
            "size": "<listitem> <para> The amount of data in machine units that can be read from the buffet object while used as an indexed target. </para> </listitem>"
        }
    },
    "glBindFramebuffer": {
        "signature": "void glBindFramebuffer(GLenum target, GLuint framebuffer)",
        "purpose": "bind a framebuffer to a framebuffer target",
        "parameters": {
            "target": "<listitem> <para> Specifies the framebuffer target of the binding operation. </para> </listitem>",
            "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object to bind. </para> </listitem>"
        }
    },
    "glBindRenderbuffer": {
        "signature": "void glBindRenderbuffer(GLenum target, GLuint renderbuffer)",
        "purpose": "bind a renderbuffer to a renderbuffer target",
        "parameters": {
            "target": "<listitem> <para> Specifies the renderbuffer target of the binding operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
            "renderbuffer": "<listitem> <para> Specifies the name of the renderbuffer object to bind. </para> </listitem>"
        }
    },
    "glBindSampler": {
        "signature": "void glBindSampler(GLuint unit, GLuint sampler)",
        "purpose": "bind a named sampler to a texturing target",
        "parameters": {
            "unit": "<listitem> <para> Specifies the index of the texture unit to which the sampler is bound. </para> </listitem>",
            "sampler": "<listitem> <para> Specifies the name of a sampler. </para> </listitem>"
        }
    },
    "glBindTexture": {
        "signature": "void glBindTexture(GLenum target, GLuint texture)",
        "purpose": "bind a named texture to a texturing target",
        "parameters": {
            "target": "<listitem> <para> Specifies the target to which the texture is bound. Must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`, </para> </listitem>",
            "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
        }
    },
    "glBindTransformFeedback": {
        "signature": "void glBindTransformFeedback(GLenum target, GLuint id)",
        "purpose": "bind a transform feedback object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target to which to bind the transform feedback object <parameter>id</parameter>. <parameter>target</parameter> must be `GL_TRANSFORM_FEEDBACK`. </para> </listitem>",
            "id": "<listitem> <para> Specifies the name of a transform feedback object reserved by <citerefentry><refentrytitle>glGenTransformFeedbacks</refentrytitle></citerefentry>. </para> </listitem>"
        }
    },
    "glBindVertexArray": {
        "signature": "void glBindVertexArray(GLuint array)",
        "purpose": "bind a vertex array object",
        "parameters": {
            "array": "<listitem> <para> Specifies the name of the vertex array to bind. </para> </listitem>"
        }
    },
    "glBlendColor": {
        "signature": "void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
        "purpose": "set the blend color",
        "parameters": {
            "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
        }
    },
    "glBlendEquation": {
        "signature": "void glBlendEquation(GLenum mode)",
        "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
        "parameters": {
            "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
        }
    },
    "glBlendEquationSeparate": {
        "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
        "purpose": "set the RGB blend equation and the alpha blend equation separately",
        "parameters": {
            "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
            "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
        }
    },
    "glBlendFunc": {
        "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
        "purpose": "specify pixel arithmetic",
        "parameters": {
            "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
            "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
        }
    },
    "glBlendFuncSeparate": {
        "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
        "purpose": "specify pixel arithmetic for RGB and alpha components separately",
        "parameters": {
            "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
            "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
            "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
            "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
        }
    },
    "glBlitFramebuffer": {
        "signature": "void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)",
        "purpose": "copy a block of pixels from the read framebuffer to the draw framebuffer",
        "parameters": {
            "srcX0": "<listitem> <para> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </para> </listitem>",
            "dstX0": "<listitem> <para> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </para> </listitem>",
            "mask": "<listitem> <para> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>",
            "filter": "<listitem> <para> Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`. </para> </listitem>"
        }
    },
    "glBufferData": {
        "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
        "purpose": "creates and initializes a buffer object's data store",
        "parameters": {
            "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "size": "<listitem> <para> Specifies the size in bytes of the buffer object's new data store. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied. </para> </listitem>",
            "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`. </para> </listitem>"
        }
    },
    "glBufferSubData": {
        "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
        "purpose": "updates a subset of a buffer object's data store",
        "parameters": {
            "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
            "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
        }
    },
    "glCheckFramebufferStatus": {
        "signature": "GLenum glCheckFramebufferStatus(GLenum target)",
        "purpose": "check the completeness status of a framebuffer",
        "parameters": {
            "target": "<listitem> <para> Specify the target of the framebuffer completeness check. </para> </listitem>"
        }
    },
    "glClear": {
        "signature": "void glClear(GLbitfield mask)",
        "purpose": "clear buffers to preset values",
        "parameters": {
            "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
        }
    },
    "glClearBufferiv": {
        "signature": "void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value)",
        "purpose": "clear individual buffers of the currently bound draw framebuffer",
        "parameters": {
            "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
            "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
            "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
            "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
            "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
        }
    },
    "glClearBufferuiv": {
        "signature": "void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value)",
        "purpose": "clear individual buffers of the currently bound draw framebuffer",
        "parameters": {
            "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
            "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
            "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
            "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
            "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
        }
    },
    "glClearBufferfv": {
        "signature": "void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value)",
        "purpose": "clear individual buffers of the currently bound draw framebuffer",
        "parameters": {
            "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
            "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
            "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
            "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
            "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
        }
    },
    "glClearBufferfi": {
        "signature": "void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)",
        "purpose": "clear individual buffers of the currently bound draw framebuffer",
        "parameters": {
            "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
            "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
            "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
            "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
            "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
        }
    },
    "glClearColor": {
        "signature": "void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
        "purpose": "specify clear values for the color buffers",
        "parameters": {
            "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
        }
    },
    "glClearDepthf": {
        "signature": "void glClearDepthf(GLfloat depth)",
        "purpose": "specify the clear value for the depth buffer",
        "parameters": {
            "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
        }
    },
    "glClearStencil": {
        "signature": "void glClearStencil(GLint s)",
        "purpose": "specify the clear value for the stencil buffer",
        "parameters": {
            "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
        }
    },
    "glClientWaitSync": {
        "signature": "GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
        "purpose": "block and wait for a sync object to become signaled",
        "parameters": {
            "sync": "<listitem> <para> The sync object whose status to wait on. </para> </listitem>",
            "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> may be `GL_SYNC_FLUSH_COMMANDS_BIT`. </para> </listitem>",
            "timeout": "<listitem> <para> The timeout, specified in nanoseconds, for which the implementation should wait for <parameter>sync</parameter> to become signaled. </para> </listitem>"
        }
    },
    "glColorMask": {
        "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
        "purpose": "enable and disable writing of frame buffer color components",
        "parameters": {
            "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
        }
    },
    "glCompileShader": {
        "signature": "void glCompileShader(GLuint shader)",
        "purpose": "Compiles a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
        }
    },
    "glCompressedTexImage2D": {
        "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
        "purpose": "specify a two-dimensional texture image in a compressed format",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high. </para> </listitem>",
            "border": "<listitem> <para> This value must be 0. </para> </listitem>",
            "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
        }
    },
    "glCompressedTexImage3D": {
        "signature": "void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)",
        "purpose": "specify a three-dimensional texture image in a compressed format",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
            "depth": "<listitem> <para> Specifies the depth of the texture image. </para> </listitem>",
            "border": "<listitem> <para> This value must be 0. </para> </listitem>",
            "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
        }
    },
    "glCompressedTexSubImage2D": {
        "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
        "purpose": "specify a two-dimensional texture subimage in a compressed format",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
            "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
            "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
        }
    },
    "glCompressedTexSubImage3D": {
        "signature": "void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)",
        "purpose": "specify a three-dimensional texture subimage in a compressed format",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
            "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
            "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
            "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
            "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
        }
    },
    "glCopyBufferSubData": {
        "signature": "void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)",
        "purpose": "copy part of the data store of a buffer object to the data store of another buffer object",
        "parameters": {
            "readtarget": "<listitem> <para> Specifies the target from whose data store data should be read. </para> </listitem>",
            "writetarget": "<listitem> <para> Specifies the target to whose data store data should be written. </para> </listitem>",
            "readoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>readtarget</parameter> from which data should be read. </para> </listitem>",
            "writeoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>writetarget</parameter> to which data should be written. </para> </listitem>",
            "size": "<listitem> <para> Specifies the size, in basic machine units, of the data to be copied from <parameter>readtarget</parameter> to <parameter>writetarget</parameter>. </para> </listitem>"
        }
    },
    "glCopyTexImage2D": {
        "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
        "purpose": "copy pixels into a 2D texture image",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_R8`, `GL_RG8`, `GL_RGB565`, `GL_RGB8`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_SRGB8`, `GL_SRGB8_ALPHA8`, `GL_R8I`, `GL_R8UI`, `GL_R16I`, `GL_R16UI`, `GL_R32I`, `GL_R32UI`, `GL_RG8I`, `GL_RG8UI`, `GL_RG16I`, `GL_RG16UI`, `GL_RG32I`, `GL_RG32UI`, `GL_RGBA8I`, `GL_RGBA8UI`, `GL_RGB10_A2UI`, `GL_RGBA16I`, `GL_RGBA16UI`, `GL_RGBA32I`, `GL_RGBA32UI`. </para> </listitem>",
            "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
            "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>"
        }
    },
    "glCopyTexSubImage2D": {
        "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
        "purpose": "copy a two-dimensional texture subimage",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
            "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
            "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
        }
    },
    "glCopyTexSubImage3D": {
        "signature": "void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
        "purpose": "copy a three-dimensional texture subimage",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
            "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
            "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
            "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
        }
    },
    "glCreateProgram": {
        "signature": "GLuint glCreateProgram(void)",
        "purpose": "Creates a program object",
        "parameters": {}
    },
    "glCreateShader": {
        "signature": "GLuint glCreateShader(GLenum shaderType)",
        "purpose": "Creates a shader object",
        "parameters": {
            "shaderType": "<listitem> <para>Specifies the type of shader to be created. Must be one of `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.</para> </listitem>"
        }
    },
    "glCullFace": {
        "signature": "void glCullFace(GLenum mode)",
        "purpose": "specify whether front- or back-facing polygons can be culled",
        "parameters": {
            "mode": "<listitem> <para> Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
        }
    },
    "glDeleteBuffers": {
        "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
        "purpose": "delete named buffer objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
            "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
        }
    },
    "glDeleteFramebuffers": {
        "signature": "void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)",
        "purpose": "delete framebuffer objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of framebuffer objects to be deleted. </para> </listitem>",
            "framebuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> framebuffer objects to be deleted. </para> </listitem>"
        }
    },
    "glDeleteProgram": {
        "signature": "void glDeleteProgram(GLuint program)",
        "purpose": "Deletes a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
        }
    },
    "glDeleteQueries": {
        "signature": "void glDeleteQueries(GLsizei n, const GLuint * ids)",
        "purpose": "delete named query objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of query objects to be deleted. </para> </listitem>",
            "ids": "<listitem> <para> Specifies an array of query objects to be deleted. </para> </listitem>"
        }
    },
    "glDeleteRenderbuffers": {
        "signature": "void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)",
        "purpose": "delete renderbuffer objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of renderbuffer objects to be deleted. </para> </listitem>",
            "renderbuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> renderbuffer objects to be deleted. </para> </listitem>"
        }
    },
    "glDeleteSamplers": {
        "signature": "void glDeleteSamplers(GLsizei n, const GLuint * samplers)",
        "purpose": "delete named sampler objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of sampler objects to be deleted. </para> </listitem>",
            "samplers": "<listitem> <para> Specifies an array of sampler objects to be deleted. </para> </listitem>"
        }
    },
    "glDeleteShader": {
        "signature": "void glDeleteShader(GLuint shader)",
        "purpose": "Deletes a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
        }
    },
    "glDeleteSync": {
        "signature": "void glDeleteSync(GLsync sync)",
        "purpose": "delete a sync object",
        "parameters": {
            "sync": "<listitem> <para> The sync object to be deleted. </para> </listitem>"
        }
    },
    "glDeleteTextures": {
        "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
        "purpose": "delete named textures",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
            "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
        }
    },
    "glDeleteTransformFeedbacks": {
        "signature": "void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)",
        "purpose": "delete transform feedback objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of transform feedback objects to delete. </para> </listitem>",
            "ids": "<listitem> <para> Specifies an array of names of transform feedback objects to delete. </para> </listitem>"
        }
    },
    "glDeleteVertexArrays": {
        "signature": "void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)",
        "purpose": "delete vertex array objects",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of vertex array objects to be deleted. </para> </listitem>",
            "arrays": "<listitem> <para> Specifies the address of an array containing the <parameter>n</parameter> names of the objects to be deleted. </para> </listitem>"
        }
    },
    "glDepthFunc": {
        "signature": "void glDepthFunc(GLenum func)",
        "purpose": "specify the value used for depth buffer comparisons",
        "parameters": {
            "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
        }
    },
    "glDepthMask": {
        "signature": "void glDepthMask(GLboolean flag)",
        "purpose": "enable or disable writing into the depth buffer",
        "parameters": {
            "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
        }
    },
    "glDepthRangef": {
        "signature": "void glDepthRangef(GLfloat n, GLfloat f)",
        "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
        "parameters": {
            "n": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
            "f": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
        }
    },
    "glDetachShader": {
        "signature": "void glDetachShader(GLuint program, GLuint shader)",
        "purpose": "Detaches a shader object from a program object to which it is attached",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
            "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
        }
    },
    "glDrawArrays": {
        "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
        "purpose": "render primitives from array data",
        "parameters": {
            "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
            "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
            "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
        }
    },
    "glDrawArraysInstanced": {
        "signature": "void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount)",
        "purpose": "draw multiple instances of a range of elements",
        "parameters": {
            "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
            "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
            "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>",
            "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
        }
    },
    "glDrawBuffers": {
        "signature": "void glDrawBuffers(GLsizei n, const GLenum *bufs)",
        "purpose": "Specifies a list of color buffers to be drawn into",
        "parameters": {
            "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
            "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
        }
    },
    "glDrawElements": {
        "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
        "purpose": "render primitives from array data",
        "parameters": {
            "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
            "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
            "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
            "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
        }
    },
    "glDrawElementsInstanced": {
        "signature": "void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)",
        "purpose": "draw multiple instances of a set of elements",
        "parameters": {
            "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
            "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
            "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
            "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>",
            "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
        }
    },
    "glDrawRangeElements": {
        "signature": "void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)",
        "purpose": "render primitives from array data",
        "parameters": {
            "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
            "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
            "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
            "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
            "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
            "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
        }
    },
    "glEnable": {
        "signature": "void glEnable(GLenum cap)",
        "purpose": "enable or disable server-side GL capabilities",
        "parameters": {
            "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
        }
    },
    "glDisable": {
        "signature": "void glDisable(GLenum cap)",
        "purpose": "enable or disable server-side GL capabilities",
        "parameters": {
            "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
        }
    },
    "glEnableVertexAttribArray": {
        "signature": "void glEnableVertexAttribArray(GLuint index)",
        "purpose": "Enable or disable a generic vertex attribute array",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
        }
    },
    "glDisableVertexAttribArray": {
        "signature": "void glDisableVertexAttribArray(GLuint index)",
        "purpose": "Enable or disable a generic vertex attribute array",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
        }
    },
    "glFenceSync": {
        "signature": "GLsync glFenceSync(GLenum condition, GLbitfield flags)",
        "purpose": "create a new sync object and insert it into the GL command stream",
        "parameters": {
            "condition": "<listitem> <para> Specifies the condition that must be met to set the sync object's state to signaled. <parameter>condition</parameter> must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. </para> </listitem>",
            "flags": "<listitem> <para> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and <parameter>flags</parameter> must be zero.<footnote><para> <parameter>flags</parameter> is a placeholder for anticipated future extensions of fence sync object capabilities. </para> </footnote> </para> </listitem>"
        }
    },
    "glFinish": {
        "signature": "void glFinish( void)",
        "purpose": "block until all GL execution is complete",
        "parameters": {}
    },
    "glFlush": {
        "signature": "void glFlush( void)",
        "purpose": "force execution of GL commands in finite time",
        "parameters": {}
    },
    "glFlushMappedBufferRange": {
        "signature": "void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)",
        "purpose": "indicate modifications to a range of a mapped buffer",
        "parameters": {
            "target": "<listitem> <para> Specifies the target of the flush operation. <parameter>target</parameter> must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the start of the buffer subrange, in basic machine units. </para> </listitem>",
            "length": "<listitem> <para> Specifies the length of the buffer subrange, in basic machine units. </para> </listitem>"
        }
    },
    "glFramebufferRenderbuffer": {
        "signature": "void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
        "purpose": "attach a renderbuffer as a logical buffer to the currently bound framebuffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
            "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
            "renderbuffertarget": "<listitem> <para> Specifies the renderbuffer target and must be `GL_RENDERBUFFER`. </para> </listitem>",
            "renderbuffer": "<listitem> <para> Specifies the name of an existing renderbuffer object of type <parameter>renderbuffertarget</parameter> to attach. </para> </listitem>"
        }
    },
    "glFramebufferTexture2D": {
        "signature": "void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
        "purpose": "attach a level of a texture object as a logical buffer to the currently bound framebuffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
            "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. </para> </listitem>",
            "textarget": "<listitem> <para> Specifies a 2D texture target, or for cube map textures, which face is to be attached. </para> </listitem>",
            "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
            "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>"
        }
    },
    "glFramebufferTextureLayer": {
        "signature": "void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)",
        "purpose": "attach a single layer of a texture to a framebuffer",
        "parameters": {
            "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
            "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMMENT`. </para> </listitem>",
            "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
            "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>",
            "layer": "<listitem> <para> Specifies the layer of <parameter>texture</parameter> to attach. </para> </listitem>"
        }
    },
    "glFrontFace": {
        "signature": "void glFrontFace(GLenum mode)",
        "purpose": "define front- and back-facing polygons",
        "parameters": {
            "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
        }
    },
    "glGenBuffers": {
        "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
        "purpose": "generate buffer object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
            "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
        }
    },
    "glGenerateMipmap": {
        "signature": "void glGenerateMipmap(GLenum target)",
        "purpose": "generate mipmaps for a specified texture target",
        "parameters": {
            "target": "<listitem> <para> Specifies the target to which the texture whose mimaps to generate is bound. <parameter>target</parameter> must be `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>"
        }
    },
    "glGenFramebuffers": {
        "signature": "void glGenFramebuffers(GLsizei n, GLuint *framebuffers)",
        "purpose": "generate framebuffer object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of framebuffer object names to generate. </para> </listitem>",
            "framebuffers": "<listitem> <para> Specifies an array in which the generated framebuffer object names are stored. </para> </listitem>"
        }
    },
    "glGenQueries": {
        "signature": "void glGenQueries(GLsizei n, GLuint * ids)",
        "purpose": "generate query object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of query object names to be generated. </para> </listitem>",
            "ids": "<listitem> <para> Specifies an array in which the generated query object names are stored. </para> </listitem>"
        }
    },
    "glGenRenderbuffers": {
        "signature": "void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)",
        "purpose": "generate renderbuffer object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of renderbuffer object names to generate. </para> </listitem>",
            "renderbuffers": "<listitem> <para> Specifies an array in which the generated renderbuffer object names are stored. </para> </listitem>"
        }
    },
    "glGenSamplers": {
        "signature": "void glGenSamplers(GLsizei n, GLuint *samplers)",
        "purpose": "generate sampler object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of sampler object names to generate. </para> </listitem>",
            "samplers": "<listitem> <para> Specifies an array in which the generated sampler object names are stored. </para> </listitem>"
        }
    },
    "glGenTextures": {
        "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
        "purpose": "generate texture names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
            "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
        }
    },
    "glGenTransformFeedbacks": {
        "signature": "void glGenTransformFeedbacks(GLsizei n, GLuint *ids)",
        "purpose": "reserve transform feedback object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of transform feedback object names to reserve. </para> </listitem>",
            "ids": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
        }
    },
    "glGenVertexArrays": {
        "signature": "void glGenVertexArrays(GLsizei n, GLuint *arrays)",
        "purpose": "generate vertex array object names",
        "parameters": {
            "n": "<listitem> <para> Specifies the number of vertex array object names to generate. </para> </listitem>",
            "arrays": "<listitem> <para> Specifies an array in which the generated vertex array object names are stored. </para> </listitem>"
        }
    },
    "glGetBooleanv": {
        "signature": "void glGetBooleanv(GLenum pname, GLboolean * data)",
        "purpose": "return the value or values of a selected parameter",
        "parameters": {
            "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
            "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
            "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
        }
    },
    "glGetFloatv": {
        "signature": "void glGetFloatv(GLenum pname, GLfloat * data)",
        "purpose": "return the value or values of a selected parameter",
        "parameters": {
            "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
            "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
            "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
        }
    },
    "glGetIntegerv": {
        "signature": "void glGetIntegerv(GLenum pname, GLint * data)",
        "purpose": "return the value or values of a selected parameter",
        "parameters": {
            "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
            "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
            "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
        }
    },
    "glGetInteger64v": {
        "signature": "void glGetInteger64v(GLenum pname, GLint64 * data)",
        "purpose": "return the value or values of a selected parameter",
        "parameters": {
            "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
            "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
            "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
        }
    },
    "glGetIntegeri_v": {
        "signature": "void glGetIntegeri_v(GLenum target, GLuint index, GLint * data)",
        "purpose": "return the value or values of a selected parameter",
        "parameters": {
            "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
            "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
            "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
        }
    },
    "glGetInteger64i_v": {
        "signature": "void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data)",
        "purpose": "return the value or values of a selected parameter",
        "parameters": {
            "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
            "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
            "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
        }
    },
    "glGetActiveAttrib": {
        "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
        "purpose": "Returns information about an active attribute variable for the specified program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
            "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
            "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
            "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
            "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
            "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
        }
    },
    "glGetActiveUniform": {
        "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
        "purpose": "Returns information about an active uniform variable for the specified program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
            "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
            "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
            "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
            "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
            "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
        }
    },
    "glGetActiveUniformBlockiv": {
        "signature": "void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)",
        "purpose": "query information about an active uniform block",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
            "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the name of the parameter to query. </para> </listitem>",
            "params": "<listitem> <para> Specifies the address of a variable to receive the result of the query. </para> </listitem>"
        }
    },
    "glGetActiveUniformBlockName": {
        "signature": "void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)",
        "purpose": "retrieve the name of an active uniform block",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
            "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
            "bufSize": "<listitem> <para> Specifies the size of the buffer addressed by <parameter>uniformBlockName</parameter>. </para> </listitem>",
            "length": "<listitem> <para> Specifies the address of a variable to receive the number of characters that were written to <parameter>uniformBlockName</parameter>. </para> </listitem>",
            "uniformBlockName": "<listitem> <para> Specifies the address an array of characters to receive the name of the uniform block at <parameter>uniformBlockIndex</parameter>. </para> </listitem>"
        }
    },
    "glGetActiveUniformsiv": {
        "signature": "void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)",
        "purpose": "Returns information about several active uniform variables for the specified program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "uniformCount": "<listitem> <para>Specifies both the number of elements in the array of indices <parameter>uniformIndices</parameter> and the number of parameters written to <parameter>params</parameter> upon successful return.</para> </listitem>",
            "uniformIndices": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers containing the indices of uniforms within <parameter>program</parameter> whose parameter <parameter>pname</parameter> should be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the property of each uniform in <parameter>uniformIndices</parameter> that should be written into the corresponding element of <parameter>params</parameter>.</para> </listitem>",
            "params": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers which are to receive the value of <parameter>pname</parameter> for each uniform in <parameter>uniformIndices</parameter>.</para> </listitem>"
        }
    },
    "glGetAttachedShaders": {
        "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
        "purpose": "Returns the handles of the shader objects attached to a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
            "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
            "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
        }
    },
    "glGetAttribLocation": {
        "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
        "purpose": "Returns the location of an attribute variable",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
        }
    },
    "glGetBufferParameteriv": {
        "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
        "purpose": "return parameters of a buffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
            "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
        }
    },
    "glGetBufferParameteri64v": {
        "signature": "void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data)",
        "purpose": "return parameters of a buffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
            "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
        }
    },
    "glGetBufferPointerv": {
        "signature": "void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)",
        "purpose": "return the pointer to a mapped buffer object's data store",
        "parameters": {
            "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the pointer to be returned. The symbolic constant must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
            "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
        }
    },
    "glGetError": {
        "signature": "GLenum glGetError( void)",
        "purpose": "return error information",
        "parameters": {}
    },
    "glGetFragDataLocation": {
        "signature": "GLint glGetFragDataLocation(GLuint program, const char * name)",
        "purpose": "query the bindings of color numbers to user-defined varying out variables",
        "parameters": {
            "program": "<listitem> <para> The name of the program containing varying out variable whose binding to query </para> </listitem>",
            "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to query </para> </listitem>"
        }
    },
    "glGetFramebufferAttachmentParameteriv": {
        "signature": "void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)",
        "purpose": "retrieve information about attachments of a bound framebuffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target of the query operation. </para> </listitem>",
            "attachment": "<listitem> <para> Specifies the attachment within <parameter>target</parameter> </para> </listitem>",
            "pname": "<listitem> <para> Specifies the parameter of <parameter>attachment</parameter> to query. </para> </listitem>",
            "params": "<listitem> <para> Specifies the address of a variable receive the value of <parameter>pname</parameter> for <parameter>attachment</parameter>. </para> </listitem>"
        }
    },
    "glGetInternalformativ": {
        "signature": "void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)",
        "purpose": "retrieve information about implementation-dependent support for internal formats",
        "parameters": {
            "target": "<listitem> <para> Indicates the usage of the internal format. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the internal format about which to retrieve information. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the type of information to query. </para> </listitem>",
            "bufSize": "<listitem> <para> Specifies the maximum number of integers that may be written to <parameter>params</parameter> by the function. </para> </listitem>",
            "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
        }
    },
    "glGetProgramBinary": {
        "signature": "void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary)",
        "purpose": "return a binary representation of a program object's compiled and linked executable source",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program object whose binary representation to retrieve. </para> </listitem>",
            "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given by <parameter>binary</parameter>. </para> </listitem>",
            "length": "<listitem> <para> Specifies the address of a variable to receive the number of bytes written into <parameter>binary</parameter>. </para> </listitem>",
            "binaryFormat": "<listitem> <para> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </para> </listitem>",
            "binary": "<listitem> <para> Specifies the address an array into which the GL will return <parameter>program</parameter>'s binary representation. </para> </listitem>"
        }
    },
    "glGetProgramInfoLog": {
        "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
        "purpose": "Returns the information log for a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
            "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
            "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
            "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
        }
    },
    "glGetProgramiv": {
        "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
        "purpose": "Returns a parameter from a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_DELETE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_LINK_STATUS`, `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH` and `GL_VALIDATE_STATUS`.</para> </listitem>",
            "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
        }
    },
    "glGetQueryiv": {
        "signature": "void glGetQueryiv(GLenum target, GLenum pname, GLint * params)",
        "purpose": "return parameters of a query object target",
        "parameters": {
            "target": "<listitem> <para> Specifies a query object target. Must be `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Must be `GL_CURRENT_QUERY`. </para> </listitem>",
            "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
        }
    },
    "glGetQueryObjectuiv": {
        "signature": "void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)",
        "purpose": "return parameters of a query object",
        "parameters": {
            "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT` or `GL_QUERY_RESULT_AVAILABLE`. </para> </listitem>",
            "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
        }
    },
    "glGetRenderbufferParameteriv": {
        "signature": "void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)",
        "purpose": "retrieve information about a bound renderbuffer object",
        "parameters": {
            "target": "<listitem> <para> Specifies the target of the query operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the renderbuffer bound to <parameter>target</parameter>. </para> </listitem>",
            "params": "<listitem> <para> Specifies the address of an array to receive the value of the queried parameter. </para> </listitem>"
        }
    },
    "glGetSamplerParameterfv": {
        "signature": "void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params)",
        "purpose": "return sampler parameter values",
        "parameters": {
            "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
            "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
        }
    },
    "glGetSamplerParameteriv": {
        "signature": "void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params)",
        "purpose": "return sampler parameter values",
        "parameters": {
            "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
            "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
        }
    },
    "glGetShaderInfoLog": {
        "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
        "purpose": "Returns the information log for a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
            "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
            "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
            "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
        }
    },
    "glGetShaderiv": {
        "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
        "purpose": "Returns a parameter from a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
            "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
        }
    },
    "glGetShaderPrecisionFormat": {
        "signature": "void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)",
        "purpose": "retrieve the range and precision for numeric formats supported by the shader compiler",
        "parameters": {
            "shaderType": "<listitem> <para> Specifies the type of shader whose precision to query. <parameter>shaderType</parameter> must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
            "precisionType": "<listitem> <para> Specifies the numeric format whose precision and range to query. </para> </listitem>",
            "range": "<listitem> <para> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </para> </listitem>",
            "precision": "<listitem> <para> Specifies the address of an integer into which the numeric precision of the implementation is written. </para> </listitem>"
        }
    },
    "glGetShaderSource": {
        "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
        "purpose": "Returns the source code string from a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
            "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
            "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
            "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
        }
    },
    "glGetString": {
        "signature": "const GLubyte* glGetString(GLenum name)",
        "purpose": "return a string describing the current GL connection",
        "parameters": {
            "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
            "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
        }
    },
    "glGetStringi": {
        "signature": "const GLubyte* glGetStringi(GLenum name, GLuint index)",
        "purpose": "return a string describing the current GL connection",
        "parameters": {
            "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
            "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
        }
    },
    "glGetSynciv": {
        "signature": "void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)",
        "purpose": "query the properties of a sync object",
        "parameters": {
            "sync": "<listitem> <para> Specifies the sync object whose properties to query. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the sync object specified in <parameter>sync</parameter>. </para> </listitem>",
            "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>values</parameter>. </para> </listitem>",
            "length": "<listitem> <para> Specifies the address of an variable to receive the number of integers placed in <parameter>values</parameter>. </para> </listitem>",
            "values": "<listitem> <para> Specifies the address of an array to receive the values of the queried parameter. </para> </listitem>"
        }
    },
    "glGetTexParameterfv": {
        "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
        "purpose": "return texture parameter values",
        "parameters": {
            "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted. </para> </listitem>",
            "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
        }
    },
    "glGetTexParameteriv": {
        "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
        "purpose": "return texture parameter values",
        "parameters": {
            "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted. </para> </listitem>",
            "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
        }
    },
    "glGetTransformFeedbackVarying": {
        "signature": "void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name)",
        "purpose": "retrieve information about varying variables selected for transform feedback",
        "parameters": {
            "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
            "index": "<listitem> <para> The index of the varying variable whose information to retrieve. </para> </listitem>",
            "bufSize": "<listitem> <para> The maximum number of characters, including the null terminator, that may be written into <parameter>name</parameter>. </para> </listitem>",
            "length": "<listitem> <para> The address of a variable which will receive the number of characters written into <parameter>name</parameter>, excluding the null-terminator. If <parameter>length</parameter> is `NULL` no length is returned. </para> </listitem>",
            "size": "<listitem> <para> The address of a variable that will receive the size of the varying. </para> </listitem>",
            "type": "<listitem> <para> The address of a variable that will receive the type of the varying. </para> </listitem>",
            "name": "<listitem> <para> The address of a buffer into which will be written the name of the varying. </para> </listitem>"
        }
    },
    "glGetUniformfv": {
        "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
        "purpose": "Returns the value of a uniform variable",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
            "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
        }
    },
    "glGetUniformiv": {
        "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
        "purpose": "Returns the value of a uniform variable",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
            "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
        }
    },
    "glGetUniformuiv": {
        "signature": "void glGetUniformuiv(GLuint program, GLint location, GLuint *params)",
        "purpose": "Returns the value of a uniform variable",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
            "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
        }
    },
    "glGetUniformBlockIndex": {
        "signature": "GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)",
        "purpose": "retrieve the index of a named uniform block",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
            "uniformBlockName": "<listitem> <para> Specifies the address an array of characters containing the name of the uniform block whose index to retrieve. </para> </listitem>"
        }
    },
    "glGetUniformIndices": {
        "signature": "void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)",
        "purpose": "retrieve the index of a named uniform block",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program containing uniforms whose indices to query. </para> </listitem>",
            "uniformCount": "<listitem> <para> Specifies the number of uniforms whose indices to query. </para> </listitem>",
            "uniformNames": "<listitem> <para> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </para> </listitem>",
            "uniformIndices": "<listitem> <para> Specifies the address of an array that will receive the indices of the uniforms. </para> </listitem>"
        }
    },
    "glGetUniformLocation": {
        "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
        "purpose": "Returns the location of a uniform variable",
        "parameters": {
            "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
            "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
        }
    },
    "glGetVertexAttribfv": {
        "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
        "purpose": "Return a generic vertex attribute parameter",
        "parameters": {
            "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
            "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
        }
    },
    "glGetVertexAttribiv": {
        "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
        "purpose": "Return a generic vertex attribute parameter",
        "parameters": {
            "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
            "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
        }
    },
    "glGetVertexAttribIiv": {
        "signature": "void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)",
        "purpose": "Return a generic vertex attribute parameter",
        "parameters": {
            "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
            "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
        }
    },
    "glGetVertexAttribIuiv": {
        "signature": "void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)",
        "purpose": "Return a generic vertex attribute parameter",
        "parameters": {
            "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
            "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
        }
    },
    "glGetVertexAttribPointerv": {
        "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
        "purpose": "return the address of the specified generic vertex attribute pointer",
        "parameters": {
            "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
            "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
            "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
        }
    },
    "glHint": {
        "signature": "void glHint(GLenum target, GLenum mode)",
        "purpose": "specify implementation-specific hints",
        "parameters": {
            "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_FRAGMENT_SHADER_DERIVATIVE_HINT`, and `GL_GENERATE_MIPMAP_HINT` are accepted. </para> </listitem>",
            "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
        }
    },
    "glInvalidateFramebuffer": {
        "signature": "void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)",
        "purpose": "Invalidate the contents of attachments within a framebuffer",
        "parameters": {
            "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
            "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
            "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>"
        }
    },
    "glInvalidateSubFramebuffer": {
        "signature": "void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLintx, GLinty, GLsizei width, GLsizei height)",
        "purpose": "Invalidate portions of the contents of attachments within a framebuffer",
        "parameters": {
            "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
            "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
            "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>",
            "x": "<listitem> <para> Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
            "y": "<listitem> <para> Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the pixel rectangle to invalidate. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the pixel rectangle to invalidate. </para> </listitem>"
        }
    },
    "glIsBuffer": {
        "signature": "GLboolean glIsBuffer(GLuint buffer)",
        "purpose": "determine if a name corresponds to a buffer object",
        "parameters": {
            "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
        }
    },
    "glIsEnabled": {
        "signature": "GLboolean glIsEnabled(GLenum cap)",
        "purpose": "test whether a capability is enabled",
        "parameters": {
            "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
            "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
        }
    },
    "glIsFramebuffer": {
        "signature": "GLboolean glIsFramebuffer(GLuint framebuffer)",
        "purpose": "determine if a name corresponds to a framebuffer object",
        "parameters": {
            "framebuffer": "<listitem> <para> Specifies a value that may be the name of a framebuffer object. </para> </listitem>"
        }
    },
    "glIsProgram": {
        "signature": "GLboolean glIsProgram(GLuint program)",
        "purpose": "Determines if a name corresponds to a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
        }
    },
    "glIsQuery": {
        "signature": "GLboolean glIsQuery(GLuint id)",
        "purpose": "determine if a name corresponds to a query object",
        "parameters": {
            "id": "<listitem> <para> Specifies a value that may be the name of a query object. </para> </listitem>"
        }
    },
    "glIsRenderbuffer": {
        "signature": "GLboolean glIsRenderbuffer(GLuint renderbuffer)",
        "purpose": "determine if a name corresponds to a renderbuffer object",
        "parameters": {
            "renderbuffer": "<listitem> <para> Specifies a value that may be the name of a renderbuffer object. </para> </listitem>"
        }
    },
    "glIsSampler": {
        "signature": "GLboolean glIsSampler(GLuint id)",
        "purpose": "determine if a name corresponds to a sampler object",
        "parameters": {
            "id": "<listitem> <para> Specifies a value that may be the name of a sampler object. </para> </listitem>"
        }
    },
    "glIsShader": {
        "signature": "GLboolean glIsShader(GLuint shader)",
        "purpose": "Determines if a name corresponds to a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
        }
    },
    "glIsSync": {
        "signature": "GLboolean glIsSync(GLsync sync)",
        "purpose": "determine if a name corresponds to a sync object",
        "parameters": {
            "sync": "<listitem> <para> Specifies a value that may be the name of a sync object. </para> </listitem>"
        }
    },
    "glIsTexture": {
        "signature": "GLboolean glIsTexture(GLuint texture)",
        "purpose": "determine if a name corresponds to a texture",
        "parameters": {
            "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
        }
    },
    "glIsTransformFeedback": {
        "signature": "GLboolean glIsTransformFeedback(GLuint id)",
        "purpose": "determine if a name corresponds to a transform feedback object",
        "parameters": {
            "id": "<listitem> <para> Specifies a value that may be the name of a transform feedback object. </para> </listitem>"
        }
    },
    "glIsVertexArray": {
        "signature": "GLboolean glIsVertexArray(GLuint array)",
        "purpose": "determine if a name corresponds to a vertex array object",
        "parameters": {
            "array": "<listitem> <para> Specifies a value that may be the name of a vertex array object. </para> </listitem>"
        }
    },
    "glLineWidth": {
        "signature": "void glLineWidth(GLfloat width)",
        "purpose": "specify the width of rasterized lines",
        "parameters": {
            "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
        }
    },
    "glLinkProgram": {
        "signature": "void glLinkProgram(GLuint program)",
        "purpose": "Links a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
        }
    },
    "glMapBufferRange": {
        "signature": "void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)",
        "purpose": "map a section of a buffer object's data store",
        "parameters": {
            "target": "<listitem> <para> Specifies a binding to which the target buffer is bound. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
            "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
            "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
        }
    },
    "glUnmapBuffer": {
        "signature": "GLboolean glUnmapBuffer(GLenum target)",
        "purpose": "map a section of a buffer object's data store",
        "parameters": {
            "target": "<listitem> <para> Specifies a binding to which the target buffer is bound. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
            "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
            "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
        }
    },
    "glPauseTransformFeedback": {
        "signature": "void glPauseTransformFeedback(void)",
        "purpose": "pause transform feedback operations",
        "parameters": {}
    },
    "glPixelStorei": {
        "signature": "void glPixelStorei(GLenum pname, GLint param)",
        "purpose": "set pixel storage modes",
        "parameters": {
            "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Four values affect the packing of pixel data into memory: `GL_PACK_ROW_LENGTH`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
            "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
        }
    },
    "glPolygonOffset": {
        "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
        "purpose": "set the scale and units used to calculate depth values",
        "parameters": {
            "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
            "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
        }
    },
    "glProgramBinary": {
        "signature": "void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)",
        "purpose": "load a program object with a program binary",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program object into which to load a program binary. </para> </listitem>",
            "binaryFormat": "<listitem> <para> Specifies the format of the binary data in binary. </para> </listitem>",
            "binary": "<listitem> <para> Specifies the address of an array containing the binary to be loaded into <parameter>program</parameter>. </para> </listitem>",
            "length": "<listitem> <para> Specifies the number of bytes contained in <parameter>binary</parameter>. </para> </listitem>"
        }
    },
    "glProgramParameteri": {
        "signature": "void glProgramParameteri(GLuint program, GLenum pname, GLint value)",
        "purpose": "specify a parameter for a program object",
        "parameters": {
            "program": "<listitem> <para> Specifies the name of a program object whose parameter to modify. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the name of the parameter to modify. </para> </listitem>",
            "value": "<listitem> <para> Specifies the new value of the parameter specified by <parameter>pname</parameter> for <parameter>program</parameter>. </para> </listitem>"
        }
    },
    "glReadBuffer": {
        "signature": "void glReadBuffer(GLenum src)",
        "purpose": "select a color buffer source for pixels",
        "parameters": {
            "src": "<listitem> <para> Specifies a color buffer. Accepted values are `GL_BACK`, `GL_NONE`, and `GL_COLOR_ATTACHMENTi`. </para> </listitem>"
        }
    },
    "glReadPixels": {
        "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
        "purpose": "read a block of pixels from the frame buffer",
        "parameters": {
            "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
            "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RGBA`, and `GL_RGBA_INTEGER`. An implementation-chosen format will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_FORMAT`. </para> </listitem>",
            "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_INT`, `GL_INT`, or `GL_FLOAT`. An implementation-chosen type will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_TYPE`. </para> </listitem>",
            "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
        }
    },
    "glReleaseShaderCompiler": {
        "signature": "void glReleaseShaderCompiler(void)",
        "purpose": "release resources consumed by the implementation's shader compiler",
        "parameters": {}
    },
    "glRenderbufferStorage": {
        "signature": "void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)",
        "purpose": "establish data storage, format and dimensions of a renderbuffer object's image",
        "parameters": {
            "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
        }
    },
    "glRenderbufferStorageMultisample": {
        "signature": "void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)",
        "purpose": "establish data storage, format, dimensions and sample count of a renderbuffer object's image",
        "parameters": {
            "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
            "samples": "<listitem> <para> Specifies the number of samples to be used for the renderbuffer object's storage. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
        }
    },
    "glResumeTransformFeedback": {
        "signature": "void glResumeTransformFeedback(void)",
        "purpose": "resume transform feedback operations",
        "parameters": {}
    },
    "glSampleCoverage": {
        "signature": "void glSampleCoverage(GLfloat value, GLboolean invert)",
        "purpose": "specify multisample coverage parameters",
        "parameters": {
            "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
            "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
        }
    },
    "glSamplerParameterf": {
        "signature": "void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)",
        "purpose": "set sampler parameters",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
            "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glSamplerParameteri": {
        "signature": "void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)",
        "purpose": "set sampler parameters",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
            "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glSamplerParameterfv": {
        "signature": "void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params)",
        "purpose": "set sampler parameters",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
            "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glSamplerParameteriv": {
        "signature": "void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params)",
        "purpose": "set sampler parameters",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
            "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glScissor": {
        "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
        "purpose": "define the scissor box",
        "parameters": {
            "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
            "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
        }
    },
    "glShaderBinary": {
        "signature": "void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)",
        "purpose": "load pre-compiled shader binaries",
        "parameters": {
            "count": "<listitem> <para> Specifies the number of shader object handles contained in <parameter>shaders</parameter>. </para> </listitem>",
            "shaders": "<listitem> <para> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </para> </listitem>",
            "binaryFormat": "<listitem> <para> Specifies the format of the shader binaries contained in <parameter>binary</parameter>. </para> </listitem>",
            "binary": "<listitem> <para> Specifies the address of an array of bytes containing pre-compiled binary shader code. </para> </listitem>",
            "length": "<listitem> <para> Specifies the length of the array whose address is given in <parameter>binary</parameter>. </para> </listitem>"
        }
    },
    "glShaderSource": {
        "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)",
        "purpose": "Replaces the source code in a shader object",
        "parameters": {
            "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
            "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
            "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
            "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
        }
    },
    "glStencilFunc": {
        "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
        "purpose": "set front and back function and reference value for stencil testing",
        "parameters": {
            "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
            "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
            "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
        }
    },
    "glStencilFuncSeparate": {
        "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
        "purpose": "set front and/or back function and reference value for stencil testing",
        "parameters": {
            "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
            "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
            "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
            "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
        }
    },
    "glStencilMask": {
        "signature": "void glStencilMask(GLuint mask)",
        "purpose": "control the front and back writing of individual bits in the stencil planes",
        "parameters": {
            "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
        }
    },
    "glStencilMaskSeparate": {
        "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
        "purpose": "control the front and/or back writing of individual bits in the stencil planes",
        "parameters": {
            "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
            "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
        }
    },
    "glStencilOp": {
        "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
        "purpose": "set front and back stencil test actions",
        "parameters": {
            "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
            "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
            "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
        }
    },
    "glStencilOpSeparate": {
        "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
        "purpose": "set front and/or back stencil test actions",
        "parameters": {
            "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
            "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
            "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
            "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
        }
    },
    "glTexImage2D": {
        "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
        "purpose": "specify a two-dimensional texture image",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high. </para> </listitem>",
            "border": "<listitem> <para> This value must be 0. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
            "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
        }
    },
    "glTexImage3D": {
        "signature": "void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data)",
        "purpose": "specify a three-dimensional texture image",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be one of `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"> <msup><mi mathvariant=\"italic\">n</mi> <mi mathvariant=\"italic\">th</mi> </msup> </math></inlineequation> mipmap reduction image. </para> </listitem>",
            "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </para> </listitem>",
            "depth": "<listitem> <para> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </para> </listitem>",
            "border": "<listitem> <para> This value must be 0. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`, </para> </listitem>",
            "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
        }
    },
    "glTexParameterf": {
        "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
        "purpose": "set texture parameters",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
            "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glTexParameteri": {
        "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
        "purpose": "set texture parameters",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
            "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glTexParameterfv": {
        "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
        "purpose": "set texture parameters",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
            "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glTexParameteriv": {
        "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
        "purpose": "set texture parameters",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
            "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
            "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
            "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
        }
    },
    "glTexStorage2D": {
        "signature": "void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)",
        "purpose": "simultaneously specify storage for all levels of a two-dimensional texture",
        "parameters": {
            "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_2D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
            "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>"
        }
    },
    "glTexStorage3D": {
        "signature": "void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)",
        "purpose": "simultaneously specify storage for all levels of a three-dimensional or two-dimensional array texture",
        "parameters": {
            "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_3D`, or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
            "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
            "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
            "depth": "<listitem> <para> Specifies the depth of the texture, in texels. </para> </listitem>"
        }
    },
    "glTexSubImage2D": {
        "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
        "purpose": "specify a two-dimensional texture subimage",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
            "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
            "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
        }
    },
    "glTexSubImage3D": {
        "signature": "void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
        "purpose": "specify a three-dimensional texture subimage",
        "parameters": {
            "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
            "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
            "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
            "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
            "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
            "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
            "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
            "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
            "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
            "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
            "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
        }
    },
    "glTransformFeedbackVaryings": {
        "signature": "void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode)",
        "purpose": "specify values to record in transform feedback buffers",
        "parameters": {
            "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
            "count": "<listitem> <para> The number of varying variables used for transform feedback. </para> </listitem>",
            "varyings": "<listitem> <para> An array of <parameter>count</parameter> zero-terminated strings specifying the names of the varying variables to use for transform feedback. </para> </listitem>",
            "bufferMode": "<listitem> <para> Identifies the mode used to capture the varying variables when transform feedback is active. <parameter>bufferMode</parameter> must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`. </para> </listitem>"
        }
    },
    "glUniform1f": {
        "signature": "void glUniform1f(GLint location, GLfloat v0)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform2f": {
        "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform3f": {
        "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform4f": {
        "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform1i": {
        "signature": "void glUniform1i(GLint location, GLint v0)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform2i": {
        "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform3i": {
        "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform4i": {
        "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform1ui": {
        "signature": "void glUniform1ui(GLint location, GLuint v0)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform2ui": {
        "signature": "void glUniform2ui(GLint location, GLuint v0, GLuint v1)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform3ui": {
        "signature": "void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform4ui": {
        "signature": "void glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform1fv": {
        "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform2fv": {
        "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform3fv": {
        "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform4fv": {
        "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform1iv": {
        "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform2iv": {
        "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform3iv": {
        "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform4iv": {
        "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform1uiv": {
        "signature": "void glUniform1uiv(GLint location, GLsizei count, const GLuint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform2uiv": {
        "signature": "void glUniform2uiv(GLint location, GLsizei count, const GLuint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform3uiv": {
        "signature": "void glUniform3uiv(GLint location, GLsizei count, const GLuint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniform4uiv": {
        "signature": "void glUniform4uiv(GLint location, GLsizei count, const GLuint *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix2fv": {
        "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix3fv": {
        "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix4fv": {
        "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix2x3fv": {
        "signature": "void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix3x2fv": {
        "signature": "void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix2x4fv": {
        "signature": "void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix4x2fv": {
        "signature": "void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix3x4fv": {
        "signature": "void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformMatrix4x3fv": {
        "signature": "void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
        "purpose": "Specify the value of a uniform variable for the current program object",
        "parameters": {
            "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
            "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
            "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
            "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
        }
    },
    "glUniformBlockBinding": {
        "signature": "void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)",
        "purpose": "assign a binding point to an active uniform block",
        "parameters": {
            "program": "<listitem> <para> The name of a program object containing the active uniform block whose binding to assign. </para> </listitem>",
            "uniformBlockIndex": "<listitem> <para> The index of the active uniform block within <parameter>program</parameter> whose binding to assign. </para> </listitem>",
            "uniformBlockBinding": "<listitem> <para> Specifies the binding point to which to bind the uniform block with index <parameter>uniformBlockIndex</parameter> within <parameter>program</parameter>. </para> </listitem>"
        }
    },
    "glUseProgram": {
        "signature": "void glUseProgram(GLuint program)",
        "purpose": "Installs a program object as part of current rendering state",
        "parameters": {
            "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
        }
    },
    "glValidateProgram": {
        "signature": "void glValidateProgram(GLuint program)",
        "purpose": "Validates a program object",
        "parameters": {
            "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
        }
    },
    "glVertexAttrib1f": {
        "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib2f": {
        "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib3f": {
        "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib4f": {
        "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttribI4i": {
        "signature": "void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttribI4ui": {
        "signature": "void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib1fv": {
        "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib2fv": {
        "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib3fv": {
        "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttrib4fv": {
        "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttribI4iv": {
        "signature": "void glVertexAttribI4iv(GLuint index, const GLint *v)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttribI4uiv": {
        "signature": "void glVertexAttribI4uiv(GLuint index, const GLuint *v)",
        "purpose": "Specifies the value of a generic vertex attribute",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
            "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
        }
    },
    "glVertexAttribDivisor": {
        "signature": "void glVertexAttribDivisor(GLuint index, GLuint divisor)",
        "purpose": "modify the rate at which generic vertex attributes advance during instanced rendering",
        "parameters": {
            "index": "<listitem> <para> Specify the index of the generic vertex attribute. </para> </listitem>",
            "divisor": "<listitem> <para> Specify the number of instances that will pass between updates of the generic attribute at slot <parameter>index</parameter>. </para> </listitem>"
        }
    },
    "glVertexAttribPointer": {
        "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
        "purpose": "define an array of generic vertex attribute data",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
            "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
            "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
            "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
            "pointer": "<listitem> <para>Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0.</para> </listitem>"
        }
    },
    "glVertexAttribIPointer": {
        "signature": "void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)",
        "purpose": "define an array of generic vertex attribute data",
        "parameters": {
            "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
            "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
            "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
            "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
            "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
            "pointer": "<listitem> <para>Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0.</para> </listitem>"
        }
    },
    "glViewport": {
        "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
        "purpose": "set the viewport",
        "parameters": {
            "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
            "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
        }
    },
    "glWaitSync": {
        "signature": "void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
        "purpose": "instruct the GL server to block until the specified sync object becomes signaled",
        "parameters": {
            "sync": "<listitem> <para> Specifies the sync object whose status to wait on. </para> </listitem>",
            "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> must be zero. </para> </listitem>",
            "timeout": "<listitem> <para> Specifies the timeout that the server should wait before continuing. <parameter>timeout</parameter> must be `GL_TIMEOUT_IGNORED`. </para> </listitem>"
        }
    },
    "greaterThan": {
        "signature": "bvec greaterThan(uvec x, uvec y)",
        "purpose": "perform a component-wise greater-than comparison of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
        }
    },
    "greaterThanEqual": {
        "signature": "bvec greaterThanEqual(uvec x, uvec y)",
        "purpose": "perform a component-wise greater-than-or-equal comparison of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
        }
    },
    "intBitsToFloat": {
        "signature": "genType intBitsToFloat(genIType x)",
        "purpose": "produce a floating point using an encoding supplied as an integer",
        "parameters": {
            "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
        }
    },
    "uintBitsToFloat": {
        "signature": "genType uintBitsToFloat(genUType x)",
        "purpose": "produce a floating point using an encoding supplied as an integer",
        "parameters": {
            "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
        }
    },
    "inverse": {
        "signature": "mat4 inverse(mat4 m)",
        "purpose": "calculate the inverse of a matrix",
        "parameters": {
            "m": "<listitem> <para> Specifies the matrix of which to take the inverse. </para> </listitem>"
        }
    },
    "inversesqrt": {
        "signature": "genType inversesqrt(genType x)",
        "purpose": "return the inverse of the square root of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value of which to take the inverse of the square root. </para> </listitem>"
        }
    },
    "isinf": {
        "signature": "genBType isinf(genType x)",
        "purpose": "determine whether the parameter is positive or negative infinity",
        "parameters": {
            "x": "<listitem> <para> Specifies the value to test for infinity. </para> </listitem>"
        }
    },
    "isnan": {
        "signature": "genBType isnan(genType x)",
        "purpose": "determine whether the parameter is a number",
        "parameters": {
            "x": "<listitem> <para> Specifies the value to test for NaN. </para> </listitem>"
        }
    },
    "length": {
        "signature": "float length(genType x)",
        "purpose": "calculate the length of a vector",
        "parameters": {
            "x": "<listitem> <para> Specifies a vector of which to calculate the length. </para> </listitem>"
        }
    },
    "lessThan": {
        "signature": "bvec lessThan(uvec x, uvec y)",
        "purpose": "perform a component-wise less-than comparison of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
        }
    },
    "lessThanEqual": {
        "signature": "bvec lessThanEqual(uvec x, uvec y)",
        "purpose": "perform a component-wise less-than-or-equal comparison of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
        }
    },
    "log": {
        "signature": "genType log(genType x)",
        "purpose": "return the natural logarithm of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value of which to take the natural logarithm. </para> </listitem>"
        }
    },
    "log2": {
        "signature": "genType log2(genType x)",
        "purpose": "return the base 2 logarithm of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value of which to take the base 2 logarithm. </para> </listitem>"
        }
    },
    "matrixCompMult": {
        "signature": "mat matrixCompMult(mat x, mat y)",
        "purpose": "perform a component-wise multiplication of two matrices",
        "parameters": {
            "x": "<listitem> <para> Specifies the first matrix multiplicand. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second matrix multiplicand. </para> </listitem>"
        }
    },
    "max": {
        "signature": "genUType max(genUType x, uint y)",
        "purpose": "return the greater of two values",
        "parameters": {
            "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
            "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
        }
    },
    "min": {
        "signature": "genUType min(genUType x, uint y)",
        "purpose": "return the lesser of two values",
        "parameters": {
            "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
            "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
        }
    },
    "mix": {
        "signature": "genType mix(genType x, genType y, genBType a)",
        "purpose": "linearly interpolate between two values",
        "parameters": {
            "x": "<listitem> <para> Specify the start of the range in which to interpolate. </para> </listitem>",
            "y": "<listitem> <para> Specify the end of the range in which to interpolate. </para> </listitem>",
            "a": "<listitem> <para> Specify the value to use to interpolate between <parameter>x</parameter> and <parameter>y</parameter>. </para> </listitem>"
        }
    },
    "mod": {
        "signature": "genType mod(genType x, genType y)",
        "purpose": "compute value of one parameter modulo another",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>",
            "y": "<listitem> <para> Specify the value by which to perform the modulo. </para> </listitem>"
        }
    },
    "modf": {
        "signature": "genType modf(genType x, out genType i)",
        "purpose": "separate a value into its integer and fractional components",
        "parameters": {
            "x": "<listitem> <para> Specify the value to separate. </para> </listitem>",
            "out i": "<listitem> <para> A variable that receives the integer part of the argument. </para> </listitem>"
        }
    },
    "normalize": {
        "signature": "genType normalize(genType v)",
        "purpose": "calculates the unit vector in the same direction as the original vector",
        "parameters": {
            "v": "<listitem> <para> Specifies the vector to normalize. </para> </listitem>"
        }
    },
    "not": {
        "signature": "bvec not(bvec x)",
        "purpose": "logically invert a boolean vector",
        "parameters": {
            "x": "<listitem> <para> Specifies the vector to be inverted. </para> </listitem>"
        }
    },
    "notEqual": {
        "signature": "bvec notEqual(uvec x, uvec y)",
        "purpose": "perform a component-wise not-equal-to comparison of two vectors",
        "parameters": {
            "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
            "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
        }
    },
    "outerProduct": {
        "signature": "mat4x3 outerProduct(vec3 c, vec4 r)",
        "purpose": "calculate the outer product of a pair of vectors",
        "parameters": {
            "c": "<listitem> <para> Specifies the parameter to be treated as a column vector. </para> </listitem>",
            "r": "<listitem> <para> Specifies the parameter to be treated as a row vector. </para> </listitem>"
        }
    },
    "packHalf2x16": {
        "signature": "uint packHalf2x16(vec2 v)",
        "purpose": "convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer",
        "parameters": {
            "v": "<listitem> <para> Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result. </para> </listitem>"
        }
    },
    "packUnorm2x16": {
        "signature": "uint packUnorm2x16(vec2 v)",
        "purpose": "pack floating-point values into an unsigned integer",
        "parameters": {
            "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
        }
    },
    "packSnorm2x16": {
        "signature": "uint packSnorm2x16(vec2 v)",
        "purpose": "pack floating-point values into an unsigned integer",
        "parameters": {
            "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
        }
    },
    "pow": {
        "signature": "genType pow(genType x, genType y)",
        "purpose": "return the value of the first parameter raised to the power of the second",
        "parameters": {
            "x": "<listitem> <para> Specify the value to raise to the power <parameter>y</parameter>. </para> </listitem>",
            "y": "<listitem> <para> Specify the power to which to raise <parameter>x</parameter>. </para> </listitem>"
        }
    },
    "radians": {
        "signature": "genType radians(genType degrees)",
        "purpose": "convert a quantity in degrees to radians",
        "parameters": {
            "degrees": "<listitem> <para> Specify the quantity, in degrees, to be converted to radians. </para> </listitem>"
        }
    },
    "reflect": {
        "signature": "genType reflect(genType I, genType N)",
        "purpose": "calculate the reflection direction for an incident vector",
        "parameters": {
            "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
            "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>"
        }
    },
    "refract": {
        "signature": "genType refract(genType I, genType N, float eta)",
        "purpose": "calculate the refraction direction for an incident vector",
        "parameters": {
            "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
            "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>",
            "eta": "<listitem> <para> Specifies the ratio of indices of refraction. </para> </listitem>"
        }
    },
    "round": {
        "signature": "genType round(genType x)",
        "purpose": "find the nearest integer to the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
        }
    },
    "roundEven": {
        "signature": "genType roundEven(genType x)",
        "purpose": "find the nearest even integer to the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
        }
    },
    "sign": {
        "signature": "genIType sign(genIType x)",
        "purpose": "extract the sign of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value from which to extract the sign. </para> </listitem>"
        }
    },
    "sin": {
        "signature": "genType sin(genType angle)",
        "purpose": "return the sine of the parameter",
        "parameters": {
            "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the sine. </para> </listitem>"
        }
    },
    "sinh": {
        "signature": "genType sinh(genType x)",
        "purpose": "return the hyperbolic sine of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose hyperbolic sine to return. </para> </listitem>"
        }
    },
    "smoothstep": {
        "signature": "genType smoothstep(float edge0, float edge1, genType x)",
        "purpose": "perform Hermite interpolation between two values",
        "parameters": {
            "edge0": "<listitem> <para> Specifies the value of the lower edge of the Hermite function. </para> </listitem>",
            "edge1": "<listitem> <para> Specifies the value of the upper edge of the Hermite function. </para> </listitem>",
            "x": "<listitem> <para> Specifies the source value for interpolation. </para> </listitem>"
        }
    },
    "sqrt": {
        "signature": "genType sqrt(genType x)",
        "purpose": "return the square root of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value of which to take the square root. </para> </listitem>"
        }
    },
    "step": {
        "signature": "genType step(float edge, genType x)",
        "purpose": "generate a step function by comparing two values",
        "parameters": {
            "edge": "<listitem> <para> Specifies the location of the edge of the step function. </para> </listitem>",
            "x": "<listitem> <para> Specify the value to be used to generate the step function. </para> </listitem>"
        }
    },
    "tan": {
        "signature": "genType tan(genType angle)",
        "purpose": "return the tangent of the parameter",
        "parameters": {
            "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the tangent. </para> </listitem>"
        }
    },
    "tanh": {
        "signature": "genType tanh(genType x)",
        "purpose": "return the hyperbolic tangent of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value whose hyperbolic tangent to return. </para> </listitem>"
        }
    },
    "texelFetch": {
        "signature": "gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod)",
        "purpose": "perform a lookup of a single texel within a texture",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>"
        }
    },
    "texelFetchOffset": {
        "signature": "gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)",
        "purpose": "perform a lookup of a single texel within a texture with an offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
            "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>"
        }
    },
    "texture": {
        "signature": "float texture(sampler2DArrayShadow sampler, vec4 P)",
        "purpose": "retrieves texels from a texture",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
        }
    },
    "textureGrad": {
        "signature": "float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
        "purpose": "perform a texture lookup with explicit gradients",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
            "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
        }
    },
    "textureGradOffset": {
        "signature": "float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
        "purpose": "perform a texture lookup with explicit gradients and offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
            "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the offset to be applied to the texture coordinates before sampling. </para> </listitem>"
        }
    },
    "textureLod": {
        "signature": "gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)",
        "purpose": "perform a texture lookup with explicit level-of-detail",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "lod": "<listitem> <para> Specifies the explicit level-of-detail </para> </listitem>"
        }
    },
    "textureLodOffset": {
        "signature": "gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset)",
        "purpose": "perform a texture lookup with explicit level-of-detail and offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
            "lod": "<listitem> <para> Specifies the explicit level-of-detail from which texels will be fetched. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the offset that will be applied to <parameter>P</parameter> before texels are fetched. </para> </listitem>"
        }
    },
    "textureOffset": {
        "signature": "gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias)",
        "purpose": "perform a texture lookup with offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>",
            "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
        }
    },
    "textureProj": {
        "signature": "float textureProj(sampler2DShadow sampler, vec4 P, [float bias)",
        "purpose": "perform a texture lookup with projection",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
        }
    },
    "textureProjGrad": {
        "signature": "float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
        "purpose": "perform a texture lookup with projection and explicit gradients",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
            "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
        }
    },
    "textureProjGradOffset": {
        "signature": "float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
        "purpose": "perform a texture lookup with projection, explicit gradients and offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
            "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the offsets, in texels at which the texture will be sampled relative to the projection of <parameter>P</parameter>. </para> </listitem>"
        }
    },
    "textureProjLod": {
        "signature": "float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)",
        "purpose": "perform a texture lookup with projection and explicit level-of-detail",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>"
        }
    },
    "textureProjLodOffset": {
        "signature": "float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)",
        "purpose": "perform a texture lookup with projection and explicit level-of-detail and offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
            "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the offset, in texels, to be applied to <parameter>P</parameter> before fetching texels. </para> </listitem>"
        }
    },
    "textureProjOffset": {
        "signature": "float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias)",
        "purpose": "perform a texture lookup with projection and offset",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
            "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
            "offset": "<listitem> <para> Specifies the offset that is applied to <parameter>P</parameter> before sampling occurs. </para> </listitem>",
            "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
        }
    },
    "textureSize": {
        "signature": "ivec3 textureSize(sampler2DArrayShadow sampler, int lod)",
        "purpose": "retrieve the dimensions of a level of a texture",
        "parameters": {
            "sampler": "<listitem> <para> Specifies the sampler to which the texture whose dimensions to retrieve is bound. </para> </listitem>",
            "lod": "<listitem> <para> Specifies the level of the texture for which to retrieve the dimensions. </para> </listitem>"
        }
    },
    "transpose": {
        "signature": "mat4x3 transpose(mat3x4 m)",
        "purpose": "calculate the transpose of a matrix",
        "parameters": {
            "m": "<listitem> <para> Specifies the matrix of which to take the transpose. </para> </listitem>"
        }
    },
    "trunc": {
        "signature": "genType trunc(genType x)",
        "purpose": "find the truncated value of the parameter",
        "parameters": {
            "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
        }
    },
    "unpackHalf2x16": {
        "signature": "vec2 unpackHalf2x16(uint v)",
        "purpose": "convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities",
        "parameters": {
            "v": "<listitem> <para> Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked. </para> </listitem>"
        }
    },
    "unpackUnorm2x16": {
        "signature": "vec2 unpackUnorm2x16(uint p)",
        "purpose": "unpack floating-point values from an unsigned integer",
        "parameters": {
            "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
        }
    },
    "unpackSnorm2x16": {
        "signature": "vec2 unpackSnorm2x16(uint p)",
        "purpose": "unpack floating-point values from an unsigned integer",
        "parameters": {
            "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
        }
    }
}
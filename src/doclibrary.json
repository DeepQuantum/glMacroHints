{
  "es1.1": {
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select server-side active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. <parameter>texture</parameter> must be one of `GL_TEXTURE`<replaceable>i</replaceable>, where <inlineequation><math> <mn>0</mn> <mo>=</mo> <mi>i</mi> <mo /> <mi>GL_MAX_TEXTURE_UNITS</mi> </math></inlineequation>, which is an implementation-dependent value. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAlphaFunc": {
      "signature": "void glAlphaFunc(GLenum func, GLclampf ref)",
      "purpose": "specify the alpha test function",
      "parameters": {
        "func": "<listitem> <para>Specifies the alpha comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para>Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0, 1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0. </para> </listitem>"
      }
    },
    "glAlphaFuncx": {
      "signature": "void glAlphaFuncx(GLenum func, GLclampx ref)",
      "purpose": "specify the alpha test function",
      "parameters": {
        "func": "<listitem> <para>Specifies the alpha comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para>Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0, 1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0. </para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer to a target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer is bound. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "buffer": "<listitem> <para>Specifies the name of a buffer object.</para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para>Specifies the target to which the texture is bound. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "texture": "<listitem> <para>Specifies the name of a texture.</para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, and `GL_SRC_ALPHA_SATURATE`. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para>Specifies how the red, green, blue, and alpha destination blending factors are computed. Eight symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, and `GL_ONE_MINUS_DST_ALPHA`. The initial value is `GL_ZERO`.</para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data store.",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "size": "<listitem> <para>Specifies the size in bytes of the buffer object's new data store.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.</para> </listitem>",
        "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STATIC_DRAW` or `GL_DYNAMIC_DRAW`. </para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "updates a subset of a buffer object's data store.",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para>Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</para> </listitem>",
        "size": "<listitem> <para>Specifies the size in bytes of the data store region being replaced.</para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store.</para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para>Bitwise OR of masks that indicate the buffers to be cleared. Valid masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`.</para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)",
      "purpose": "specify clear values for the color buffer",
      "parameters": {
        "red": "<listitem> <para>Specify the red, green, blue, and alpha values used when the color buffer is cleared. The initial values are all 0.</para> </listitem>"
      }
    },
    "glClearColorx": {
      "signature": "void glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)",
      "purpose": "specify clear values for the color buffer",
      "parameters": {
        "red": "<listitem> <para>Specify the red, green, blue, and alpha values used when the color buffer is cleared. The initial values are all 0.</para> </listitem>"
      }
    },
    "glClearDepthf": {
      "signature": "void glClearDepthf(GLclampf depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para>Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</para> </listitem>"
      }
    },
    "glClearDepthx": {
      "signature": "void glClearDepthx(GLclampx depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para>Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para>Specifies the index used when the stencil buffer is cleared. The initial value is 0.</para> </listitem>"
      }
    },
    "glClientActiveTexture": {
      "signature": "void glClientActiveTexture(GLenum texture)",
      "purpose": "select client-side active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. <parameter>texture</parameter> must be one of `GL_TEXTURE`<replaceable>i</replaceable>, <inlineequation><math> <mn>0</mn> <mo>=</mo> <mi>i</mi> <mo /> <mi>GL_MAX_TEXTURE_UNITS</mi> </math></inlineequation>, which is an implementation-dependent value. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glClipPlanef": {
      "signature": "void glClipPlanef(GLenum plane, const GLfloat *equation)",
      "purpose": "specify a plane against which all geometry is    clipped",
      "parameters": {
        "plane": "<listitem> <para>Specifies which clipping plane is being positioned. Symbolic names of the form `GL_CLIP_PLANE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> is an integer between 0 and `GL_MAX_CLIP_PLANES` <inlineequation> <math> <mn>-1</mn> </math> </inlineequation>, are accepted.</para> </listitem>",
        "equation": "<listitem> <para>Specifies the address of an array of four fixed-point or floating-point values. These are the coefficients of a plane equation in object coordinates: <emphasis>p1</emphasis>, <emphasis>p2</emphasis>, <emphasis>p3</emphasis>, and <emphasis>p4</emphasis>, in that order.</para> </listitem>"
      }
    },
    "glClipPlanex": {
      "signature": "void glClipPlanex(GLenum plane, const GLfixed *equation)",
      "purpose": "specify a plane against which all geometry is    clipped",
      "parameters": {
        "plane": "<listitem> <para>Specifies which clipping plane is being positioned. Symbolic names of the form `GL_CLIP_PLANE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> is an integer between 0 and `GL_MAX_CLIP_PLANES` <inlineequation> <math> <mn>-1</mn> </math> </inlineequation>, are accepted.</para> </listitem>",
        "equation": "<listitem> <para>Specifies the address of an array of four fixed-point or floating-point values. These are the coefficients of a plane equation in object coordinates: <emphasis>p1</emphasis>, <emphasis>p2</emphasis>, <emphasis>p3</emphasis>, and <emphasis>p4</emphasis>, in that order.</para> </listitem>"
      }
    },
    "glColor4f": {
      "signature": "void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para>Specify new red, green, blue, and alpha values for the current color.</para> </listitem>"
      }
    },
    "glColor4x": {
      "signature": "void glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para>Specify new red, green, blue, and alpha values for the current color.</para> </listitem>"
      }
    },
    "glColor4ub": {
      "signature": "void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para>Specify new red, green, blue, and alpha values for the current color.</para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of color buffer        components",
      "parameters": {
        "red": "<listitem> <para>Specify whether red, green, blue, and alpha can or cannot be written into the color buffer. The initial values are all `GL_TRUE`, indicating that all color components can be written.</para> </listitem>"
      }
    },
    "glColorPointer": {
      "signature": "void glColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of colors",
      "parameters": {
        "size": "<listitem> <para>Specifies the number of components per color. Must be 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each color component in the array. Symbolic constants `GL_UNSIGNED_BYTE` and `GL_FIXED` are accepted. However, the initial value is `GL_FLOAT`.</para> <para> The common profile accepts the symbolic constant `GL_FLOAT` as well. </para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive colors. If <parameter>stride</parameter> is 0, the colors are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first component of the first color element in the array.</para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional compressed texture image",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. For paletted formats, where all mipmap levels are loaded at once, this parameter is overloaded to represent the negative of the greatest mipmap level included in <parameter>data</parameter>. </para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the color components in the texture. The following symbolic constants are accepted: `GL_PALETTE4_RGB8_OES`, `GL_PALETTE4_RGBA8_OES`, `GL_PALETTE4_R5_G6_B5_OES`, `GL_PALETTE4_RGBA4_OES`, `GL_PALETTE4_RGB5_A1_OES`, `GL_PALETTE8_RGB8_OES`, `GL_PALETTE8_RGBA8_OES`, `GL_PALETTE8_R5_G6_B5_OES`, `GL_PALETTE8_RGBA4_OES`, and `GL_PALETTE8_RGB5_A1_OES`.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture image. Must be <inlineequation><math> <msup><mn>2</mn><mi>n</mi></msup> </math></inlineequation> for some integer <replaceable>n</replaceable>. All implementations support texture images that are at least 64 texels wide.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture image. Must be <inlineequation><math> <msup><mn>2</mn><mi>m</mi></msup> </math></inlineequation> for some integer <replaceable>m</replaceable>. All implementations support texture images that are at least 64 texels high.</para> </listitem>",
        "border": "<listitem> <para>Specifies the width of the border. Must be 0.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the size of the compressed image data in bytes.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional compressed texture subimage",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the pixel data. Currently, there is no supported format.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the size of the compressed pixel data in bytes.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "specify a two-dimensional texture image with pixels from the color buffer",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <parameter>n</parameter> is the <parameter>n</parameter>th mipmap reduction image.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the color components of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, or `GL_RGBA`.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture image. Must be 0 or <inlineequation><math> <msup><mn>2</mn><mi>n</mi></msup> </math></inlineequation> for some integer <replaceable>n</replaceable>.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture image. Must be 0 or <inlineequation><math> <msup><mn>2</mn><mi>m</mi></msup> </math></inlineequation> for some integer <replaceable>m</replaceable>.</para> </listitem>",
        "border": "<listitem> <para>Specifies the width of the border. Must be 0.</para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "specify a two-dimensional texture subimage with pixels from the color buffer",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <parameter>n</parameter> is the <parameter>n</parameter>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing polygons are        culled",
      "parameters": {
        "mode": "<listitem> <para>Specifies whether front- or back-facing polygons are culled. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`.</para> </listitem>"
      }
    },
    "glCurrentPaletteMatrixOES": {
      "signature": "void glCurrentPaletteMatrixOES(GLuint index)",
      "purpose": "        defines which of the palette's matrices is affected by        subsequent matrix operations        ",
      "parameters": {
        "index": "<listitem> <para> specifies the index into the palette's matrices. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffer objects to be deleted.</para> </listitem>",
        "buffers": "<listitem> <para>Specifies an array of buffer object names to be deleted.</para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of textures to be deleted.</para> </listitem>",
        "textures": "<listitem> <para>Specifies an array of textures to be deleted.</para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para>Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`.</para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para>Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled, otherwise it is enabled. The initial value is `GL_TRUE`.</para> </listitem>"
      }
    },
    "glDepthRangef": {
      "signature": "void glDepthRangef(GLclampf near, GLclampf far)",
      "purpose": "specify mapping of depth values from normalized        device coordinates to window coordinates",
      "parameters": {
        "near": "<listitem> <para>Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.</para> </listitem>",
        "far": "<listitem> <para>Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.</para> </listitem>"
      }
    },
    "glDepthRangex": {
      "signature": "void glDepthRangex(GLclampx near, GLclampx far)",
      "purpose": "specify mapping of depth values from normalized        device coordinates to window coordinates",
      "parameters": {
        "near": "<listitem> <para>Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.</para> </listitem>",
        "far": "<listitem> <para>Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.</para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para>Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, and `GL_TRIANGLES` are accepted.</para> </listitem>",
        "first": "<listitem> <para>Specifies the starting index in the enabled arrays.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of indices to be rendered.</para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para>Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, and `GL_TRIANGLES` are accepted.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements to be rendered.</para> </listitem>",
        "type": "<listitem> <para>Specifies the type of the values in <parameter>indices</parameter>. Must be either `GL_UNSIGNED_BYTE` or `GL_UNSIGNED_SHORT`.</para> </listitem>",
        "indices": "<listitem> <para>Specifies a pointer to the location where the indices are stored.</para> </listitem>"
      }
    },
    "glDrawTexsOES": {
      "signature": "void glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexiOES": {
      "signature": "void glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexfOES": {
      "signature": "void glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexxOES": {
      "signature": "void glDrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexsvOES": {
      "signature": "void glDrawTexsvOES(GLshort* coords)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexivOES": {
      "signature": "void glDrawTexivOES(GLint* coords)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexfvOES": {
      "signature": "void glDrawTexfvOES(GLfloat* coords)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glDrawTexxvOES": {
      "signature": "void glDrawTexxvOES(GLfixed* coords)",
      "purpose": "draws a texture rectangle to the screen",
      "parameters": {
        "x": "<listitem> <para> Specify the position of the affected screen rectangle. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height of the affected screen rectangle in pixels. </para> </listitem>",
        "coords": "<listitem> <para> Specifies a pointer to the coords for the affected screen rectangle. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para>Specifies a symbolic constant indicating a GL capability.</para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para>Specifies a symbolic constant indicating a GL capability.</para> </listitem>"
      }
    },
    "glEnableClientState": {
      "signature": "void glEnableClientState(GLenum array)",
      "purpose": "enable or disable client-side capability",
      "parameters": {
        "array": "<listitem> <para> Specifies the capability to enable or disable. Symbolic constants `GL_COLOR_ARRAY`, <constant revision=\"OES_matrix_palette\">GL_MATRIX_INDEX_ARRAY_OES`<phrase revision=\"OES_matrix_palette\">,</phrase> `GL_NORMAL_ARRAY`, <constant revision=\"es1.1\">GL_POINT_SIZE_ARRAY_OES`<phrase revision=\"es1.1\">,</phrase> `GL_TEXTURE_COORD_ARRAY`,<phrase revision=\"not-OES_matrix_palette\"> and</phrase> `GL_VERTEX_ARRAY`<phrase revision=\"OES_matrix_palette\">, and</phrase> <constant revision=\"OES_matrix_palette\">GL_WEIGHT_ARRAY_OES` are accepted. </para> </listitem>"
      }
    },
    "glDisableClientState": {
      "signature": "void glDisableClientState(GLenum array)",
      "purpose": "enable or disable client-side capability",
      "parameters": {
        "array": "<listitem> <para> Specifies the capability to enable or disable. Symbolic constants `GL_COLOR_ARRAY`, <constant revision=\"OES_matrix_palette\">GL_MATRIX_INDEX_ARRAY_OES`<phrase revision=\"OES_matrix_palette\">,</phrase> `GL_NORMAL_ARRAY`, <constant revision=\"es1.1\">GL_POINT_SIZE_ARRAY_OES`<phrase revision=\"es1.1\">,</phrase> `GL_TEXTURE_COORD_ARRAY`,<phrase revision=\"not-OES_matrix_palette\"> and</phrase> `GL_VERTEX_ARRAY`<phrase revision=\"OES_matrix_palette\">, and</phrase> <constant revision=\"OES_matrix_palette\">GL_WEIGHT_ARRAY_OES` are accepted. </para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish()",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush()",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFogf": {
      "signature": "void glFogf(GLenum pname, GLfloat param)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, and `GL_FOG_END` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>pname</parameter> will be set to.</para> </listitem>"
      }
    },
    "glFogx": {
      "signature": "void glFogx(GLenum pname, GLfixed param)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, and `GL_FOG_END` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>pname</parameter> will be set to.</para> </listitem>"
      }
    },
    "glFogfv": {
      "signature": "void glFogfv(GLenum pname, const GLfloat * params)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, and `GL_FOG_END` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>pname</parameter> will be set to.</para> </listitem>"
      }
    },
    "glFogxv": {
      "signature": "void glFogxv(GLenum pname, const GLfixed * params)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, and `GL_FOG_END` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>pname</parameter> will be set to.</para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para>Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`.</para> </listitem>"
      }
    },
    "glFrustumf": {
      "signature": "void glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat near, GLfloat far)",
      "purpose": "multiply the current matrix by a perspective matrix",
      "parameters": {
        "left": "<listitem> <para>Specify the coordinates for the left and right vertical clipping planes.</para> </listitem>",
        "bottom": "<listitem> <para>Specify the coordinates for the bottom and top horizontal clipping planes.</para> </listitem>",
        "near": "<listitem> <para>Specify the distances to the near and far depth clipping planes. Both distances must be positive.</para> </listitem>"
      }
    },
    "glFrustumx": {
      "signature": "void glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed near, GLfixed far)",
      "purpose": "multiply the current matrix by a perspective matrix",
      "parameters": {
        "left": "<listitem> <para>Specify the coordinates for the left and right vertical clipping planes.</para> </listitem>",
        "bottom": "<listitem> <para>Specify the coordinates for the bottom and top horizontal clipping planes.</para> </listitem>",
        "near": "<listitem> <para>Specify the distances to the near and far depth clipping planes. Both distances must be positive.</para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffer object names to be generated.</para> </listitem>",
        "buffers": "<listitem> <para>Specifies an array in which the generated buffer object names are stored.</para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of texture names to be generated.</para> </listitem>",
        "textures": "<listitem> <para>Specifies an array in which the generated texture names are stored.</para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para>Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the value or values of the specified parameter.</para> </listitem>"
      }
    },
    "glGetFixedv": {
      "signature": "void glGetFixedv(GLenum pname, GLfixed * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para>Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the value or values of the specified parameter.</para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para>Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the value or values of the specified parameter.</para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para>Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the value or values of the specified parameter.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`. </para> </listitem>",
        "params": "<listitem> <para>Returns the requested parameter.</para> </listitem>"
      }
    },
    "glGetClipPlanef": {
      "signature": "void glGetClipPlanef(GLenum plane, GLfloat *equation)",
      "purpose": "return the coefficients of the specified clipping    plane",
      "parameters": {
        "plane": "<listitem> <para>Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. Symbolic names of the form `GL_CLIP_PLANE` <emphasis>i</emphasis>, where <emphasis>i</emphasis> is an integer between 0 and `GL_MAX_CLIP_PLANES` <inlineequation> <math> <mn>-1</mn> </math> </inlineequation>, are accepted.</para> </listitem>",
        "equation": "<listitem> <para>Returns four fixed-point or floating-point values that are the coefficients of the plane equation of <parameter>plane</parameter> in eye coordinates in the order <emphasis>p1</emphasis>, <emphasis>p2</emphasis>, <emphasis>p3</emphasis>, and <emphasis>p4</emphasis>. The initial value is (0, 0, 0, 0).</para> </listitem>"
      }
    },
    "glGetClipPlanex": {
      "signature": "void glGetClipPlanex(GLenum plane, GLfixed *equation)",
      "purpose": "return the coefficients of the specified clipping    plane",
      "parameters": {
        "plane": "<listitem> <para>Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. Symbolic names of the form `GL_CLIP_PLANE` <emphasis>i</emphasis>, where <emphasis>i</emphasis> is an integer between 0 and `GL_MAX_CLIP_PLANES` <inlineequation> <math> <mn>-1</mn> </math> </inlineequation>, are accepted.</para> </listitem>",
        "equation": "<listitem> <para>Returns four fixed-point or floating-point values that are the coefficients of the plane equation of <parameter>plane</parameter> in eye coordinates in the order <emphasis>p1</emphasis>, <emphasis>p2</emphasis>, <emphasis>p3</emphasis>, and <emphasis>p4</emphasis>. The initial value is (0, 0, 0, 0).</para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError()",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetLightfv": {
      "signature": "void glGetLightfv(GLenum light, GLenum pname, GLfloat * params)",
      "purpose": "return light source parameter values",
      "parameters": {
        "light": "<listitem> <para> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form <inlineequation><math> <mi>GL_LIGHTi</mi> where <mi>0</mi><mo /><mi>i</mi><mo /> <mi>GL_MAX_LIGHTS</mi> </math></inlineequation> </para> </listitem>",
        "pname": "<listitem> <para> Specifies a light source parameter for light. Accepted symbolic names are `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_POSITION`, `GL_SPOT_DIRECTION`, `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetLightxv": {
      "signature": "void glGetLightxv(GLenum light, GLenum pname, GLfixed * params)",
      "purpose": "return light source parameter values",
      "parameters": {
        "light": "<listitem> <para> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form <inlineequation><math> <mi>GL_LIGHTi</mi> where <mi>0</mi><mo /><mi>i</mi><mo /> <mi>GL_MAX_LIGHTS</mi> </math></inlineequation> </para> </listitem>",
        "pname": "<listitem> <para> Specifies a light source parameter for light. Accepted symbolic names are `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_POSITION`, `GL_SPOT_DIRECTION`, `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMaterialfv": {
      "signature": "void glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params)",
      "purpose": "return material parameters values",
      "parameters": {
        "face": "<listitem> <para> Specifies which of the two materials is being queried. `GL_FRONT` or `GL_BACK` are accepted, representing the front and back materials, respectively. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the material parameter to return. Accepted symbolic names are `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_EMISSION`, and `GL_SHININESS`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMaterialxv": {
      "signature": "void glGetMaterialxv(GLenum face, GLenum pname, GLfixed * params)",
      "purpose": "return material parameters values",
      "parameters": {
        "face": "<listitem> <para> Specifies which of the two materials is being queried. `GL_FRONT` or `GL_BACK` are accepted, representing the front and back materials, respectively. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the material parameter to return. Accepted symbolic names are `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_EMISSION`, and `GL_SHININESS`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetPointerv": {
      "signature": "void glGetPointerv(GLenum pname, void ** params)",
      "purpose": "return the address of the specified pointer",
      "parameters": {
        "pname": "<listitem> <para> Specifies the array or buffer pointer to be returned. Accepted symbolic names are `GL_COLOR_ARRAY_POINTER`, <constant revision=\"OES_matrix_palette\">GL_MATRIX_INDEX_ARRAY_POINTER_OES`<phrase revision=\"OES_matrix_palette\">,</phrase> `GL_NORMAL_ARRAY_POINTER`, <constant revision=\"es1.1\">GL_POINT_SIZE_ARRAY_POINTER_OES`<phrase revision=\"es1.1\">,</phrase> `GL_TEXTURE_COORD_ARRAY_POINTER`,<phrase revision=\"not-OES_matrix_palette\"> and</phrase> `GL_VERTEX_ARRAY_POINTER`<phrase revision=\"not-OES_matrix_palette\">.</phrase><phrase revision=\"OES_matrix_palette\">, and</phrase> <constant revision=\"OES_matrix_palette\">GL_WEIGHT_ARRAY_POINTER_OES`<phrase revision=\"OES_matrix_palette\">.</phrase> </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte * glGetString(GLenum name)",
      "purpose": "return a string describing the current GL        connection",
      "parameters": {
        "name": "<listitem> <para>Specifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, or `GL_EXTENSIONS`.</para> </listitem>"
      }
    },
    "glGetTexEnvfv": {
      "signature": "void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture environment parameter. Accepted values are `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_ENV_COLOR`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexEnviv": {
      "signature": "void glGetTexEnviv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture environment parameter. Accepted values are `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_ENV_COLOR`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexEnvxv": {
      "signature": "void glGetTexEnvxv(GLenum target, GLenum pname, GLfixed * params)",
      "purpose": "return texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture environment parameter. Accepted values are `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_ENV_COLOR`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "params": "<listitem> <para>Returns texture parameters.</para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "params": "<listitem> <para>Returns texture parameters.</para> </listitem>"
      }
    },
    "glGetTexParameterxv": {
      "signature": "void glGetTexParameterxv(GLenum target, GLenum pname, GLfixed * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "params": "<listitem> <para>Returns texture parameters.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para>Specifies a symbolic constant indicating the behavior to be controlled. `GL_FOG_HINT` , `GL_GENERATE_MIPMAP_HINT` , `GL_LINE_SMOOTH_HINT` , `GL_PERSPECTIVE_CORRECTION_HINT`, and `GL_POINT_SMOOTH_HINT` are accepted.</para> </listitem>",
        "mode": "<listitem> <para>Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted.</para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glLightf": {
      "signature": "void glLightf(GLenum light, GLenum pname, GLfloat param)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para>Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT`<replaceable>i</replaceable> where <inlineequation><math> <mn>0</mn> <mo>=</mo> <mi>i</mi> <mo /> <mi>GL_MAX_LIGHTS</mi> </math></inlineequation>. </para> </listitem>",
        "pname": "<listitem> <para>Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightx": {
      "signature": "void glLightx(GLenum light, GLenum pname, GLfixed param)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para>Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT`<replaceable>i</replaceable> where <inlineequation><math> <mn>0</mn> <mo>=</mo> <mi>i</mi> <mo /> <mi>GL_MAX_LIGHTS</mi> </math></inlineequation>. </para> </listitem>",
        "pname": "<listitem> <para>Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightfv": {
      "signature": "void glLightfv(GLenum light, GLenum pname, const GLfloat * params)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para>Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT`<replaceable>i</replaceable> where <inlineequation><math> <mn>0</mn> <mo>=</mo> <mi>i</mi> <mo /> <mi>GL_MAX_LIGHTS</mi> </math></inlineequation>. </para> </listitem>",
        "pname": "<listitem> <para>Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightxv": {
      "signature": "void glLightxv(GLenum light, GLenum pname, const GLfixed * params)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para>Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT`<replaceable>i</replaceable> where <inlineequation><math> <mn>0</mn> <mo>=</mo> <mi>i</mi> <mo /> <mi>GL_MAX_LIGHTS</mi> </math></inlineequation>. </para> </listitem>",
        "pname": "<listitem> <para>Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightModelf": {
      "signature": "void glLightModelf(GLenum pname, GLfloat param)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued lighting model parameter. Must be `GL_LIGHT_MODEL_TWO_SIDE`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>param</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightModelx": {
      "signature": "void glLightModelx(GLenum pname, GLfixed param)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued lighting model parameter. Must be `GL_LIGHT_MODEL_TWO_SIDE`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>param</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightModelfv": {
      "signature": "void glLightModelfv(GLenum pname, const GLfloat * params)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued lighting model parameter. Must be `GL_LIGHT_MODEL_TWO_SIDE`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>param</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLightModelxv": {
      "signature": "void glLightModelxv(GLenum pname, const GLfixed * params)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies a single-valued lighting model parameter. Must be `GL_LIGHT_MODEL_TWO_SIDE`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>param</parameter> will be set to.</para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para>Specifies the width of rasterized lines. The initial value is 1.</para> </listitem>"
      }
    },
    "glLineWidthx": {
      "signature": "void glLineWidthx(GLfixed width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para>Specifies the width of rasterized lines. The initial value is 1.</para> </listitem>"
      }
    },
    "glLoadIdentity": {
      "signature": "void glLoadIdentity()",
      "purpose": "replace the current matrix with the identity\tmatrix",
      "parameters": {}
    },
    "glLoadMatrixf": {
      "signature": "void glLoadMatrixf(const GLfloat * m)",
      "purpose": "replace the current matrix with the specified\tmatrix",
      "parameters": {
        "m": "<listitem> <para>Specifies a pointer to 16 consecutive values, which are used as the elements of a <inlineequation><math> <mn>4</mn><mo>x</mo><mn>4</mn> </math></inlineequation> column-major matrix.</para> </listitem>"
      }
    },
    "glLoadMatrixx": {
      "signature": "void glLoadMatrixx(const GLfixed * m)",
      "purpose": "replace the current matrix with the specified\tmatrix",
      "parameters": {
        "m": "<listitem> <para>Specifies a pointer to 16 consecutive values, which are used as the elements of a <inlineequation><math> <mn>4</mn><mo>x</mo><mn>4</mn> </math></inlineequation> column-major matrix.</para> </listitem>"
      }
    },
    "glLoadPaletteFromModelViewMatrixOES": {
      "signature": "void glLoadPaletteFromModelViewMatrixOES()",
      "purpose": "        copies the current model view matrix to a        matrix in the current matrix palette        ",
      "parameters": {}
    },
    "glLogicOp": {
      "signature": "void glLogicOp(GLenum opcode)",
      "purpose": "specify a logical pixel operation",
      "parameters": {
        "opcode": "<listitem> <para>Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: `GL_CLEAR`, `GL_SET`, `GL_COPY`, `GL_COPY_INVERTED`, `GL_NOOP`, `GL_INVERT`, `GL_AND`, `GL_NAND`, `GL_OR`, `GL_NOR`, `GL_XOR`, `GL_EQUIV`, `GL_AND_REVERSE`, `GL_AND_INVERTED`, `GL_OR_REVERSE`, and `GL_OR_INVERTED`. The initial value is `GL_COPY`.</para> </listitem>"
      }
    },
    "glMaterialf": {
      "signature": "void glMaterialf(GLenum face, GLenum pname, GLfloat param)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para>Specifies which face or faces are being updated. Must be `GL_FRONT_AND_BACK`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter `GL_SHININESS` will be set to.</para> </listitem>"
      }
    },
    "glMaterialx": {
      "signature": "void glMaterialx(GLenum face, GLenum pname, GLfixed param)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para>Specifies which face or faces are being updated. Must be `GL_FRONT_AND_BACK`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter `GL_SHININESS` will be set to.</para> </listitem>"
      }
    },
    "glMaterialfv": {
      "signature": "void glMaterialfv(GLenum face, GLenum pname, const GLfloat * params)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para>Specifies which face or faces are being updated. Must be `GL_FRONT_AND_BACK`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter `GL_SHININESS` will be set to.</para> </listitem>"
      }
    },
    "glMaterialxv": {
      "signature": "void glMaterialxv(GLenum face, GLenum pname, const GLfixed * params)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para>Specifies which face or faces are being updated. Must be `GL_FRONT_AND_BACK`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that parameter `GL_SHININESS` will be set to.</para> </listitem>"
      }
    },
    "glMatrixIndexPointerOES": {
      "signature": "void glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of matrix indices",
      "parameters": {
        "size": "<listitem> <para> Specifies the number of matrix indices per vertex. Must be is less than or equal to `GL_MAX_VERTEX_UNITS_OES`. The initial value is `0`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of each matrix index in the array. Symbolic constant `GL_UNSIGNED_BYTE` is accepted. The initial value is `GL_UNSIGNED_BYTE`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive matrix indices. If <parameter>stride</parameter> is 0, the matrix indices are understood to be tightly packed in the array. The initial value is `0`. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first matrix index of the first vertex in the array. The initial value is `0`. </para> </listitem>"
      }
    },
    "glMatrixMode": {
      "signature": "void glMatrixMode(GLenum mode)",
      "purpose": "specify which matrix is the current matrix",
      "parameters": {
        "mode": "<listitem> <para> Specifies which matrix stack is the target for subsequent matrix operations. These values are accepted: `GL_MODELVIEW`, `GL_PROJECTION`,<phrase revision=\"not-OES_matrix_palette\"> and</phrase> `GL_TEXTURE`<phrase revision=\"not-OES_matrix_palette\">.</phrase><phrase revision=\"OES_matrix_palette\">, and</phrase> <constant revision=\"OES_matrix_palette\">GL_MATRIX_PALETTE_OES`<phrase revision=\"OES_matrix_palette\">.</phrase> The initial value is `GL_MODELVIEW`. </para> </listitem>"
      }
    },
    "glMultiTexCoord4f": {
      "signature": "void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para>Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least <phrase revision=\"es1.1\">two</phrase><phrase revision=\"not-es1.1\">one</phrase>. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_UNITS` - 1, which is an implementation-dependent value.</para> </listitem>",
        "s": "<listitem> <para>Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit.</para> </listitem>"
      }
    },
    "glMultiTexCoord4x": {
      "signature": "void glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para>Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least <phrase revision=\"es1.1\">two</phrase><phrase revision=\"not-es1.1\">one</phrase>. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_UNITS` - 1, which is an implementation-dependent value.</para> </listitem>",
        "s": "<listitem> <para>Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit.</para> </listitem>"
      }
    },
    "glMultMatrixf": {
      "signature": "void glMultMatrixf(const GLfloat * m)",
      "purpose": "multiply the current matrix with the specified\tmatrix",
      "parameters": {
        "m": "<listitem> <para>Points to 16 consecutive values that are used as the elements of a <inlineequation><math> <mn>4</mn><mo>x</mo><mn>4</mn> </math></inlineequation> column-major matrix.</para> </listitem>"
      }
    },
    "glMultMatrixx": {
      "signature": "void glMultMatrixx(const GLfixed * m)",
      "purpose": "multiply the current matrix with the specified\tmatrix",
      "parameters": {
        "m": "<listitem> <para>Points to 16 consecutive values that are used as the elements of a <inlineequation><math> <mn>4</mn><mo>x</mo><mn>4</mn> </math></inlineequation> column-major matrix.</para> </listitem>"
      }
    },
    "glNormal3f": {
      "signature": "void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para>Specify the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> coordinates of the new current normal. The initial value is (0, 0, 1).</para> </listitem>"
      }
    },
    "glNormal3x": {
      "signature": "void glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para>Specify the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> coordinates of the new current normal. The initial value is (0, 0, 1).</para> </listitem>"
      }
    },
    "glNormalPointer": {
      "signature": "void glNormalPointer(GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of normals",
      "parameters": {
        "type": "<listitem> <para>Specifies the data type of each coordinate in the array. Symbolic constants `GL_BYTE`, `GL_SHORT`, and `GL_FIXED` are accepted. However, the initial value is `GL_FLOAT`.</para> <para> The common profile accepts the symbolic constant `GL_FLOAT` as well. </para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive normals. If <parameter>stride</parameter> is 0, the normals are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.</para> </listitem>"
      }
    },
    "glOrthof": {
      "signature": "void glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat near, GLfloat far)",
      "purpose": "multiply the current matrix with an orthographic\tmatrix",
      "parameters": {
        "left": "<listitem> <para>Specify the coordinates for the left and right vertical clipping planes.</para> </listitem>",
        "bottom": "<listitem> <para>Specify the coordinates for the bottom and top horizontal clipping planes.</para> </listitem>",
        "near": "<listitem> <para>Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer.</para> </listitem>"
      }
    },
    "glOrthox": {
      "signature": "void glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed near, GLfixed far)",
      "purpose": "multiply the current matrix with an orthographic\tmatrix",
      "parameters": {
        "left": "<listitem> <para>Specify the coordinates for the left and right vertical clipping planes.</para> </listitem>",
        "bottom": "<listitem> <para>Specify the coordinates for the bottom and top horizontal clipping planes.</para> </listitem>",
        "near": "<listitem> <para>Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer.</para> </listitem>"
      }
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of the parameter to be set. `GL_PACK_ALIGNMENT` affects the packing of pixel data into memory. `GL_UNPACK_ALIGNMENT` affects the unpacking of pixel data <parameter>from</parameter> memory.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value that <parameter>pname</parameter> is set to.</para> </listitem>"
      }
    },
    "glPointParameterf": {
      "signature": "void glPointParameterf(GLenum pname, GLfloat param)",
      "purpose": "specify parameters for point rasterization",
      "parameters": {
        "pname": "<listitem> <para> Specifies the single-valued parameter to be updated. Can be either `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, or `GL_POINT_FADE_THRESHOLD_SIZE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that the parameter will be set to. </para> </listitem>"
      }
    },
    "glPointParameterx": {
      "signature": "void glPointParameterx(GLenum pname, GLfixed param)",
      "purpose": "specify parameters for point rasterization",
      "parameters": {
        "pname": "<listitem> <para> Specifies the single-valued parameter to be updated. Can be either `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, or `GL_POINT_FADE_THRESHOLD_SIZE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that the parameter will be set to. </para> </listitem>"
      }
    },
    "glPointParameterfv": {
      "signature": "void glPointParameterfv(GLenum pname, const GLfloat * params)",
      "purpose": "specify parameters for point rasterization",
      "parameters": {
        "pname": "<listitem> <para> Specifies the single-valued parameter to be updated. Can be either `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, or `GL_POINT_FADE_THRESHOLD_SIZE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that the parameter will be set to. </para> </listitem>"
      }
    },
    "glPointParameterxv": {
      "signature": "void glPointParameterxv(GLenum pname, const GLfixed * params)",
      "purpose": "specify parameters for point rasterization",
      "parameters": {
        "pname": "<listitem> <para> Specifies the single-valued parameter to be updated. Can be either `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, or `GL_POINT_FADE_THRESHOLD_SIZE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that the parameter will be set to. </para> </listitem>"
      }
    },
    "glPointSize": {
      "signature": "void glPointSize(GLfloat size)",
      "purpose": "specify the diameter of rasterized points",
      "parameters": {
        "size": "<listitem> <para>Specifies the diameter of rasterized points. The initial value is 1.</para> </listitem>"
      }
    },
    "glPointSizex": {
      "signature": "void glPointSizex(GLfixed size)",
      "purpose": "specify the diameter of rasterized points",
      "parameters": {
        "size": "<listitem> <para>Specifies the diameter of rasterized points. The initial value is 1.</para> </listitem>"
      }
    },
    "glPointSizePointerOES": {
      "signature": "void glPointSizePointerOES(GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of point sizes",
      "parameters": {
        "type": "<listitem> <para> Specifies the data type of each point size in the array. Symbolic constant `GL_FIXED` is accepted. However, the common profile also accepts the symbolic constant `GL_FLOAT`. The initial value is `GL_FIXED` for the common lite profile, or `GL_FLOAT` for the common profile. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive point sizes. If <parameter>stride</parameter> is 0, the point sizes are understood to be tightly packed in the array. The initial value is `0`. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the point size of the first vertex in the array. The initial value is `0`. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth        values",
      "parameters": {
        "factor": "<listitem> <para>Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.</para> </listitem>",
        "units": "<listitem> <para>Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.</para> </listitem>"
      }
    },
    "glPolygonOffsetx": {
      "signature": "void glPolygonOffsetx(GLfixed factor, GLfixed units)",
      "purpose": "set the scale and units used to calculate depth        values",
      "parameters": {
        "factor": "<listitem> <para>Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.</para> </listitem>",
        "units": "<listitem> <para>Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.</para> </listitem>"
      }
    },
    "glPushMatrix": {
      "signature": "void glPushMatrix()",
      "purpose": "push and pop the current matrix stack",
      "parameters": {}
    },
    "glPopMatrix": {
      "signature": "void glPopMatrix()",
      "purpose": "push and pop the current matrix stack",
      "parameters": {}
    },
    "glQueryMatrixxOES": {
      "signature": "GLbitfield glQueryMatrixxOES(GLfixed * mantissa, GLint * exponent)",
      "purpose": "return the values of the current matrix",
      "parameters": {
        "mantissa": "<listitem> <para>Returns the mantissa values of the current matrix.</para> </listitem>",
        "exponent": "<listitem> <para>Returns the exponents of the current matrix.</para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)",
      "purpose": "read a block of pixels from the color buffer",
      "parameters": {
        "x": "<listitem> <para>Specify the window coordinates of the first pixel that is read from the color buffer. This location is the lower left corner of a rectangular block of pixels.</para> </listitem>",
        "width": "<listitem> <para>Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the pixel data. Must be either `GL_RGBA` or the value of `GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES`.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of the pixel data. Must be either `GL_UNSIGNED_BYTE` or the value of `GL_IMPLEMENTATION_COLOR_READ_TYPE_OES`.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the pixel data.</para> </listitem>"
      }
    },
    "glRotatef": {
      "signature": "void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "multiply the current matrix by a rotation matrix",
      "parameters": {
        "angle": "<listitem> <para>Specifies the angle of rotation, in degrees.</para> </listitem>",
        "x": "<listitem> <para>Specify the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> coordinates of a vector, respectively.</para> </listitem>"
      }
    },
    "glRotatex": {
      "signature": "void glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)",
      "purpose": "multiply the current matrix by a rotation matrix",
      "parameters": {
        "angle": "<listitem> <para>Specifies the angle of rotation, in degrees.</para> </listitem>",
        "x": "<listitem> <para>Specify the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> coordinates of a vector, respectively.</para> </listitem>"
      }
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLclampf value, GLboolean invert)",
      "purpose": "specify mask to modify multisampled pixel fragments",
      "parameters": {
        "value": "<listitem> <para>Specifies the coverage of the modification mask. The value is clamped to the range [0, 1], where 0 represents no coverage and 1 full coverage. The initial value is 1.</para> </listitem>",
        "invert": "<listitem> <para>Specifies whether the modification mask implied by <parameter>value</parameter> is inverted or not. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glSampleCoveragex": {
      "signature": "void glSampleCoveragex(GLclampx value, GLboolean invert)",
      "purpose": "specify mask to modify multisampled pixel fragments",
      "parameters": {
        "value": "<listitem> <para>Specifies the coverage of the modification mask. The value is clamped to the range [0, 1], where 0 represents no coverage and 1 full coverage. The initial value is 1.</para> </listitem>",
        "invert": "<listitem> <para>Specifies whether the modification mask implied by <parameter>value</parameter> is inverted or not. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glScalef": {
      "signature": "void glScalef(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "multiply the current matrix by a general scaling\tmatrix",
      "parameters": {
        "x": "<listitem> <para>Specify scale factors along the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> axes, respectively.</para> </listitem>"
      }
    },
    "glScalex": {
      "signature": "void glScalex(GLfixed x, GLfixed y, GLfixed z)",
      "purpose": "multiply the current matrix by a general scaling\tmatrix",
      "parameters": {
        "x": "<listitem> <para>Specify scale factors along the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> axes, respectively.</para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para>Specify the lower left corner of the scissor box, in pixels. The initial value is (0, 0).</para> </listitem>",
        "width": "<listitem> <para>Specify the width and height of the scissor box. When a GL context is first attached to a surface (e.g. window), <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that surface.</para> </listitem>"
      }
    },
    "glShadeModel": {
      "signature": "void glShadeModel(GLenum mode)",
      "purpose": "select flat or smooth shading",
      "parameters": {
        "mode": "<listitem> <para>Specifies a symbolic value representing a shading technique. Accepted values are `GL_FLAT` and `GL_SMOOTH`. The initial value is `GL_SMOOTH`.</para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set function and reference value for stencil        testing",
      "parameters": {
        "func": "<listitem> <para>Specifies the test function. Eight tokens are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`.</para> </listitem>",
        "ref": "<listitem> <para>Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math> <mo>[</mo> <mn>0</mn> <mo>,</mo> <msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup> <mo>]</mo> </math></inlineequation>, where <replaceable>n</replaceable> is the number of bitplanes in the stencil buffer. The initial value is 0.</para> </listitem>",
        "mask": "<listitem> <para>Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.</para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the writing of individual bits in the        stencil planes",
      "parameters": {
        "mask": "<listitem> <para>Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. The initial value is all 1's.</para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)",
      "purpose": "set stencil test actions",
      "parameters": {
        "fail": "<listitem> <para>Specifies the action to take when the stencil test fails. Six symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_DECR`, and `GL_INVERT`. The initial value is `GL_KEEP`.</para> </listitem>",
        "zfail": "<listitem> <para>Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>zfail</parameter> accepts the same symbolic constants as <parameter>fail</parameter>. The initial value is `GL_KEEP`.</para> </listitem>",
        "zpass": "<listitem> <para>Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>zpass</parameter> accepts the same symbolic constants as <parameter>fail</parameter>. The initial value is `GL_KEEP`.</para> </listitem>"
      }
    },
    "glTexCoordPointer": {
      "signature": "void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of texture coordinates",
      "parameters": {
        "size": "<listitem> <para>Specifies the number of coordinates per array element. Must be 2, 3 or 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each texture coordinate. Symbolic constants `GL_BYTE`, `GL_SHORT`, and `GL_FIXED` are accepted. However, the initial value is `GL_FLOAT`.</para> <para> The common profile accepts the symbolic constant `GL_FLOAT` as well. </para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive array elements. If <parameter>stride</parameter> is 0, the array elements are understood to be tightly packed. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first coordinate of the first element in the array. The initial value is 0.</para> </listitem>"
      }
    },
    "glTexEnvf": {
      "signature": "void glTexEnvf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_DOT3_RGB`, `GL_DOT3_RGBA`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnvi": {
      "signature": "void glTexEnvi(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_DOT3_RGB`, `GL_DOT3_RGBA`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnvx": {
      "signature": "void glTexEnvx(GLenum target, GLenum pname, GLfixed param)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_DOT3_RGB`, `GL_DOT3_RGBA`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnvfv": {
      "signature": "void glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_DOT3_RGB`, `GL_DOT3_RGBA`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnviv": {
      "signature": "void glTexEnviv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_DOT3_RGB`, `GL_DOT3_RGBA`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnvxv": {
      "signature": "void glTexEnvxv(GLenum target, GLenum pname, const GLfixed * params)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV` or `GL_POINT_SPRITE_OES`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE_OES`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_DOT3_RGB`, `GL_DOT3_RGBA`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <parameter>n</parameter> is the <parameter>n</parameter>th mipmap reduction image. Must be greater or equal 0.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the color components in the texture. Must be same as <parameter>format</parameter>. The following symbolic values are accepted: `GL_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_LUMINANCE`, or `GL_LUMINANCE_ALPHA`.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture image. Must be <inlineequation><math> <msup><mn>2</mn><mi>n</mi></msup> </math></inlineequation> for some integer <replaceable>n</replaceable>. All implementations support texture images that are at least 64 texels wide.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture image. Must be <inlineequation><math> <msup><mn>2</mn><mi>m</mi></msup> </math></inlineequation> for some integer <replaceable>m</replaceable>. All implementations support texture images that are at least 64 texels high.</para> </listitem>",
        "border": "<listitem> <para>Specifies the width of the border. Must be 0.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the pixel data. Must be same as <parameter>internalformat</parameter>. The following symbolic values are accepted: `GL_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, and `GL_UNSIGNED_SHORT_5_5_5_1`.</para> </listitem>",
        "pixels": "<listitem> <para>Specifies a pointer to the image data in memory.</para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value of <parameter>pname</parameter>.</para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value of <parameter>pname</parameter>.</para> </listitem>"
      }
    },
    "glTexParameterx": {
      "signature": "void glTexParameterx(GLenum target, GLenum pname, GLfixed param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value of <parameter>pname</parameter>.</para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value of <parameter>pname</parameter>.</para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value of <parameter>pname</parameter>.</para> </listitem>"
      }
    },
    "glTexParameterxv": {
      "signature": "void glTexParameterxv(GLenum target, GLenum pname, GLfixed * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture, which must be `GL_TEXTURE_2D`.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_GENERATE_MIPMAP`.</para> </listitem>",
        "param": "<listitem> <para>Specifies the value of <parameter>pname</parameter>.</para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para>Specifies the target texture. Must be `GL_TEXTURE_2D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <parameter>n</parameter> is the <parameter>n</parameter>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the of the pixel data. The following symbolic values are accepted: `GL_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, and `GL_UNSIGNED_SHORT_5_5_5_1`.</para> </listitem>",
        "pixels": "<listitem> <para>Specifies a pointer to the image data in memory.</para> </listitem>"
      }
    },
    "glTranslatef": {
      "signature": "void glTranslatef(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "multiply the current matrix by a translation matrix",
      "parameters": {
        "x": "<listitem> <para>Specify the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> coordinates of a translation vector.</para> </listitem>"
      }
    },
    "glTranslatex": {
      "signature": "void glTranslatex(GLfixed x, GLfixed y, GLfixed z)",
      "purpose": "multiply the current matrix by a translation matrix",
      "parameters": {
        "x": "<listitem> <para>Specify the <parameter>x</parameter>, <parameter>y</parameter>, and <parameter>z</parameter> coordinates of a translation vector.</para> </listitem>"
      }
    },
    "glVertexPointer": {
      "signature": "void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of vertex coordinates",
      "parameters": {
        "size": "<listitem> <para>Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each vertex coordinate in the array. Symbolic constants `GL_BYTE`, `GL_SHORT`, and `GL_FIXED`, are accepted. However, the initial value is `GL_FLOAT`.</para> <para> The common profile accepts the symbolic constant `GL_FLOAT` as well. </para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive vertices. If <parameter>stride</parameter> is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.</para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para>Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0, 0).</para> </listitem>",
        "width": "<listitem> <para>Specify the width and height of the viewport. When a GL context is first attached to a surface (e.g. window), <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that surface.</para> </listitem>"
      }
    },
    "glWeightPointerOES": {
      "signature": "void glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of weights",
      "parameters": {
        "size": "<listitem> <para> Specifies the number of weights per vertex. Must be is less than or equal to `GL_MAX_VERTEX_UNITS_OES`. The initial value is `0`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of each weight in the array. Symbolic constant `GL_FIXED` is accepted. However, the common profile also accepts the symbolic constant `GL_FLOAT` as well. The initial value is `GL_FIXED` for the common lite profile, or `GL_FLOAT` for the common profile. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive weights. If <parameter>stride</parameter> is 0, the weights are understood to be tightly packed in the array. The initial value is `0`. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first weight of the first vertex in the array. The initial value is `0`. </para> </listitem>"
      }
    }
  },
  "es2.0": {
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 8. <parameter>texture</parameter> must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to (`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` - 1). The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAttachShader": {
      "signature": "void glAttachShader(GLuint program, GLuint shader)",
      "purpose": "attach a shader object to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
      }
    },
    "glBindAttribLocation": {
      "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
      "purpose": "associate a generic vertex attribute index with a named attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
        "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
      }
    },
    "glBindFramebuffer": {
      "signature": "void glBindFramebuffer(GLenum target, GLuint framebuffer)",
      "purpose": "bind a named framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer object is bound. The symbolic constant must be `GL_FRAMEBUFFER`. </para> </listitem>",
        "framebuffer": "<listitem> <para> Specifies the name of a framebuffer object. </para> </listitem>"
      }
    },
    "glBindRenderbuffer": {
      "signature": "void glBindRenderbuffer(GLenum target, GLuint renderbuffer)",
      "purpose": "bind a named renderbuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the renderbuffer object is bound. The symbolic constant must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of a renderbuffer object. </para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the active texture unit to which the texture is bound. Must be either `GL_TEXTURE_2D` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBlendColor": {
      "signature": "void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)",
      "purpose": "set the blend color",
      "parameters": {
        "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
      }
    },
    "glBlendEquation": {
      "signature": "void glBlendEquation(GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, or `GL_FUNC_REVERSE_SUBTRACT`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparate": {
      "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, or `GL_FUNC_REVERSE_SUBTRACT`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, or `GL_FUNC_REVERSE_SUBTRACT`. </para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, and `GL_SRC_ALPHA_SATURATE`. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparate": {
      "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, and `GL_SRC_ALPHA_SATURATE`. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for <parameter>srcRGB</parameter>. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for <parameter>dstRGB</parameter>. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "create and initialize a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the buffer object's new data store. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied. </para> </listitem>",
        "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STATIC_DRAW`, or `GL_DYNAMIC_DRAW`. </para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "update a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glCheckFramebufferStatus": {
      "signature": "GLenum glCheckFramebufferStatus(GLenum target)",
      "purpose": "return the framebuffer completeness status of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target framebuffer object. The symbolic constant must be `GL_FRAMEBUFFER`. </para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)",
      "purpose": "specify clear values for the color buffers",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearDepthf": {
      "signature": "void glClearDepthf(GLclampf depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha can or cannot be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components can be written. </para> </listitem>"
      }
    },
    "glCompileShader": {
      "signature": "void glCompileShader(GLuint shader)",
      "purpose": "compile a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "copy pixels into a 2D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, or `GL_RGBA`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCreateProgram": {
      "signature": "GLuint glCreateProgram(void)",
      "purpose": "create a program object",
      "parameters": {}
    },
    "glCreateShader": {
      "signature": "GLuint glCreateShader(GLenum shaderType)",
      "purpose": "create a shader object",
      "parameters": {
        "shaderType": "<listitem> <para>Specifies the type of shader to be created. Must be either `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.</para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing polygons can be culled",
      "parameters": {
        "mode": "<listitem> <para> Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteFramebuffers": {
      "signature": "void glDeleteFramebuffers(GLsizei n, const GLuint * framebuffers)",
      "purpose": "delete named framebuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer objects to be deleted. </para> </listitem>",
        "framebuffers": "<listitem> <para> Specifies an array of framebuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteProgram": {
      "signature": "void glDeleteProgram(GLuint program)",
      "purpose": "delete a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteRenderbuffers": {
      "signature": "void glDeleteRenderbuffers(GLsizei n, const GLuint * renderbuffers)",
      "purpose": "delete named renderbuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer objects to be deleted. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array of renderbuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteShader": {
      "signature": "void glDeleteShader(GLuint shader)",
      "purpose": "delete a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
      }
    },
    "glDepthRangef": {
      "signature": "void glDepthRangef(GLclampf nearVal, GLclampf farVal)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "nearVal": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "farVal": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDetachShader": {
      "signature": "void glDetachShader(GLuint program, GLuint shader)",
      "purpose": "detach a shader object from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be `GL_UNSIGNED_BYTE` or `GL_UNSIGNED_SHORT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnableVertexAttribArray": {
      "signature": "void glEnableVertexAttribArray(GLuint index)",
      "purpose": "enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexAttribArray": {
      "signature": "void glDisableVertexAttribArray(GLuint index)",
      "purpose": "enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish( void)",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush( void)",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFramebufferRenderbuffer": {
      "signature": "void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
      "purpose": "attach a renderbuffer object to a framebuffer object",
      "parameters": {
        "target": "<listitem> <para>Specifies the framebuffer target. The symbolic constant must be `GL_FRAMEBUFFER`.</para> </listitem>",
        "attachment": "<listitem> <para>Specifies the attachment point to which <parameter>renderbuffer</parameter> should be attached. Must be one of the following symbolic constants: `GL_COLOR_ATTACHMENT0`, `GL_DEPTH_ATTACHMENT`, or `GL_STENCIL_ATTACHMENT`.</para> </listitem>",
        "renderbuffertarget": "<listitem> <para>Specifies the renderbuffer target. The symbolic constant must be `GL_RENDERBUFFER`.</para> </listitem>",
        "renderbuffer": "<listitem> <para>Specifies the renderbuffer object that is to be attached.</para> </listitem>"
      }
    },
    "glFramebufferTexture2D": {
      "signature": "void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
      "purpose": "attach a texture image to a framebuffer object",
      "parameters": {
        "target": "<listitem> <para>Specifies the framebuffer target. The symbolic constant must be `GL_FRAMEBUFFER`.</para> </listitem>",
        "attachment": "<listitem> <para>Specifies the attachment point to which an image from <parameter>texture</parameter> should be attached. Must be one of the following symbolic constants: `GL_COLOR_ATTACHMENT0`, `GL_DEPTH_ATTACHMENT`, or `GL_STENCIL_ATTACHMENT`.</para> </listitem>",
        "textarget": "<listitem> <para>Specifies the texture target. Must be one of the following symbolic constants: `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.</para> </listitem>",
        "texture": "<listitem> <para>Specifies the texture object whose image is to be attached.</para> </listitem>",
        "level": "<listitem> <para>Specifies the mipmap level of the texture image to be attached, which must be 0.</para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
      }
    },
    "glGenerateMipmap": {
      "signature": "void glGenerateMipmap(GLenum target)",
      "purpose": "generate a complete set of mipmaps for a texture object",
      "parameters": {
        "target": "<listitem> <para>Specifies the texture target of the active texture unit to which the texture object is bound whose mipmaps will be generated. Must be one of the following symbolic constants: `GL_TEXTURE_2D` or `GL_TEXTURE_CUBE_MAP`.</para> </listitem>"
      }
    },
    "glGenFramebuffers": {
      "signature": "void glGenFramebuffers(GLsizei n, GLuint * framebuffers)",
      "purpose": "generate framebuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer object names to be generated. </para> </listitem>",
        "framebuffers": "<listitem> <para> Specifies an array in which the generated framebuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenRenderbuffers": {
      "signature": "void glGenRenderbuffers(GLsizei n, GLuint * renderbuffers)",
      "purpose": "generate renderbuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer object names to be generated. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array in which the generated renderbuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetActiveAttrib": {
      "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "return information about an active attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
      }
    },
    "glGetActiveUniform": {
      "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "return information about an active uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
      }
    },
    "glGetAttachedShaders": {
      "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
      "purpose": "return the handles of the shader objects attached to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
        "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
      }
    },
    "glGetAttribLocation": {
      "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
      "purpose": "return the location of an attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError( void)",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetFramebufferAttachmentParameteriv": {
      "signature": "void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params)",
      "purpose": "return attachment parameters of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target framebuffer object. The symbolic constant must be `GL_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the symbolic name of a framebuffer object attachment point. Accepted values are `GL_COLOR_ATTACHMENT0`, `GL_DEPTH_ATTACHMENT`, and `GL_STENCIL_ATTACHMENT`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a framebuffer object attachment parameter. Accepted values are `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL`, and `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetProgramInfoLog": {
      "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "return the information log for a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetProgramiv": {
      "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
      "purpose": "return a parameter from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_DELETE_STATUS`, `GL_LINK_STATUS`, `GL_VALIDATE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetRenderbufferParameteriv": {
      "signature": "void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a renderbuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target renderbuffer object. The symbolic constant must be `GL_RENDERBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a renderbuffer object parameter. Accepted values are `GL_RENDERBUFFER_WIDTH`, `GL_RENDERBUFFER_HEIGHT`, `GL_RENDERBUFFER_INTERNAL_FORMAT`, `GL_RENDERBUFFER_RED_SIZE`, `GL_RENDERBUFFER_GREEN_SIZE`, `GL_RENDERBUFFER_BLUE_SIZE`, `GL_RENDERBUFFER_ALPHA_SIZE`, `GL_RENDERBUFFER_DEPTH_SIZE`, or `GL_RENDERBUFFER_STENCIL_SIZE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetShaderInfoLog": {
      "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "return the information log for a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetShaderiv": {
      "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
      "purpose": "return a parameter from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetShaderPrecisionFormat": {
      "signature": "void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)",
      "purpose": "return the range and precision for different shader numeric formats",
      "parameters": {
        "shaderType": "<listitem> <para>Specifies the type of shader to query. Must be either `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.</para> </listitem>",
        "precisionType": "<listitem> <para>Specifies the numeric format to query, corresponding to a shader precision qualifier and variable type. Must be one of `GL_LOW_FLOAT`, `GL_MEDIUM_FLOAT`, `GL_HIGH_FLOAT`, `GL_LOW_INT`, `GL_MEDIUM_INT`, or `GL_HIGH_INT`.</para> </listitem>",
        "range": "<listitem> <para>Specifies a pointer to the two-element array in which the <inlineequation><math> <mrow> <msub><mi mathvariant=\"italic\">log</mi> <mn>2</mn> </msub> </mrow> </math></inlineequation> of the minimum and maximum representable magnitudes of the format are returned.</para> </listitem>",
        "precision": "<listitem> <para>Specifies a pointer to the location in which the <inlineequation><math> <mrow> <msub><mi mathvariant=\"italic\">log</mi> <mn>2</mn> </msub> </mrow> </math></inlineequation> of the precision of the format is returned.</para> </listitem>"
      }
    },
    "glGetShaderSource": {
      "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
      "purpose": "return the source code string from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
        "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte* glGetString(GLenum name)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, `GL_SHADING_LANGUAGE_VERSION`, or `GL_EXTENSIONS`. </para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture of the active texture unit. `GL_TEXTURE_2D` and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_WRAP_S`, and `GL_TEXTURE_WRAP_T` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameter. </para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture of the active texture unit. `GL_TEXTURE_2D` and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_WRAP_S`, and `GL_TEXTURE_WRAP_T` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameter. </para> </listitem>"
      }
    },
    "glGetUniformfv": {
      "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
      "purpose": "return the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformiv": {
      "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
      "purpose": "return the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformLocation": {
      "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
      "purpose": "return the location of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetVertexAttribfv": {
      "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
      "purpose": "return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribiv": {
      "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribPointerv": {
      "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
      "purpose": "return the address of the specified generic vertex attribute pointer",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
        "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_GENERATE_MIPMAP_HINT` is accepted. </para> </listitem>",
        "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glIsFramebuffer": {
      "signature": "GLboolean glIsFramebuffer(GLuint framebuffer)",
      "purpose": "determine if a name corresponds to a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies a value that may be the name of a framebuffer object. </para> </listitem>"
      }
    },
    "glIsProgram": {
      "signature": "GLboolean glIsProgram(GLuint program)",
      "purpose": "determine if a name corresponds to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
      }
    },
    "glIsRenderbuffer": {
      "signature": "GLboolean glIsRenderbuffer(GLuint renderbuffer)",
      "purpose": "determine if a name corresponds to a renderbuffer object",
      "parameters": {
        "renderbuffer": "<listitem> <para> Specifies a value that may be the name of a renderbuffer object. </para> </listitem>"
      }
    },
    "glIsShader": {
      "signature": "GLboolean glIsShader(GLuint shader)",
      "purpose": "determine if a name corresponds to a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
      }
    },
    "glLinkProgram": {
      "signature": "void glLinkProgram(GLuint program)",
      "purpose": "link a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
      }
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. One value affects the packing of pixel data into memory: `GL_PACK_ALIGNMENT`. The other affects the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth values",
      "parameters": {
        "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
        "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_ALPHA`, `GL_RGB`, and `GL_RGBA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, or `GL_UNSIGNED_SHORT_5_5_5_1`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
      }
    },
    "glReleaseShaderCompiler": {
      "signature": "void glReleaseShaderCompiler( void)",
      "purpose": "release resources allocated by the shader compiler",
      "parameters": {}
    },
    "glRenderbufferStorage": {
      "signature": "void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "create and initialize a renderbuffer object's data store",
      "parameters": {
        "target": "<listitem> <para>Specifies the renderbuffer target. The symbolic constant must be `GL_RENDERBUFFER`.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the color-renderable, depth-renderable, or stencil-renderable format of the renderbuffer. Must be one of the following symbolic constants: `GL_RGBA4`, `GL_RGB565`, `GL_RGB5_A1`, `GL_DEPTH_COMPONENT16`, or `GL_STENCIL_INDEX8`.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the renderbuffer in pixels.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the renderbuffer in pixels.</para> </listitem>"
      }
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLclampf value, GLboolean invert)",
      "purpose": "specify multisample coverage parameters",
      "parameters": {
        "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
        "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glShaderBinary": {
      "signature": "void glShaderBinary(GLsizei n, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length)",
      "purpose": "load a precompiled shader binary",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of shader object handles present in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies a pointer to an array of shader object handles into which the shader binary will be loaded.</para> </listitem>",
        "binaryformat": "<listitem> <para>Specifies the shader binary format.</para> </listitem>",
        "binary": "<listitem> <para>Specifies a pointer to the shader binary data in client memory.</para> </listitem>",
        "length": "<listitem> <para>Specifies the length of the shader binary data in bytes.</para> </listitem>"
      }
    },
    "glShaderSource": {
      "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length)",
      "purpose": "replace the source code in a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
        "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
        "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and back function and reference value for stencil testing",
      "parameters": {
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilFuncSeparate": {
      "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and/or back function and reference value for stencil testing",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the front and back writing of individual bits in the stencil planes",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilMaskSeparate": {
      "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
      "purpose": "control the front and/or back writing of individual bits in the stencil planes",
      "parameters": {
        "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and back stencil test actions",
      "parameters": {
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glStencilOpSeparate": {
      "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and/or back stencil test actions",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_RGBA`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the texel data. Must match <parameter>internalformat</parameter>. The following symbolic values are accepted: `GL_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the texel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, and `GL_UNSIGNED_SHORT_5_5_5_1`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit, which must be either `GL_TEXTURE_2D` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, or `GL_TEXTURE_WRAP_T`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit, which must be either `GL_TEXTURE_2D` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, or `GL_TEXTURE_WRAP_T`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit, which must be either `GL_TEXTURE_2D` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, or `GL_TEXTURE_WRAP_T`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit, which must be either `GL_TEXTURE_2D` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_WRAP_S`, or `GL_TEXTURE_WRAP_T`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture of the active texture unit. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, and `GL_UNSIGNED_SHORT_5_5_5_1`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glUniform1f": {
      "signature": "void glUniform1f(GLint location, GLfloat v0)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2f": {
      "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3f": {
      "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4f": {
      "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform1i": {
      "signature": "void glUniform1i(GLint location, GLint v0)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2i": {
      "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3i": {
      "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4i": {
      "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform1fv": {
      "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2fv": {
      "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3fv": {
      "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4fv": {
      "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform1iv": {
      "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2iv": {
      "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3iv": {
      "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4iv": {
      "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix2fv": {
      "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix3fv": {
      "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix4fv": {
      "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUseProgram": {
      "signature": "void glUseProgram(GLuint program)",
      "purpose": "install a program object as part of current rendering state",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
      }
    },
    "glValidateProgram": {
      "signature": "void glValidateProgram(GLuint program)",
      "purpose": "validate a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
      }
    },
    "glVertexAttrib1f": {
      "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2f": {
      "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3f": {
      "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4f": {
      "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib1fv": {
      "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2fv": {
      "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3fv": {
      "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4fv": {
      "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
      "purpose": "specify the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttribPointer": {
      "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. Symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_FIXED`, or `GL_FLOAT` are accepted. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.</para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    }
  },
  "es3": {
    "abs": {
      "signature": "genIType abs(genIType x)",
      "purpose": "return the absolute value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to return the absolute. </para> </listitem>"
      }
    },
    "acos": {
      "signature": "genType acos(genType x)",
      "purpose": "return the arccosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arccosine to return. </para> </listitem>"
      }
    },
    "acosh": {
      "signature": "genType acosh(genType x)",
      "purpose": "return the arc hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "all": {
      "signature": "bool all(bvec x)",
      "purpose": "check whether all elements of a boolean vector are true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "any": {
      "signature": "bool any(bvec x)",
      "purpose": "check whether any element of a boolean vector is true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "asin": {
      "signature": "genType asin(genType x)",
      "purpose": "return the arcsine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arcsine to return. </para> </listitem>"
      }
    },
    "asinh": {
      "signature": "genType asinh(genType x)",
      "purpose": "return the arc hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic sine to return. </para> </listitem>"
      }
    },
    "atan": {
      "signature": "genType atan(genType y_over_x)",
      "purpose": "return the arc-tangent of the parameters",
      "parameters": {
        "y": "<listitem> <para> Specify the numerator of the fraction whose arctangent to return. </para> </listitem>",
        "x": "<listitem> <para> Specify the denominator of the fraction whose arctangent to return. </para> </listitem>",
        "y_over_x": "<listitem> <para> Specify the fraction whose arctangent to return. </para> </listitem>"
      }
    },
    "atanh": {
      "signature": "genType atanh(genType x)",
      "purpose": "return the arc hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "atomicAdd": {
      "signature": "uint atomicAdd(inout uint mem, uint data)",
      "purpose": "perform an atomic addition to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be added to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicAnd": {
      "signature": "uint atomicAnd(inout uint mem, uint data)",
      "purpose": "perform an atomic logical AND operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically ANDed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicCompSwap": {
      "signature": "uint atomicCompSwap(inout uint mem, uint compare, uint data)",
      "purpose": "perform an atomic compare-exchange operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared and potentially exchanged with <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicCounter": {
      "signature": "uint atomicCounter(atomic_uint c)",
      "purpose": "return the current value of an atomic counter",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter whose value to return. </para> </listitem>"
      }
    },
    "atomicCounterDecrement": {
      "signature": "uint atomicCounterDecrement(atomic_uint c)",
      "purpose": "atomically decrement a counter and return the prior value",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter to decrement. </para> </listitem>"
      }
    },
    "atomicCounterIncrement": {
      "signature": "uint atomicCounterIncrement(atomic_uint c)",
      "purpose": "atomically increment a counter and return the prior value",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter to increment. </para> </listitem>"
      }
    },
    "atomicExchange": {
      "signature": "uint atomicExchange(inout uint mem, uint data)",
      "purpose": "perform an atomic exchange operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be exchanged with <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicMax": {
      "signature": "uint atomicMax(inout uint mem, uint data)",
      "purpose": "perform an atomic max operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicMin": {
      "signature": "uint atomicMin(inout uint mem, uint data)",
      "purpose": "perform an atomic min operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicOr": {
      "signature": "uint atomicOr(inout uint mem, uint data)",
      "purpose": "perform an atomic logical OR operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically ORed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicXor": {
      "signature": "uint atomicXor(inout uint mem, uint data)",
      "purpose": "perform an atomic logical exclusive OR operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically exclusive ORed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "barrier": {
      "signature": "void barrier(void)",
      "purpose": "synchronize execution of multiple shader invocations",
      "parameters": {}
    },
    "bitCount": {
      "signature": "genIType bitCount(genUType value)",
      "purpose": "counts the number of 1 bits in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to count. </para> </listitem>"
      }
    },
    "bitfieldExtract": {
      "signature": "genUType bitfieldExtract(genUType value, int offset, int bits)",
      "purpose": "extract a range of bits from an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the integer from which to extract bits. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the index of the first bit to extract. </para> </listitem>",
        "bits": "<listitem> <para> Specifies the number of bits to extract. </para> </listitem>"
      }
    },
    "bitfieldInsert": {
      "signature": "genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)",
      "purpose": "insert a range of bits into an integer",
      "parameters": {
        "base": "<listitem> <para> Specifies the integer into which to insert <parameter>insert</parameter>. </para> </listitem>",
        "insert": "<listitem> <para> Specifies the value of the bits to insert. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the index of the first bit to insert. </para> </listitem>",
        "bits": "<listitem> <para> Specifies the number of bits to insert. </para> </listitem>"
      }
    },
    "bitfieldReverse": {
      "signature": "genUType bitfieldReverse(genUType value)",
      "purpose": "reverse the order of bits in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to reverse. </para> </listitem>"
      }
    },
    "ceil": {
      "signature": "genType ceil(genType x)",
      "purpose": "find the nearest integer that is greater than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "clamp": {
      "signature": "genUType clamp(genUType x, uint minVal, uint maxVal)",
      "purpose": "constrain a value to lie between two further values",
      "parameters": {
        "x": "<listitem> <para> Specify the value to constrain. </para> </listitem>",
        "minVal": "<listitem> <para> Specify the lower end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>",
        "maxVal": "<listitem> <para> Specify the upper end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "cos": {
      "signature": "genType cos(genType angle)",
      "purpose": "return the cosine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the cosine. </para> </listitem>"
      }
    },
    "cosh": {
      "signature": "genType cosh(genType x)",
      "purpose": "return the hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "cross": {
      "signature": "vec3 cross(vec3 x, vec3 y)",
      "purpose": "calculate the cross product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "degrees": {
      "signature": "genType degrees(genType radians)",
      "purpose": "convert a quantity in radians to degrees",
      "parameters": {
        "radians": "<listitem> <para> Specify the quantity, in radians, to be converted to degrees. </para> </listitem>"
      }
    },
    "determinant": {
      "signature": "float determinant(mat4 m)",
      "purpose": "calculate the determinant of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the determinant. </para> </listitem>"
      }
    },
    "dFdx": {
      "signature": "genType dFdx(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdy": {
      "signature": "genType dFdy(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "distance": {
      "signature": "float distance(genType p0, genType p1)",
      "purpose": "calculate the distance between two points",
      "parameters": {
        "p0": "<listitem> <para> Specifies the first of two points </para> </listitem>",
        "p1": "<listitem> <para> Specifies the second of two points </para> </listitem>"
      }
    },
    "dot": {
      "signature": "float dot(genType x, genType y)",
      "purpose": "calculate the dot product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "EmitVertex": {
      "signature": "void EmitVertex(void)",
      "purpose": "emit a vertex to the first vertex stream",
      "parameters": {}
    },
    "EndPrimitive": {
      "signature": "void EndPrimitive(void)",
      "purpose": "complete the current output primitive on the first vertex stream",
      "parameters": {}
    },
    "equal": {
      "signature": "bvec equal(uvec x, uvec y)",
      "purpose": "perform a component-wise equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "exp": {
      "signature": "genType exp(genType x)",
      "purpose": "return the natural exponentiation of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to exponentiate. </para> </listitem>"
      }
    },
    "exp2": {
      "signature": "genType exp2(genType x)",
      "purpose": "return 2 raised to the power of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of the power to which 2 will be raised. </para> </listitem>"
      }
    },
    "faceforward": {
      "signature": "genType faceforward(genType N, genType I, genType Nref)",
      "purpose": "return a vector pointing in the same direction as another",
      "parameters": {
        "N": "<listitem> <para> Specifies the vector to orient. </para> </listitem>",
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "Nref": "<listitem> <para> Specifies the reference vector. </para> </listitem>"
      }
    },
    "findLSB": {
      "signature": "genIType findLSB(genUType value)",
      "purpose": "find the index of the least significant bit set to 1 in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to scan. </para> </listitem>"
      }
    },
    "findMSB": {
      "signature": "genIType findMSB(genUType value)",
      "purpose": "find the index of the most significant bit set to 1 in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to scan. </para> </listitem>"
      }
    },
    "floatBitsToInt": {
      "signature": "genIType floatBitsToInt(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floatBitsToUint": {
      "signature": "genUType floatBitsToUint(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floor": {
      "signature": "genType floor(genType x)",
      "purpose": "find the nearest integer less than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "fma": {
      "signature": "genType fma(genType a, genType b, genType c)",
      "purpose": "perform a fused multiply-add operation",
      "parameters": {
        "a": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "b": "<listitem> <para> Specifies the second multiplicand. </para> </listitem>",
        "c": "<listitem> <para> Specifies the value to be added to the result. </para> </listitem>"
      }
    },
    "fract": {
      "signature": "genType fract(genType x)",
      "purpose": "compute the fractional part of the argument",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "frexp": {
      "signature": "genType frexp(genType x, out genIType exp)",
      "purpose": "split a floating point number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value from which significand and exponent are to be extracted. </para> </listitem>",
        "out exp": "<listitem> <para> Specifies the variable into which to place the exponent </para> </listitem>"
      }
    },
    "fwidth": {
      "signature": "genType fwidth(genType p)",
      "purpose": "return the sum of the absolute derivatives in x and y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "glActiveShaderProgram": {
      "signature": "void glActiveShaderProgram(GLuint pipeline, GLuint program)",
      "purpose": "set the active program object for a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the program pipeline object to set the active program object for. </para> </listitem>",
        "program": "<listitem> <para> Specifies the program object to set as the active program pipeline object <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation-dependent, but must be at least 32. <parameter>texture</parameter> must be one of `GL_TEXTURE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAttachShader": {
      "signature": "void glAttachShader(GLuint program, GLuint shader)",
      "purpose": "Attaches a shader object to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
      }
    },
    "glBeginQuery": {
      "signature": "void glBeginQuery(GLenum target, GLuint id)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glEndQuery": {
      "signature": "void glEndQuery(GLenum target)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glBeginTransformFeedback": {
      "signature": "void glBeginTransformFeedback(GLenum primitiveMode)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glEndTransformFeedback": {
      "signature": "void glEndTransformFeedback(void)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glBindAttribLocation": {
      "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
      "purpose": "Associates a generic vertex attribute index with a named attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
        "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
      }
    },
    "glBindBufferBase": {
      "signature": "void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)",
      "purpose": "bind a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>"
      }
    },
    "glBindBufferRange": {
      "signature": "void glBindBufferRange(GLenumtarget, GLuintindex, GLuintbuffer, GLintptroffset, GLsizeiptrsize)",
      "purpose": "bind a range within a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>",
        "offset": "<listitem> <para> The starting offset in basic machine units into the buffer object <parameter>buffer</parameter>. </para> </listitem>",
        "size": "<listitem> <para> The amount of data in machine units that can be read from the buffet object while used as an indexed target. </para> </listitem>"
      }
    },
    "glBindFramebuffer": {
      "signature": "void glBindFramebuffer(GLenum target, GLuint framebuffer)",
      "purpose": "bind a framebuffer to a framebuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target of the binding operation. </para> </listitem>",
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object to bind. </para> </listitem>"
      }
    },
    "glBindImageTexture": {
      "signature": "void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)",
      "purpose": "bind a level of a texture to an image unit",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the image unit to which to bind the texture </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of the texture to bind to the image unit. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level of the texture that is to be bound. </para> </listitem>",
        "layered": "<listitem> <para> Specifies whether a layered texture binding is to be established. </para> </listitem>",
        "layer": "<listitem> <para> If <parameter>layered</parameter> is `GL_FALSE`, specifies the layer of <parameter>texture</parameter> to be bound to the image unit. Ignored otherwise. </para> </listitem>",
        "access": "<listitem> <para> Specifies a token indicating the type of access that will be performed on the image. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format that the elements of the image will be treated as for the purposes of formatted loads and stores. </para> </listitem>"
      }
    },
    "glBindProgramPipeline": {
      "signature": "void glBindProgramPipeline(GLuint pipeline)",
      "purpose": "bind a program pipeline to the current context",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of the pipeline object to bind to the context. </para> </listitem>"
      }
    },
    "glBindRenderbuffer": {
      "signature": "void glBindRenderbuffer(GLenum target, GLuint renderbuffer)",
      "purpose": "bind a renderbuffer to a renderbuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the renderbuffer target of the binding operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of the renderbuffer object to bind. </para> </listitem>"
      }
    },
    "glBindSampler": {
      "signature": "void glBindSampler(GLuint unit, GLuint sampler)",
      "purpose": "bind a named sampler to a texturing target",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the texture unit to which the sampler is bound. </para> </listitem>",
        "sampler": "<listitem> <para> Specifies the name of a sampler. </para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound. Must be either `GL_TEXTURE_2D`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBindTransformFeedback": {
      "signature": "void glBindTransformFeedback(GLenum target, GLuint id)",
      "purpose": "bind a transform feedback object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which to bind the transform feedback object <parameter>id</parameter>. <parameter>target</parameter> must be `GL_TRANSFORM_FEEDBACK`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object reserved by <citerefentry><refentrytitle>glGenTransformFeedbacks</refentrytitle></citerefentry>. </para> </listitem>"
      }
    },
    "glBindVertexArray": {
      "signature": "void glBindVertexArray(GLuint array)",
      "purpose": "bind a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies the name of the vertex array to bind. </para> </listitem>"
      }
    },
    "glBindVertexBuffer": {
      "signature": "void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride)",
      "purpose": "bind a buffer to a vertex buffer bind point",
      "parameters": {
        "bindingindex": "<listitem> <para> The index of the vertex buffer binding point to which to bind the buffer. </para> </listitem>",
        "buffer": "<listitem> <para> The name of an existing buffer to bind to the vertex buffer binding point. </para> </listitem>",
        "offset": "<listitem> <para> The offset of the first element of the buffer. </para> </listitem>",
        "stride": "<listitem> <para> The distance between elements within the buffer. </para> </listitem>"
      }
    },
    "glBlendBarrier": {
      "signature": "void glBlendBarrier(void)",
      "purpose": "specifies a boundary between advanced blending passes",
      "parameters": {}
    },
    "glBlendColor": {
      "signature": "void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "set the blend color",
      "parameters": {
        "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
      }
    },
    "glBlendEquation": {
      "signature": "void glBlendEquation(GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationi": {
      "signature": "void glBlendEquationi(GLuint buf, GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "buf": "<listitem> <para> for <function>glBlendEquationi</function>, specifies the index of the draw buffer for which to set the blend equation. </para> </listitem>",
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparate": {
      "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparatei": {
      "signature": "void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "buf": "<listitem> <para> for <function>glBlendEquationSeparatei</function>, specifies the index of the draw buffer for which to set the blend equations. </para> </listitem>",
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFunci</function>, specifies the index of the draw buffer for which to set the blend function. </para> </listitem>",
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFunci": {
      "signature": "void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFunci</function>, specifies the index of the draw buffer for which to set the blend function. </para> </listitem>",
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparate": {
      "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFuncSeparatei</function>, specifies the index of the draw buffer for which to set the blend functions. </para> </listitem>",
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparatei": {
      "signature": "void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFuncSeparatei</function>, specifies the index of the draw buffer for which to set the blend functions. </para> </listitem>",
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlitFramebuffer": {
      "signature": "void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)",
      "purpose": "copy a block of pixels from the read framebuffer to the draw framebuffer",
      "parameters": {
        "srcX0": "<listitem> <para> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </para> </listitem>",
        "dstX0": "<listitem> <para> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </para> </listitem>",
        "mask": "<listitem> <para> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>",
        "filter": "<listitem> <para> Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`. </para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glBufferData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the buffer object's new data store. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied. </para> </listitem>",
        "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`. </para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "updates a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glBufferSubData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glCheckFramebufferStatus": {
      "signature": "GLenum glCheckFramebufferStatus(GLenum target)",
      "purpose": "check the completeness status of a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the framebuffer completeness check. </para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
      }
    },
    "glClearBufferiv": {
      "signature": "void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferuiv": {
      "signature": "void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfv": {
      "signature": "void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfi": {
      "signature": "void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "specify clear values for the color buffers",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearDepthf": {
      "signature": "void glClearDepthf(GLfloat depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glClientWaitSync": {
      "signature": "GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "block and wait for a sync object to become signaled",
      "parameters": {
        "sync": "<listitem> <para> The sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> may be `GL_SYNC_FLUSH_COMMANDS_BIT`. </para> </listitem>",
        "timeout": "<listitem> <para> The timeout, specified in nanoseconds, for which the implementation should wait for <parameter>sync</parameter> to become signaled. </para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "buf": "<listitem> <para> For <function>glColorMaski</function>, specifies the index of the draw buffer whose color mask to set. </para> </listitem>",
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
      }
    },
    "glColorMaski": {
      "signature": "void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "buf": "<listitem> <para> For <function>glColorMaski</function>, specifies the index of the draw buffer whose color mask to set. </para> </listitem>",
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
      }
    },
    "glCompileShader": {
      "signature": "void glCompileShader(GLuint shader)",
      "purpose": "Compiles a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage3D": {
      "signature": "void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage3D": {
      "signature": "void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCopyBufferSubData": {
      "signature": "void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)",
      "purpose": "copy part of the data store of a buffer object to the data store of another buffer object",
      "parameters": {
        "readtarget": "<listitem> <para> Specifies the target from whose data store data should be read. </para> </listitem>",
        "writetarget": "<listitem> <para> Specifies the target to whose data store data should be written. </para> </listitem>",
        "readoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>readtarget</parameter> from which data should be read. </para> </listitem>",
        "writeoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>writetarget</parameter> to which data should be written. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size, in basic machine units, of the data to be copied from <parameter>readtarget</parameter> to <parameter>writetarget</parameter>. </para> </listitem>"
      }
    },
    "glCopyImageSubData": {
      "signature": "void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)",
      "purpose": "perform a raw data copy between two images",
      "parameters": {
        "srcName": "<listitem> <para> The name of a texture or renderbuffer object from which to copy. </para> </listitem>",
        "srcTarget": "<listitem> <para> The target representing the namespace of the source name <parameter>srcName</parameter>. </para> </listitem>",
        "srcLevel": "<listitem> <para> The mipmap level to read from the source. </para> </listitem>",
        "srcX": "<listitem> <para> The X coordinate of the left edge of the souce region to copy. </para> </listitem>",
        "srcY": "<listitem> <para> The Y coordinate of the top edge of the souce region to copy. </para> </listitem>",
        "srcZ": "<listitem> <para> The Z coordinate of the near edge of the souce region to copy. </para> </listitem>",
        "dstName": "<listitem> <para> The name of a texture or renderbuffer object to which to copy. </para> </listitem>",
        "dstTarget": "<listitem> <para> The target representing the namespace of the destination name <parameter>dstName</parameter>. </para> </listitem>",
        "dstX": "<listitem> <para> The X coordinate of the left edge of the destination region. </para> </listitem>",
        "dstY": "<listitem> <para> The Y coordinate of the top edge of the destination region. </para> </listitem>",
        "dstZ": "<listitem> <para> The Z coordinate of the near edge of the destination region. </para> </listitem>",
        "srcWidth": "<listitem> <para> The width of the region to be copied. </para> </listitem>",
        "srcHeight": "<listitem> <para> The height of the region to be copied. </para> </listitem>",
        "srcDepth": "<listitem> <para> The depth of the region to be copied. </para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "copy pixels into a 2D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_R8`, `GL_RG8`, `GL_RGB565`, `GL_RGB8`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_SRGB8`, `GL_SRGB8_ALPHA8`, `GL_R8I`, `GL_R8UI`, `GL_R16I`, `GL_R16UI`, `GL_R32I`, `GL_R32UI`, `GL_RG8I`, `GL_RG8UI`, `GL_RG16I`, `GL_RG16UI`, `GL_RG32I`, `GL_RG32UI`, `GL_RGBA8I`, `GL_RGBA8UI`, `GL_RGB10_A2UI`, `GL_RGBA16I`, `GL_RGBA16UI`, `GL_RGBA32I`, `GL_RGBA32UI`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCopyTexSubImage3D": {
      "signature": "void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCreateProgram": {
      "signature": "GLuint glCreateProgram(void)",
      "purpose": "Creates a program object",
      "parameters": {}
    },
    "glCreateShader": {
      "signature": "GLuint glCreateShader(GLenum shaderType)",
      "purpose": "Creates a shader object",
      "parameters": {
        "shaderType": "<listitem> <para> Specifies the type of shader to be created. Must be one of `GL_COMPUTE_SHADER`, `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER`, or `GL_FRAGMENT_SHADER`. </para> </listitem>"
      }
    },
    "glCreateShaderProgramv": {
      "signature": "GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char **strings)",
      "purpose": "create a stand-alone program from an array of null-terminated source code strings",
      "parameters": {
        "type": "<listitem> <para> Specifies the type of shader to create. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of source code strings in the array <parameter>strings</parameter>. </para> </listitem>",
        "strings": "<listitem> <para> Specifies the address of an array of pointers to source code strings from which to create the program object. </para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing polygons can be culled",
      "parameters": {
        "mode": "<listitem> <para> Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
      }
    },
    "glDebugMessageCallback": {
      "signature": "void glDebugMessageCallback(DEBUGPROC callback, const void * userParam)",
      "purpose": "specify a callback to receive debugging messages from the GL",
      "parameters": {
        "callback": "<listitem> <para> The address of a callback function that will be called when a debug message is generated. </para> </listitem>",
        "userParam": "<listitem> <para> A user supplied pointer that will be passed on each invocation of <parameter>callback</parameter>. </para> </listitem>"
      }
    },
    "glDebugMessageControl": {
      "signature": "void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)",
      "purpose": "control the reporting of debug messages in a debug context",
      "parameters": {
        "source": "<listitem> <para> The source of debug messages to enable or disable. </para> </listitem>",
        "type": "<listitem> <para> The type of debug messages to enable or disable. </para> </listitem>",
        "severity": "<listitem> <para> The severity of debug messages to enable or disable. </para> </listitem>",
        "count": "<listitem> <para> The length of the array <parameter>ids</parameter>. </para> </listitem>",
        "ids": "<listitem> <para> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </para> </listitem>",
        "enabled": "<listitem> <para> A Boolean flag determining whether the selected messages should be enabled or disabled. </para> </listitem>"
      }
    },
    "glDebugMessageInsert": {
      "signature": "void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message)",
      "purpose": "inject an application-supplied message into the debug message queue",
      "parameters": {
        "source": "<listitem> <para> The source of the debug message to insert. </para> </listitem>",
        "type": "<listitem> <para> The type of the debug message insert. </para> </listitem>",
        "id": "<listitem> <para> The user-supplied identifier of the message to insert. </para> </listitem>",
        "severity": "<listitem> <para> The severity of the debug messages to insert. </para> </listitem>",
        "length": "<listitem> <para> The length string contained in the character array whose address is given by <parameter>message</parameter>. </para> </listitem>",
        "message": "<listitem> <para> The address of a character array containing the message to insert. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteFramebuffers": {
      "signature": "void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "delete framebuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer objects to be deleted. </para> </listitem>",
        "framebuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> framebuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteProgram": {
      "signature": "void glDeleteProgram(GLuint program)",
      "purpose": "Deletes a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteProgramPipelines": {
      "signature": "void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)",
      "purpose": "delete program pipeline objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of program pipeline objects to delete. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array of names of program pipeline objects to delete. </para> </listitem>"
      }
    },
    "glDeleteQueries": {
      "signature": "void glDeleteQueries(GLsizei n, const GLuint * ids)",
      "purpose": "delete named query objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query objects to be deleted. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of query objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteRenderbuffers": {
      "signature": "void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "delete renderbuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer objects to be deleted. </para> </listitem>",
        "renderbuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> renderbuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteSamplers": {
      "signature": "void glDeleteSamplers(GLsizei n, const GLuint * samplers)",
      "purpose": "delete named sampler objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler objects to be deleted. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array of sampler objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteShader": {
      "signature": "void glDeleteShader(GLuint shader)",
      "purpose": "Deletes a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteSync": {
      "signature": "void glDeleteSync(GLsync sync)",
      "purpose": "delete a sync object",
      "parameters": {
        "sync": "<listitem> <para> The sync object to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTransformFeedbacks": {
      "signature": "void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)",
      "purpose": "delete transform feedback objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback objects to delete. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of names of transform feedback objects to delete. </para> </listitem>"
      }
    },
    "glDeleteVertexArrays": {
      "signature": "void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)",
      "purpose": "delete vertex array objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array objects to be deleted. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies the address of an array containing the <parameter>n</parameter> names of the objects to be deleted. </para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
      }
    },
    "glDepthRangef": {
      "signature": "void glDepthRangef(GLfloat n, GLfloat f)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "n": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "f": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDetachShader": {
      "signature": "void glDetachShader(GLuint program, GLuint shader)",
      "purpose": "Detaches a shader object from a program object to which it is attached",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
      }
    },
    "glDispatchCompute": {
      "signature": "void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)",
      "purpose": "launch one or more compute work groups",
      "parameters": {
        "num_groups_x": "<listitem> <para> The number of work groups to be launched in the X dimension. </para> </listitem>",
        "num_groups_y": "<listitem> <para> The number of work groups to be launched in the Y dimension. </para> </listitem>",
        "num_groups_z": "<listitem> <para> The number of work groups to be launched in the Z dimension. </para> </listitem>"
      }
    },
    "glDispatchComputeIndirect": {
      "signature": "void glDispatchComputeIndirect(GLintptr indirect)",
      "purpose": "launch one or more compute work groups using parameters stored in a buffer",
      "parameters": {
        "indirect": "<listitem> <para> The offset into the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` buffer target at which the dispatch parameters are stored. </para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawArraysIndirect": {
      "signature": "void glDrawArraysIndirect(GLenum mode, const void *indirect)",
      "purpose": "render primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing the draw parameters. </para> </listitem>"
      }
    },
    "glDrawArraysInstanced": {
      "signature": "void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount)",
      "purpose": "draw multiple instances of a range of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawBuffers": {
      "signature": "void glDrawBuffers(GLsizei n, const GLenum *bufs)",
      "purpose": "Specifies a list of color buffers to be drawn into",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
        "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawElementsBaseVertex": {
      "signature": "void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex)",
      "purpose": "render primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>"
      }
    },
    "glDrawElementsIndirect": {
      "signature": "void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect)",
      "purpose": "render indexed primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing the draw parameters. </para> </listitem>"
      }
    },
    "glDrawElementsInstanced": {
      "signature": "void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)",
      "purpose": "draw multiple instances of a set of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawElementsInstancedBaseVertex": {
      "signature": "void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei primcount, GLint basevertex)",
      "purpose": "render multiple instances of a set of primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the indexed geometry that should be drawn. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>"
      }
    },
    "glDrawRangeElements": {
      "signature": "void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawRangeElementsBaseVertex": {
      "signature": "void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex)",
      "purpose": "render primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnablei": {
      "signature": "void glEnablei(GLenum cap, GLuint index)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisablei": {
      "signature": "void glDisablei(GLenum cap, GLuint index)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnableVertexAttribArray": {
      "signature": "void glEnableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexAttribArray": {
      "signature": "void glDisableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glFenceSync": {
      "signature": "GLsync glFenceSync(GLenum condition, GLbitfield flags)",
      "purpose": "create a new sync object and insert it into the GL command stream",
      "parameters": {
        "condition": "<listitem> <para> Specifies the condition that must be met to set the sync object's state to signaled. <parameter>condition</parameter> must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. </para> </listitem>",
        "flags": "<listitem> <para> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and <parameter>flags</parameter> must be zero.<footnote><para> <parameter>flags</parameter> is a placeholder for anticipated future extensions of fence sync object capabilities. </para> </footnote> </para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish( void)",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush( void)",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFlushMappedBufferRange": {
      "signature": "void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)",
      "purpose": "indicate modifications to a range of a mapped buffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glFlushMappedBufferRange</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the start of the buffer subrange, in basic machine units. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the buffer subrange, in basic machine units. </para> </listitem>"
      }
    },
    "glFramebufferParameteri": {
      "signature": "void glFramebufferParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set a named parameter of a framebuffer",
      "parameters": {
        "target": "<listitem> <para> The target of the operation, which must be `GL_READ_FRAMEBUFFER`, `GL_DRAW_FRAMEBUFFER` or `GL_FRAMEBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> A token indicating the parameter to be modified. </para> </listitem>",
        "param": "<listitem> <para> The new value for the parameter named <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glFramebufferRenderbuffer": {
      "signature": "void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
      "purpose": "attach a renderbuffer as a logical buffer to the currently bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "renderbuffertarget": "<listitem> <para> Specifies the renderbuffer target and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of an existing renderbuffer object of type <parameter>renderbuffertarget</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture": {
      "signature": "void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture2D": {
      "signature": "void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer to the currently bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. </para> </listitem>",
        "textarget": "<listitem> <para> Specifies a 2D texture target, 2D multisample texture target, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTextureLayer": {
      "signature": "void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)",
      "purpose": "attach a single layer of a texture to a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>",
        "layer": "<listitem> <para> Specifies the layer of <parameter>texture</parameter> to attach. </para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
      }
    },
    "glGenerateMipmap": {
      "signature": "void glGenerateMipmap(GLenum target)",
      "purpose": "generate mipmaps for a specified texture target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture whose mimaps to generate is bound. <parameter>target</parameter> must be `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>"
      }
    },
    "glGenFramebuffers": {
      "signature": "void glGenFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "generate framebuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer object names to generate. </para> </listitem>",
        "framebuffers": "<listitem> <para> Specifies an array in which the generated framebuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenProgramPipelines": {
      "signature": "void glGenProgramPipelines(GLsizei n, GLuint *pipelines)",
      "purpose": "reserve program pipeline object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of program pipeline object names to reserve. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenQueries": {
      "signature": "void glGenQueries(GLsizei n, GLuint * ids)",
      "purpose": "generate query object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query object names to be generated. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which the generated query object names are stored. </para> </listitem>"
      }
    },
    "glGenRenderbuffers": {
      "signature": "void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "generate renderbuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer object names to generate. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array in which the generated renderbuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenSamplers": {
      "signature": "void glGenSamplers(GLsizei n, GLuint *samplers)",
      "purpose": "generate sampler object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler object names to generate. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array in which the generated sampler object names are stored. </para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
      }
    },
    "glGenTransformFeedbacks": {
      "signature": "void glGenTransformFeedbacks(GLsizei n, GLuint *ids)",
      "purpose": "reserve transform feedback object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback object names to reserve. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenVertexArrays": {
      "signature": "void glGenVertexArrays(GLsizei n, GLuint *arrays)",
      "purpose": "generate vertex array object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array object names to generate. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies an array in which the generated vertex array object names are stored. </para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64v": {
      "signature": "void glGetInteger64v(GLenum pname, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetBooleani_v": {
      "signature": "void glGetBooleani_v(GLenum target, GLuint index, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegeri_v": {
      "signature": "void glGetIntegeri_v(GLenum target, GLuint index, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64i_v": {
      "signature": "void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetActiveAttrib": {
      "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active attribute variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
      }
    },
    "glGetActiveUniform": {
      "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active uniform variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
      }
    },
    "glGetActiveUniformBlockiv": {
      "signature": "void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)",
      "purpose": "query information about an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable to receive the result of the query. </para> </listitem>"
      }
    },
    "glGetActiveUniformBlockName": {
      "signature": "void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)",
      "purpose": "retrieve the name of an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer addressed by <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of characters that were written to <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters to receive the name of the uniform block at <parameter>uniformBlockIndex</parameter>. </para> </listitem>"
      }
    },
    "glGetActiveUniformsiv": {
      "signature": "void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)",
      "purpose": "Returns information about several active uniform variables for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "uniformCount": "<listitem> <para>Specifies both the number of elements in the array of indices <parameter>uniformIndices</parameter> and the number of parameters written to <parameter>params</parameter> upon successful return.</para> </listitem>",
        "uniformIndices": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers containing the indices of uniforms within <parameter>program</parameter> whose parameter <parameter>pname</parameter> should be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the property of each uniform in <parameter>uniformIndices</parameter> that should be written into the corresponding element of <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers which are to receive the value of <parameter>pname</parameter> for each uniform in <parameter>uniformIndices</parameter>.</para> </listitem>"
      }
    },
    "glGetAttachedShaders": {
      "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
      "purpose": "Returns the handles of the shader objects attached to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
        "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
      }
    },
    "glGetAttribLocation": {
      "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of an attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferParameteri64v": {
      "signature": "void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferPointerv": {
      "signature": "void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)",
      "purpose": "return the pointer to a mapped buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glGetBufferPointerv</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "pname": "<listitem> <para> Specifies the pointer to be returned. The symbolic constant must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetDebugMessageLog": {
      "signature": "GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)",
      "purpose": "retrieve messages from the debug message log",
      "parameters": {
        "count": "<listitem> <para> The number of debug messages to retrieve from the log. </para> </listitem>",
        "bufSize": "<listitem> <para> The size of the buffer whose address is given by <parameter>messageLog</parameter>. </para> </listitem>",
        "sources": "<listitem> <para> The address of an array of variables to receive the sources of the retrieved messages. </para> </listitem>",
        "types": "<listitem> <para> The address of an array of variables to receive the types of the retrieved messages. </para> </listitem>",
        "ids": "<listitem> <para> The address of an array of unsigned integers to receive the ids of the retrieved messages. </para> </listitem>",
        "severities": "<listitem> <para> The address of an array of variables to receive the severites of the retrieved messages. </para> </listitem>",
        "lengths": "<listitem> <para> The address of an array of variables to receive the lengths of the received messages. </para> </listitem>",
        "messageLog": "<listitem> <para> The address of an array of characters that will receive the messages. </para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError( void)",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetFragDataLocation": {
      "signature": "GLint glGetFragDataLocation(GLuint program, const char * name)",
      "purpose": "query the bindings of color numbers to user-defined varying out variables",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to query </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to query </para> </listitem>"
      }
    },
    "glGetFramebufferAttachmentParameteriv": {
      "signature": "void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)",
      "purpose": "retrieve information about attachments of a bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the query operation. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment within <parameter>target</parameter> </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of <parameter>attachment</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable receive the value of <parameter>pname</parameter> for <parameter>attachment</parameter>. </para> </listitem>"
      }
    },
    "glGetFramebufferParameteriv": {
      "signature": "void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "retrieve a named parameter from a framebuffer",
      "parameters": {
        "target": "<listitem> <para> The target of the operation, which must be `GL_READ_FRAMEBUFFER`, `GL_DRAW_FRAMEBUFFER` or `GL_FRAMEBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> A token indicating the parameter to be retrieved. </para> </listitem>",
        "params": "<listitem> <para> The address of a variable to receive the value of the parameter named <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetGraphicsResetStatus": {
      "signature": "GLenum glGetGraphicsResetStatus(void)",
      "purpose": "check if the rendering context has not been lost due to software or hardware issues",
      "parameters": {}
    },
    "glGetInternalformativ": {
      "signature": "void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)",
      "purpose": "retrieve information about implementation-dependent support for internal formats",
      "parameters": {
        "target": "<listitem> <para> Indicates the usage of the internal format. <parameter>target</parameter> must be `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format about which to retrieve information. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the type of information to query. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of integers that may be written to <parameter>params</parameter> by the function. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
      }
    },
    "glGetMultisamplefv": {
      "signature": "void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)",
      "purpose": "retrieve the location of a sample",
      "parameters": {
        "pname": "<listitem> <para> Specifies the sample parameter name. <parameter>pname</parameter> must be `GL_SAMPLE_POSITION`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the sample whose position to query. </para> </listitem>",
        "val": "<listitem> <para> Specifies the address of an array to receive the position of the sample. </para> </listitem>"
      }
    },
    "glGetObjectLabel": {
      "signature": "void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bifSize, GLsizei * length, char * label)",
      "purpose": "retrieve the label of a named object identified within a namespace",
      "parameters": {
        "identifier": "<listitem> <para> The namespace from which the name of the object is allocated. </para> </listitem>",
        "name": "<listitem> <para> The name of the object whose label to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The length of the buffer whose address is in <parameter>label</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable to receive the length of the object label. </para> </listitem>",
        "label": "<listitem> <para> The address of a string that will receive the object label. </para> </listitem>"
      }
    },
    "glGetObjectPtrLabel": {
      "signature": "void glGetObjectPtrLabel(void * ptr, GLsizei bifSize, GLsizei * length, char * label)",
      "purpose": "retrieve the label of a sync object identified by a pointer",
      "parameters": {
        "ptr": "<listitem> <para> The name of the sync object whose label to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The length of the buffer whose address is in <parameter>label</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable to receive the length of the object label. </para> </listitem>",
        "label": "<listitem> <para> The address of a string that will receive the object label. </para> </listitem>"
      }
    },
    "glGetPointerv": {
      "signature": "void glGetPointerv(GLenum pname, void ** params)",
      "purpose": "return the address of the specified pointer",
      "parameters": {
        "pname": "<listitem> <para> Specifies the pointer to be returned. Must be one of `GL_DEBUG_CALLBACK_FUNCTION` or `GL_DEBUG_CALLBACK_USER_PARAM`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramBinary": {
      "signature": "void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary)",
      "purpose": "return a binary representation of a program object's compiled and linked executable source",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose binary representation to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given by <parameter>binary</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of bytes written into <parameter>binary</parameter>. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address an array into which the GL will return <parameter>program</parameter>'s binary representation. </para> </listitem>"
      }
    },
    "glGetProgramInfoLog": {
      "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetProgramInterfaceiv": {
      "signature": "void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params)",
      "purpose": "query a property of an interface in a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose interface to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> to query. </para> </listitem>",
        "pname": "<listitem> <para> The name of the parameter within <parameter>programInterface</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> The address of a variable to retrieve the value of <parameter>pname</parameter> for the program interface. </para> </listitem>"
      }
    },
    "glGetProgramiv": {
      "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_COMPUTE_WORK_GROUP_SIZE`, `GL_DELETE_STATUS`, `GL_GEOMETRY_LINKED_INPUT_TYPE`, `GL_GEOMETRY_LINKED_OUTPUT_TYPE`, `GL_GEOMETRY_LINKED_VERTICES_OUT`, `GL_GEOMETRY_SHADER_INVOCATIONS`, `GL_INFO_LOG_LENGTH`, `GL_LINK_STATUS`, `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, `GL_PROGRAM_SEPARABLE`, `GL_TESS_CONTROL_OUTPUT_VERTICES`, `GL_TESS_GEN_MODE`, `GL_TESS_GEN_POINT_MODE`, `GL_TESS_GEN_SPACING`, `GL_TESS_GEN_VERTEX_ORDER`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH` and `GL_VALIDATE_STATUS`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetProgramPipelineiv": {
      "signature": "void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)",
      "purpose": "retrieve properties of a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object whose parameter retrieve. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to retrieve. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which will be written the value or values of <parameter>pname</parameter> for <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramPipelineInfoLog": {
      "signature": "void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)",
      "purpose": "retrieve the info log string from a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object from which to retrieve the info log. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of characters, including the null terminator, that may be written into <parameter>infoLog</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable into which will be written the number of characters written into <parameter>infoLog</parameter>. </para> </listitem>",
        "infoLog": "<listitem> <para> Specifies the address of an array of characters into which will be written the info log for <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramResourceiv": {
      "signature": "void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params)",
      "purpose": "retrieve values for multiple properties of a single active resource within a program object",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramResourceIndex": {
      "signature": "GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the index of a named resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the index of. </para> </listitem>"
      }
    },
    "glGetProgramResourceLocation": {
      "signature": "GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the location of a named resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the location of. </para> </listitem>"
      }
    },
    "glGetProgramResourceName": {
      "signature": "void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name)",
      "purpose": "query the name of an indexed resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the indexed resource. </para> </listitem>",
        "index": "<listitem> <para> The index of the resource within <parameter>programInterface</parameter> of <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> The size of the character array whose address is given by <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the length of the resource name. </para> </listitem>",
        "name": "<listitem> <para> The address of a character array into which will be written the name of the resource. </para> </listitem>"
      }
    },
    "glGetQueryiv": {
      "signature": "void glGetQueryiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object target",
      "parameters": {
        "target": "<listitem> <para> Specifies a query object target. Must be `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Must be `GL_CURRENT_QUERY`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryObjectuiv": {
      "signature": "void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT` or `GL_QUERY_RESULT_AVAILABLE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetRenderbufferParameteriv": {
      "signature": "void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)",
      "purpose": "retrieve information about a bound renderbuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the query operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the renderbuffer bound to <parameter>target</parameter>. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of an array to receive the value of the queried parameter. </para> </listitem>"
      }
    },
    "glGetSamplerParameterfv": {
      "signature": "void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameteriv": {
      "signature": "void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameterIiv": {
      "signature": "void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameterIuiv": {
      "signature": "void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetShaderInfoLog": {
      "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetShaderiv": {
      "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetShaderPrecisionFormat": {
      "signature": "void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)",
      "purpose": "retrieve the range and precision for numeric formats supported by the shader compiler",
      "parameters": {
        "shaderType": "<listitem> <para> Specifies the type of shader whose precision to query. <parameter>shaderType</parameter> must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "precisionType": "<listitem> <para> Specifies the numeric format whose precision and range to query. </para> </listitem>",
        "range": "<listitem> <para> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </para> </listitem>",
        "precision": "<listitem> <para> Specifies the address of an integer into which the numeric precision of the implementation is written. </para> </listitem>"
      }
    },
    "glGetShaderSource": {
      "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
      "purpose": "Returns the source code string from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
        "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte* glGetString(GLenum name)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetStringi": {
      "signature": "const GLubyte* glGetStringi(GLenum name, GLuint index)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetSynciv": {
      "signature": "void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)",
      "purpose": "query the properties of a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose properties to query. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the sync object specified in <parameter>sync</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>values</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of an variable to receive the number of integers placed in <parameter>values</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array to receive the values of the queried parameter. </para> </listitem>"
      }
    },
    "glGetTexLevelParameterfv": {
      "signature": "void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values for a specific level of detail",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture, one of `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_SAMPLES`, `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_STENCIL_SIZE`, `GL_TEXTURE_SHARED_SIZE`, `GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`, `GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_BUFFER_DATA_STORE_BINDING`, `GL_TEXTURE_BUFFER_OFFSET`, and `GL_TEXTURE_BUFFER_SIZE` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexLevelParameteriv": {
      "signature": "void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values for a specific level of detail",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture, one of `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_SAMPLES`, `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_STENCIL_SIZE`, `GL_TEXTURE_SHARED_SIZE`, `GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`, `GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_BUFFER_DATA_STORE_BINDING`, `GL_TEXTURE_BUFFER_OFFSET`, and `GL_TEXTURE_BUFFER_SIZE` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTexParameterIiv": {
      "signature": "void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTexParameterIuiv": {
      "signature": "void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, and `GL_TEXTURE_BORDER_COLOR` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTransformFeedbackVarying": {
      "signature": "void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name)",
      "purpose": "retrieve information about varying variables selected for transform feedback",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "index": "<listitem> <para> The index of the varying variable whose information to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The maximum number of characters, including the null terminator, that may be written into <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the number of characters written into <parameter>name</parameter>, excluding the null-terminator. If <parameter>length</parameter> is `NULL` no length is returned. </para> </listitem>",
        "size": "<listitem> <para> The address of a variable that will receive the size of the varying. </para> </listitem>",
        "type": "<listitem> <para> The address of a variable that will receive the type of the varying. </para> </listitem>",
        "name": "<listitem> <para> The address of a buffer into which will be written the name of the varying. </para> </listitem>"
      }
    },
    "glGetUniformfv": {
      "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>. </para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformiv": {
      "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>. </para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformuiv": {
      "signature": "void glGetUniformuiv(GLuint program, GLint location, GLuint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>. </para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformfv": {
      "signature": "void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>. </para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformiv": {
      "signature": "void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>. </para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformuiv": {
      "signature": "void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>. </para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformBlockIndex": {
      "signature": "GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters containing the name of the uniform block whose index to retrieve. </para> </listitem>"
      }
    },
    "glGetUniformIndices": {
      "signature": "void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing uniforms whose indices to query. </para> </listitem>",
        "uniformCount": "<listitem> <para> Specifies the number of uniforms whose indices to query. </para> </listitem>",
        "uniformNames": "<listitem> <para> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </para> </listitem>",
        "uniformIndices": "<listitem> <para> Specifies the address of an array that will receive the indices of the uniforms. </para> </listitem>"
      }
    },
    "glGetUniformLocation": {
      "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetVertexAttribfv": {
      "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribiv": {
      "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIiv": {
      "signature": "void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIuiv": {
      "signature": "void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribPointerv": {
      "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
      "purpose": "return the address of the specified generic vertex attribute pointer",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
        "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_FRAGMENT_SHADER_DERIVATIVE_HINT`, and `GL_GENERATE_MIPMAP_HINT` are accepted. </para> </listitem>",
        "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
      }
    },
    "glInvalidateFramebuffer": {
      "signature": "void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)",
      "purpose": "Invalidate the contents of attachments within a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
        "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>"
      }
    },
    "glInvalidateSubFramebuffer": {
      "signature": "void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLintx, GLinty, GLsizei width, GLsizei height)",
      "purpose": "Invalidate portions of the contents of attachments within a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
        "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>",
        "x": "<listitem> <para> Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
        "y": "<listitem> <para> Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the pixel rectangle to invalidate. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the pixel rectangle to invalidate. </para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
      }
    },
    "glIsEnabledi": {
      "signature": "GLboolean glIsEnabledi(GLenum cap, GLuint index)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
      }
    },
    "glIsFramebuffer": {
      "signature": "GLboolean glIsFramebuffer(GLuint framebuffer)",
      "purpose": "determine if a name corresponds to a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies a value that may be the name of a framebuffer object. </para> </listitem>"
      }
    },
    "glIsProgram": {
      "signature": "GLboolean glIsProgram(GLuint program)",
      "purpose": "Determines if a name corresponds to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
      }
    },
    "glIsProgramPipeline": {
      "signature": "GLboolean glIsProgramPipeline(GLuint pipeline)",
      "purpose": "determine if a name corresponds to a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies a value that may be the name of a program pipeline object. </para> </listitem>"
      }
    },
    "glIsQuery": {
      "signature": "GLboolean glIsQuery(GLuint id)",
      "purpose": "determine if a name corresponds to a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a query object. </para> </listitem>"
      }
    },
    "glIsRenderbuffer": {
      "signature": "GLboolean glIsRenderbuffer(GLuint renderbuffer)",
      "purpose": "determine if a name corresponds to a renderbuffer object",
      "parameters": {
        "renderbuffer": "<listitem> <para> Specifies a value that may be the name of a renderbuffer object. </para> </listitem>"
      }
    },
    "glIsSampler": {
      "signature": "GLboolean glIsSampler(GLuint id)",
      "purpose": "determine if a name corresponds to a sampler object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a sampler object. </para> </listitem>"
      }
    },
    "glIsShader": {
      "signature": "GLboolean glIsShader(GLuint shader)",
      "purpose": "Determines if a name corresponds to a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
      }
    },
    "glIsSync": {
      "signature": "GLboolean glIsSync(GLsync sync)",
      "purpose": "determine if a name corresponds to a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies a value that may be the name of a sync object. </para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glIsTransformFeedback": {
      "signature": "GLboolean glIsTransformFeedback(GLuint id)",
      "purpose": "determine if a name corresponds to a transform feedback object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a transform feedback object. </para> </listitem>"
      }
    },
    "glIsVertexArray": {
      "signature": "GLboolean glIsVertexArray(GLuint array)",
      "purpose": "determine if a name corresponds to a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies a value that may be the name of a vertex array object. </para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
      }
    },
    "glLinkProgram": {
      "signature": "void glLinkProgram(GLuint program)",
      "purpose": "Links a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
      }
    },
    "glMapBufferRange": {
      "signature": "void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)",
      "purpose": "map a section of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glMapBufferRange</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
      }
    },
    "glUnmapBuffer": {
      "signature": "GLboolean glUnmapBuffer(GLenum target)",
      "purpose": "map a section of a buffer object's data store",
      "parameters": {
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
      }
    },
    "glMemoryBarrier": {
      "signature": "void glMemoryBarrier(GLbitfield barriers)",
      "purpose": "defines a barrier ordering memory transactions",
      "parameters": {
        "barriers": "<listitem> <para> Specifies the barriers to insert. Must be a bitwise combination of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers will be inserted. </para> </listitem>"
      }
    },
    "glMemoryBarrierByRegion": {
      "signature": "void glMemoryBarrierByRegion(GLbitfield barriers)",
      "purpose": "defines a barrier ordering memory transactions",
      "parameters": {
        "barriers": "<listitem> <para> Specifies the barriers to insert. Must be a bitwise combination of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers will be inserted. </para> </listitem>"
      }
    },
    "glMinSampleShading": {
      "signature": "void glMinSampleShading(GLfloat value)",
      "purpose": "specifies minimum rate at which sample shading takes place",
      "parameters": {
        "value": "<listitem> <para> Specifies the rate at which samples are shaded within each covered pixel. </para> </listitem>"
      }
    },
    "glObjectLabel": {
      "signature": "void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label)",
      "purpose": "label a named object identified within a namespace",
      "parameters": {
        "identifier": "<listitem> <para> The namespace from which the name of the object is allocated. </para> </listitem>",
        "name": "<listitem> <para> The name of the object to label. </para> </listitem>",
        "length": "<listitem> <para> The length of the label to be used for the object. </para> </listitem>",
        "label": "<listitem> <para> The address of a string containing the label to assign to the object. </para> </listitem>"
      }
    },
    "glObjectPtrLabel": {
      "signature": "void glObjectPtrLabel(void * ptr, GLsizei length, const char * label)",
      "purpose": "label a sync object identified by a pointer",
      "parameters": {
        "ptr": "<listitem> <para> A pointer identifying a sync object. </para> </listitem>",
        "length": "<listitem> <para> The length of the label to be used for the object. </para> </listitem>",
        "label": "<listitem> <para> The address of a string containing the label to assign to the object. </para> </listitem>"
      }
    },
    "glPatchParameteri": {
      "signature": "void glPatchParameteri(GLenum pname, GLint value)",
      "purpose": "specifies the parameters for patch primitives",
      "parameters": {
        "pname": "<listitem> <para> Specifies the name of the parameter to set. The symbolc constants `GL_PATCH_VERTICES` is accepted. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value for the parameter given by <parameter>pname</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array containing the new values for the parameter given by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glPauseTransformFeedback": {
      "signature": "void glPauseTransformFeedback(void)",
      "purpose": "pause transform feedback operations",
      "parameters": {}
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Four values affect the packing of pixel data into memory: `GL_PACK_ROW_LENGTH`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth values",
      "parameters": {
        "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
        "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
      }
    },
    "glPopDebugGroup": {
      "signature": "void glPopDebugGroup(void)",
      "purpose": "pop the active debug group",
      "parameters": {}
    },
    "glPrimitiveBoundingBox": {
      "signature": "void glPrimitiveBoundingBox(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)",
      "purpose": "set the bounding box for a primitive",
      "parameters": {
        "minX": "<listitem> <para> Specify the minimum clip space coordinate of the bounding box. The initial value is (-1, -1, -1, 1). </para> </listitem>",
        "maxX": "<listitem> <para> Specify the maximum clip space coordinate of the bounding box. The initial value is (1, 1, 1, 1). </para> </listitem>"
      }
    },
    "glProgramBinary": {
      "signature": "void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load a program object with a program binary",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object into which to load a program binary. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the binary data in binary. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array containing the binary to be loaded into <parameter>program</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the number of bytes contained in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glProgramParameteri": {
      "signature": "void glProgramParameteri(GLuint program, GLenum pname, GLint value)",
      "purpose": "specify a parameter for a program object",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to modify. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value of the parameter specified by <parameter>pname</parameter> for <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glProgramUniform1f": {
      "signature": "void glProgramUniform1f(GLuint program, GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2f": {
      "signature": "void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3f": {
      "signature": "void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4f": {
      "signature": "void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1i": {
      "signature": "void glProgramUniform1i(GLuint program, GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2i": {
      "signature": "void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3i": {
      "signature": "void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4i": {
      "signature": "void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1ui": {
      "signature": "void glProgramUniform1ui(GLuint program, GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2ui": {
      "signature": "void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3ui": {
      "signature": "void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4ui": {
      "signature": "void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1fv": {
      "signature": "void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2fv": {
      "signature": "void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3fv": {
      "signature": "void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4fv": {
      "signature": "void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1iv": {
      "signature": "void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2iv": {
      "signature": "void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3iv": {
      "signature": "void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4iv": {
      "signature": "void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1uiv": {
      "signature": "void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2uiv": {
      "signature": "void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3uiv": {
      "signature": "void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4uiv": {
      "signature": "void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2fv": {
      "signature": "void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3fv": {
      "signature": "void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4fv": {
      "signature": "void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2x3fv": {
      "signature": "void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3x2fv": {
      "signature": "void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2x4fv": {
      "signature": "void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4x2fv": {
      "signature": "void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3x4fv": {
      "signature": "void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4x3fv": {
      "signature": "void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glPushDebugGroup": {
      "signature": "void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message)",
      "purpose": "push a named debug group into the command stream",
      "parameters": {
        "source": "<listitem> <para> The source of the debug message. </para> </listitem>",
        "id": "<listitem> <para> The identifier of the message. </para> </listitem>",
        "length": "<listitem> <para> The length of the message to be sent to the debug output stream. </para> </listitem>",
        "message": "<listitem> <para> The a string containing the message to be sent to the debug output stream. </para> </listitem>"
      }
    },
    "glReadBuffer": {
      "signature": "void glReadBuffer(GLenum src)",
      "purpose": "select a color buffer source for pixels",
      "parameters": {
        "src": "<listitem> <para> Specifies a color buffer. Accepted values are `GL_BACK`, `GL_NONE`, and `GL_COLOR_ATTACHMENTi`. </para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RGBA`, and `GL_RGBA_INTEGER`. An implementation-chosen format will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_FORMAT`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_INT`, or `GL_FLOAT`. An implementation-chosen type will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_TYPE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
      }
    },
    "glReadnPixels": {
      "signature": "void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RGBA`, and `GL_RGBA_INTEGER`. An implementation-chosen format will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_FORMAT`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_INT`, or `GL_FLOAT`. An implementation-chosen type will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_TYPE`. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer <parameter>data</parameter> for <function>glReadnPixels</function> function. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
      }
    },
    "glReleaseShaderCompiler": {
      "signature": "void glReleaseShaderCompiler(void)",
      "purpose": "release resources consumed by the implementation's shader compiler",
      "parameters": {}
    },
    "glRenderbufferStorage": {
      "signature": "void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format and dimensions of a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
      }
    },
    "glRenderbufferStorageMultisample": {
      "signature": "void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format, dimensions and sample count of a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "samples": "<listitem> <para> Specifies the number of samples to be used for the renderbuffer object's storage. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
      }
    },
    "glResumeTransformFeedback": {
      "signature": "void glResumeTransformFeedback(void)",
      "purpose": "resume transform feedback operations",
      "parameters": {}
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLfloat value, GLboolean invert)",
      "purpose": "specify multisample coverage parameters",
      "parameters": {
        "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
        "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glSampleMaski": {
      "signature": "void glSampleMaski(GLuint maskNumber, GLbitfield mask)",
      "purpose": "set the value of a sub-word of the sample mask",
      "parameters": {
        "maskNumber": "<listitem> <para> Specifies which 32-bit sub-word of the sample mask to update. </para> </listitem>",
        "mask": "<listitem> <para> Specifies the new value of the mask sub-word. </para> </listitem>"
      }
    },
    "glSamplerParameterf": {
      "signature": "void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`. </para> <para> For the vector commands (<function>glSamplerParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteri": {
      "signature": "void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`. </para> <para> For the vector commands (<function>glSamplerParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterfv": {
      "signature": "void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`. </para> <para> For the vector commands (<function>glSamplerParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteriv": {
      "signature": "void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`. </para> <para> For the vector commands (<function>glSamplerParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterIiv": {
      "signature": "void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`. </para> <para> For the vector commands (<function>glSamplerParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterIuiv": {
      "signature": "void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`. </para> <para> For the vector commands (<function>glSamplerParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glShaderBinary": {
      "signature": "void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load pre-compiled shader binaries",
      "parameters": {
        "count": "<listitem> <para> Specifies the number of shader object handles contained in <parameter>shaders</parameter>. </para> </listitem>",
        "shaders": "<listitem> <para> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the shader binaries contained in <parameter>binary</parameter>. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array of bytes containing pre-compiled binary shader code. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the array whose address is given in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glShaderSource": {
      "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)",
      "purpose": "Replaces the source code in a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
        "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
        "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and back function and reference value for stencil testing",
      "parameters": {
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilFuncSeparate": {
      "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and/or back function and reference value for stencil testing",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the front and back writing of individual bits in the stencil planes",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilMaskSeparate": {
      "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
      "purpose": "control the front and/or back writing of individual bits in the stencil planes",
      "parameters": {
        "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and back stencil test actions",
      "parameters": {
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glStencilOpSeparate": {
      "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and/or back stencil test actions",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glTexBuffer": {
      "signature": "void glTexBuffer(GLenum target, GLenum internalFormat, GLuint buffer)",
      "purpose": "attach a buffer object's data store to a buffer texture object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound for <function>glTexBuffer</function>. Must be `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the internal format of the data in the store belonging to <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </para> </listitem>"
      }
    },
    "glTexBufferRange": {
      "signature": "void glTexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer, GLintptr offset, GLsizeiptr size)",
      "purpose": "attach a range of a buffer object's data store to a buffer texture object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexBufferRange</function>. Must be `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the internal format of the data in the store belonging to <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset of the start of the range of the buffer's data store to attach. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size of the range of the buffer's data store to attach. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_STENCIL_INDEX`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage3D": {
      "signature": "void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"> <msup><mi mathvariant=\"italic\">n</mi> <mi mathvariant=\"italic\">th</mi> </msup> </math></inlineequation> mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_STENCIL_INDEX`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`. </para> <para> For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`. </para> <para> For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`. </para> <para> For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`. </para> <para> For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameterIiv": {
      "signature": "void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`. </para> <para> For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameterIuiv": {
      "signature": "void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`. </para> <para> For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be `GL_TEXTURE_BORDER_COLOR`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexStorage2D": {
      "signature": "void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "simultaneously specify storage for all levels of a two-dimensional texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_2D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage2DMultisample": {
      "signature": "void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be `GL_TEXTURE_2D_MULTISAMPLE`. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexStorage3D": {
      "signature": "void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)",
      "purpose": "simultaneously specify storage for all levels of a three-dimensional, two-dimensional array, or cube map array texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage3DMultisample": {
      "signature": "void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample array texture",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexStorage3DMultisample</function>. Must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in layers. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage3D": {
      "signature": "void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTransformFeedbackVaryings": {
      "signature": "void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode)",
      "purpose": "specify values to record in transform feedback buffers",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "count": "<listitem> <para> The number of varying variables used for transform feedback. </para> </listitem>",
        "varyings": "<listitem> <para> An array of <parameter>count</parameter> zero-terminated strings specifying the names of the varying variables to use for transform feedback. </para> </listitem>",
        "bufferMode": "<listitem> <para> Identifies the mode used to capture the varying variables when transform feedback is active. <parameter>bufferMode</parameter> must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`. </para> </listitem>"
      }
    },
    "glUniform1f": {
      "signature": "void glUniform1f(GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2f": {
      "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3f": {
      "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4f": {
      "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1i": {
      "signature": "void glUniform1i(GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2i": {
      "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3i": {
      "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4i": {
      "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1ui": {
      "signature": "void glUniform1ui(GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2ui": {
      "signature": "void glUniform2ui(GLint location, GLuint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3ui": {
      "signature": "void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4ui": {
      "signature": "void glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1fv": {
      "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2fv": {
      "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3fv": {
      "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4fv": {
      "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1iv": {
      "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2iv": {
      "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3iv": {
      "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4iv": {
      "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1uiv": {
      "signature": "void glUniform1uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2uiv": {
      "signature": "void glUniform2uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3uiv": {
      "signature": "void glUniform3uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4uiv": {
      "signature": "void glUniform4uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2fv": {
      "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3fv": {
      "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4fv": {
      "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x3fv": {
      "signature": "void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x2fv": {
      "signature": "void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x4fv": {
      "signature": "void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x2fv": {
      "signature": "void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x4fv": {
      "signature": "void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x3fv": {
      "signature": "void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformBlockBinding": {
      "signature": "void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)",
      "purpose": "assign a binding point to an active uniform block",
      "parameters": {
        "program": "<listitem> <para> The name of a program object containing the active uniform block whose binding to assign. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> The index of the active uniform block within <parameter>program</parameter> whose binding to assign. </para> </listitem>",
        "uniformBlockBinding": "<listitem> <para> Specifies the binding point to which to bind the uniform block with index <parameter>uniformBlockIndex</parameter> within <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glUseProgram": {
      "signature": "void glUseProgram(GLuint program)",
      "purpose": "Installs a program object as part of current rendering state",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
      }
    },
    "glUseProgramStages": {
      "signature": "void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)",
      "purpose": "bind stages of a program object to a program pipeline",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the program pipeline object to which to bind stages from <parameter>program</parameter>. </para> </listitem>",
        "stages": "<listitem> <para> Specifies a set of program stages to bind to the program pipeline object. </para> </listitem>",
        "program": "<listitem> <para> Specifies the program object containing the shader executables to use in <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glValidateProgram": {
      "signature": "void glValidateProgram(GLuint program)",
      "purpose": "Validates a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
      }
    },
    "glValidateProgramPipeline": {
      "signature": "void glValidateProgramPipeline(GLuint pipeline)",
      "purpose": "validate a program pipeline object against current GL state",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object to validate. </para> </listitem>"
      }
    },
    "glVertexAttrib1f": {
      "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2f": {
      "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3f": {
      "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4f": {
      "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4i": {
      "signature": "void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4ui": {
      "signature": "void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1fv": {
      "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2fv": {
      "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3fv": {
      "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4fv": {
      "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4iv": {
      "signature": "void glVertexAttribI4iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4uiv": {
      "signature": "void glVertexAttribI4uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribBinding": {
      "signature": "void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)",
      "purpose": "associate a vertex attribute and a vertex buffer binding",
      "parameters": {
        "attribindex": "<listitem> <para> The index of the attribute to associate with a vertex buffer binding. </para> </listitem>",
        "bindingindex": "<listitem> <para> The index of the vertex buffer binding with which to associate the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribDivisor": {
      "signature": "void glVertexAttribDivisor(GLuint index, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes advance during instanced rendering",
      "parameters": {
        "index": "<listitem> <para> Specify the index of the generic vertex attribute. </para> </listitem>",
        "divisor": "<listitem> <para> Specify the number of instances that will pass between updates of the generic attribute at slot <parameter>index</parameter>. </para> </listitem>"
      }
    },
    "glVertexAttribFormat": {
      "signature": "void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para> The generic vertex attribute array being described. </para> </listitem>",
        "size": "<listitem> <para> The number of values per vertex that are stored in the array. </para> </listitem>",
        "type": "<listitem> <para> The type of the data stored in the array. </para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para> An offset to the first element relative to the start of the vertex buffer binding. </para> </listitem>"
      }
    },
    "glVertexAttribIFormat": {
      "signature": "void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para> The generic vertex attribute array being described. </para> </listitem>",
        "size": "<listitem> <para> The number of values per vertex that are stored in the array. </para> </listitem>",
        "type": "<listitem> <para> The type of the data stored in the array. </para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para> An offset to the first element relative to the start of the vertex buffer binding. </para> </listitem>"
      }
    },
    "glVertexAttribPointer": {
      "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0. </para> </listitem>"
      }
    },
    "glVertexAttribIPointer": {
      "signature": "void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0. </para> </listitem>"
      }
    },
    "glVertexBindingDivisor": {
      "signature": "void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes advance",
      "parameters": {
        "bindingindex": "<listitem> <para> The index of the binding whose divisor to modify. </para> </listitem>",
        "divisor": "<listitem> <para> The new value for the instance step rate to apply. </para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glWaitSync": {
      "signature": "void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "instruct the GL server to block until the specified sync object becomes signaled",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> must be zero. </para> </listitem>",
        "timeout": "<listitem> <para> Specifies the timeout that the server should wait before continuing. <parameter>timeout</parameter> must be `GL_TIMEOUT_IGNORED`. </para> </listitem>"
      }
    },
    "greaterThan": {
      "signature": "bvec greaterThan(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "greaterThanEqual": {
      "signature": "bvec greaterThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "groupMemoryBarrier": {
      "signature": "void groupMemoryBarrier(void)",
      "purpose": "controls the ordering of memory transaction issued shader invocation relative to a work group",
      "parameters": {}
    },
    "imageAtomicAdd": {
      "signature": "int imageAtomicAdd(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically add a value to an existing value in memory and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to add <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to add the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to add into the image. </para> </listitem>"
      }
    },
    "imageAtomicAnd": {
      "signature": "int imageAtomicAnd(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically compute the logical AND of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to logically AND into the image. </para> </listitem>"
      }
    },
    "imageAtomicCompSwap": {
      "signature": "int imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, int compare, int data)",
      "purpose": "atomically compares supplied data with that in memory and conditionally stores it to memory",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to compare and conditionally store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to compare and conditionally store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to compare and conditionally store into. </para> </listitem>",
        "compare": "<listitem> <para> Specifies the value to compare with the content of the image. </para> </listitem>",
        "data": "<listitem> <para> Specifies the value to store in the image if <parameter>compare</parameter> is equal to the existing image content. </para> </listitem>"
      }
    },
    "imageAtomicExchange": {
      "signature": "int imageAtomicExchange(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically store supplied data into memory and return the original value from memory",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to exchange with that stored in the image. </para> </listitem>"
      }
    },
    "imageAtomicMax": {
      "signature": "int imageAtomicMax(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically compute the maximum of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data of which to take the maximum with that stored in the image. </para> </listitem>"
      }
    },
    "imageAtomicMin": {
      "signature": "int imageAtomicMin(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically compute the minimum of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data of which to take the minimum with that stored in the image. </para> </listitem>"
      }
    },
    "imageAtomicOr": {
      "signature": "int imageAtomicOr(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically compute the logical OR of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to logically OR into the image. </para> </listitem>"
      }
    },
    "imageAtomicXor": {
      "signature": "int imageAtomicXor(gimageCubeArray image, ivec3 P, int data)",
      "purpose": "atomically compute the logical exclusive OR of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to logically XOR into the image. </para> </listitem>"
      }
    },
    "imageLoad": {
      "signature": "gvec4 imageLoad(gimageCubeArray image, ivec3 P)",
      "purpose": "load a single texel from an image",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit from which to load a texel. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate from which to load the texel. </para> </listitem>"
      }
    },
    "imageSize": {
      "signature": "int imageSize(gimageBuffer image)",
      "purpose": "retrieve the dimensions of an image",
      "parameters": {
        "image": "<listitem> <para> Specifies the image to which the texture whose dimensions to retrieve is bound. </para> </listitem>"
      }
    },
    "imageStore": {
      "signature": "void imageStore(gimageCubeArray image, ivec3 P, gvec4 data)",
      "purpose": "write a single texel into an image",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store a texel. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the texel. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to store into the image. </para> </listitem>"
      }
    },
    "intBitsToFloat": {
      "signature": "genType intBitsToFloat(genIType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "uintBitsToFloat": {
      "signature": "genType uintBitsToFloat(genUType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "interpolateAtCentroid": {
      "signature": "vec4 interpolateAtCentroid(vec4 interpolant)",
      "purpose": "sample a varying at the centroid of a pixel",
      "parameters": {
        "interpolant": "<listitem> <para> Specifies the interpolant to be sampled at the pixel centroid. </para> </listitem>"
      }
    },
    "interpolateAtOffset": {
      "signature": "vec4 interpolateAtOffset(vec4 interpolant, vec2 offset)",
      "purpose": "sample a varying at specified offset from the center of a pixel",
      "parameters": {
        "interpolant": "<listitem> <para> Specifies the interpolant to be sampled at the specified offset. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset from the center of the pixel at which to sample <parameter>interpolant</parameter>. </para> </listitem>"
      }
    },
    "interpolateAtSample": {
      "signature": "vec4 interpolateAtSample(vec4 interpolant, int sample)",
      "purpose": "sample a varying at the location of a specified sample",
      "parameters": {
        "interpolant": "<listitem> <para> Specifies the interpolant to be sampled at the location of sample <parameter>sample</parameter>. </para> </listitem>",
        "sample": "<listitem> <para> Specifies the index of the sample whose location will be used to sample <parameter>interpolant</parameter>. </para> </listitem>"
      }
    },
    "inverse": {
      "signature": "mat4 inverse(mat4 m)",
      "purpose": "calculate the inverse of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the inverse. </para> </listitem>"
      }
    },
    "inversesqrt": {
      "signature": "genType inversesqrt(genType x)",
      "purpose": "return the inverse of the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the inverse of the square root. </para> </listitem>"
      }
    },
    "isinf": {
      "signature": "genBType isinf(genType x)",
      "purpose": "determine whether the parameter is positive or negative infinity",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for infinity. </para> </listitem>"
      }
    },
    "isnan": {
      "signature": "genBType isnan(genType x)",
      "purpose": "determine whether the parameter is a number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for NaN. </para> </listitem>"
      }
    },
    "ldexp": {
      "signature": "genType ldexp(genType x, genIType exp)",
      "purpose": "assemble a floating point number from a value and exponent",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used as a source of significand. </para> </listitem>",
        "exp": "<listitem> <para> Specifies the value to be used as a source of exponent. </para> </listitem>"
      }
    },
    "length": {
      "signature": "float length(genType x)",
      "purpose": "calculate the length of a vector",
      "parameters": {
        "x": "<listitem> <para> Specifies a vector of which to calculate the length. </para> </listitem>"
      }
    },
    "lessThan": {
      "signature": "bvec lessThan(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "lessThanEqual": {
      "signature": "bvec lessThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "log": {
      "signature": "genType log(genType x)",
      "purpose": "return the natural logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the natural logarithm. </para> </listitem>"
      }
    },
    "log2": {
      "signature": "genType log2(genType x)",
      "purpose": "return the base 2 logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the base 2 logarithm. </para> </listitem>"
      }
    },
    "matrixCompMult": {
      "signature": "mat matrixCompMult(mat x, mat y)",
      "purpose": "perform a component-wise multiplication of two matrices",
      "parameters": {
        "x": "<listitem> <para> Specifies the first matrix multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second matrix multiplicand. </para> </listitem>"
      }
    },
    "max": {
      "signature": "genUType max(genUType x, uint y)",
      "purpose": "return the greater of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "memoryBarrier": {
      "signature": "void memoryBarrier(void)",
      "purpose": "controls the ordering of memory transactions issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierAtomicCounter": {
      "signature": "void memoryBarrierAtomicCounter(void)",
      "purpose": "controls the ordering of operations on atomic counters issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierBuffer": {
      "signature": "void memoryBarrierBuffer(void)",
      "purpose": "controls the ordering of operations on buffer variables issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierImage": {
      "signature": "void memoryBarrierImage(void)",
      "purpose": "controls the ordering of operations on image variables issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierShared": {
      "signature": "void memoryBarrierShared(void)",
      "purpose": "controls the ordering of operations on shared variables issued by a single shader invocation",
      "parameters": {}
    },
    "min": {
      "signature": "genUType min(genUType x, uint y)",
      "purpose": "return the lesser of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "mix": {
      "signature": "genType mix(genType x, genType y, genBType a)",
      "purpose": "linearly interpolate between two values",
      "parameters": {
        "x": "<listitem> <para> Specify the start of the range in which to interpolate. </para> </listitem>",
        "y": "<listitem> <para> Specify the end of the range in which to interpolate. </para> </listitem>",
        "a": "<listitem> <para> Specify the value to use to interpolate between <parameter>x</parameter> and <parameter>y</parameter>. </para> </listitem>"
      }
    },
    "mod": {
      "signature": "genType mod(genType x, genType y)",
      "purpose": "compute value of one parameter modulo another",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>",
        "y": "<listitem> <para> Specify the value by which to perform the modulo. </para> </listitem>"
      }
    },
    "modf": {
      "signature": "genType modf(genType x, out genType i)",
      "purpose": "separate a value into its integer and fractional components",
      "parameters": {
        "x": "<listitem> <para> Specify the value to separate. </para> </listitem>",
        "out i": "<listitem> <para> A variable that receives the integer part of the argument. </para> </listitem>"
      }
    },
    "normalize": {
      "signature": "genType normalize(genType v)",
      "purpose": "calculates the unit vector in the same direction as the original vector",
      "parameters": {
        "v": "<listitem> <para> Specifies the vector to normalize. </para> </listitem>"
      }
    },
    "not": {
      "signature": "bvec not(bvec x)",
      "purpose": "logically invert a boolean vector",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be inverted. </para> </listitem>"
      }
    },
    "notEqual": {
      "signature": "bvec notEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise not-equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "outerProduct": {
      "signature": "mat4x3 outerProduct(vec3 c, vec4 r)",
      "purpose": "calculate the outer product of a pair of vectors",
      "parameters": {
        "c": "<listitem> <para> Specifies the parameter to be treated as a column vector. </para> </listitem>",
        "r": "<listitem> <para> Specifies the parameter to be treated as a row vector. </para> </listitem>"
      }
    },
    "packHalf2x16": {
      "signature": "uint packHalf2x16(vec2 v)",
      "purpose": "convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer",
      "parameters": {
        "v": "<listitem> <para> Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result. </para> </listitem>"
      }
    },
    "packUnorm2x16": {
      "signature": "uint packUnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm2x16": {
      "signature": "uint packSnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packUnorm4x8": {
      "signature": "uint packUnorm4x8(vec4 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm4x8": {
      "signature": "uint packSnorm4x8(vec4 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "pow": {
      "signature": "genType pow(genType x, genType y)",
      "purpose": "return the value of the first parameter raised to the power of the second",
      "parameters": {
        "x": "<listitem> <para> Specify the value to raise to the power <parameter>y</parameter>. </para> </listitem>",
        "y": "<listitem> <para> Specify the power to which to raise <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "radians": {
      "signature": "genType radians(genType degrees)",
      "purpose": "convert a quantity in degrees to radians",
      "parameters": {
        "degrees": "<listitem> <para> Specify the quantity, in degrees, to be converted to radians. </para> </listitem>"
      }
    },
    "reflect": {
      "signature": "genType reflect(genType I, genType N)",
      "purpose": "calculate the reflection direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>"
      }
    },
    "refract": {
      "signature": "genType refract(genType I, genType N, float eta)",
      "purpose": "calculate the refraction direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>",
        "eta": "<listitem> <para> Specifies the ratio of indices of refraction. </para> </listitem>"
      }
    },
    "round": {
      "signature": "genType round(genType x)",
      "purpose": "find the nearest integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "roundEven": {
      "signature": "genType roundEven(genType x)",
      "purpose": "find the nearest even integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "sign": {
      "signature": "genIType sign(genIType x)",
      "purpose": "extract the sign of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value from which to extract the sign. </para> </listitem>"
      }
    },
    "sin": {
      "signature": "genType sin(genType angle)",
      "purpose": "return the sine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the sine. </para> </listitem>"
      }
    },
    "sinh": {
      "signature": "genType sinh(genType x)",
      "purpose": "return the hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic sine to return. </para> </listitem>"
      }
    },
    "smoothstep": {
      "signature": "genType smoothstep(float edge0, float edge1, genType x)",
      "purpose": "perform Hermite interpolation between two values",
      "parameters": {
        "edge0": "<listitem> <para> Specifies the value of the lower edge of the Hermite function. </para> </listitem>",
        "edge1": "<listitem> <para> Specifies the value of the upper edge of the Hermite function. </para> </listitem>",
        "x": "<listitem> <para> Specifies the source value for interpolation. </para> </listitem>"
      }
    },
    "sqrt": {
      "signature": "genType sqrt(genType x)",
      "purpose": "return the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the square root. </para> </listitem>"
      }
    },
    "step": {
      "signature": "genType step(float edge, genType x)",
      "purpose": "generate a step function by comparing two values",
      "parameters": {
        "edge": "<listitem> <para> Specifies the location of the edge of the step function. </para> </listitem>",
        "x": "<listitem> <para> Specify the value to be used to generate the step function. </para> </listitem>"
      }
    },
    "tan": {
      "signature": "genType tan(genType angle)",
      "purpose": "return the tangent of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the tangent. </para> </listitem>"
      }
    },
    "tanh": {
      "signature": "genType tanh(genType x)",
      "purpose": "return the hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "texelFetch": {
      "signature": "gvec4 texelFetch(gsamplerBuffer sampler, int P)",
      "purpose": "perform a lookup of a single texel within a texture",
      "parameters": {
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "sample": "<listitem> <para> For multisampled fetches, specifies which sample within the texel from which the data will be returned. </para> </listitem>"
      }
    },
    "texelFetchOffset": {
      "signature": "gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)",
      "purpose": "perform a lookup of a single texel within a texture with an offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>"
      }
    },
    "texture": {
      "signature": "float texture(samplerCubeArrayShadow sampler, vec4 P, float compare)",
      "purpose": "retrieves texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>",
        "compare": "<listitem> <para> When present, specifies the reference for shadow comparisons. </para> </listitem>"
      }
    },
    "textureGather": {
      "signature": "vec4 textureGather(samplerCubeArrayShadow sampler, vec4 P, float refZ)",
      "purpose": "gathers four texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>"
      }
    },
    "textureGatherOffset": {
      "signature": "vec4 textureGatherOffset(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset)",
      "purpose": "gathers four texels from a texture with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset from the specified texture coordinate <parameter>P</parameter> from which the texels will be gathered. </para> </listitem>"
      }
    },
    "textureGatherOffsets": {
      "signature": "vec4 textureGatherOffsets(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offsets[4])",
      "purpose": "gathers four texels from a texture with an array of offsets",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>",
        "offsets": "<listitem> <para> Specifies an array of offsets from the specified texture coordinate <parameter>P</parameter> from which the texels will be gathered. </para> </listitem>"
      }
    },
    "textureGrad": {
      "signature": "gvec4 textureGrad(gsamplerCubeArray sampler, vec4 P, vec3 dPdx, vec3 dPdy)",
      "purpose": "perform a texture lookup with explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureGradOffset": {
      "signature": "float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset to be applied to the texture coordinates before sampling. </para> </listitem>"
      }
    },
    "textureLod": {
      "signature": "gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod)",
      "purpose": "perform a texture lookup with explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail </para> </listitem>"
      }
    },
    "textureLodOffset": {
      "signature": "gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which texels will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that will be applied to <parameter>P</parameter> before texels are fetched. </para> </listitem>"
      }
    },
    "textureOffset": {
      "signature": "gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias)",
      "purpose": "perform a texture lookup with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProj": {
      "signature": "float textureProj(sampler2DShadow sampler, vec4 P, [float bias)",
      "purpose": "perform a texture lookup with projection",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProjGrad": {
      "signature": "float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
      "purpose": "perform a texture lookup with projection and explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureProjGradOffset": {
      "signature": "float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with projection, explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offsets, in texels at which the texture will be sampled relative to the projection of <parameter>P</parameter>. </para> </listitem>"
      }
    },
    "textureProjLod": {
      "signature": "float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>"
      }
    },
    "textureProjLodOffset": {
      "signature": "float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset, in texels, to be applied to <parameter>P</parameter> before fetching texels. </para> </listitem>"
      }
    },
    "textureProjOffset": {
      "signature": "float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias)",
      "purpose": "perform a texture lookup with projection and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that is applied to <parameter>P</parameter> before sampling occurs. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureSize": {
      "signature": "int textureSize(gsamplerBuffer sampler)",
      "purpose": "retrieve the dimensions of a level of a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture whose dimensions to retrieve is bound. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the level of the texture for which to retrieve the dimensions. </para> </listitem>"
      }
    },
    "transpose": {
      "signature": "mat4x3 transpose(mat3x4 m)",
      "purpose": "calculate the transpose of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the transpose. </para> </listitem>"
      }
    },
    "trunc": {
      "signature": "genType trunc(genType x)",
      "purpose": "find the truncated value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "uaddCarry": {
      "signature": "genUType uaddCarry(genUType x, genUType y, out genUType carry)",
      "purpose": "add unsigned integers and generate carry",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the summation operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the summation operation. </para> </listitem>",
        "carry": "<listitem> <para> Specifies the variable to receive the carry output of the sum. </para> </listitem>"
      }
    },
    "umulExtended": {
      "signature": "void umulExtended(genUType x, genUType y, out genUType msb, out genUType lsb)",
      "purpose": "perform a 32- by 32-bit multiply to produce a 64-bit result",
      "parameters": {
        "x": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second multiplicand.. </para> </listitem>",
        "msb": "<listitem> <para> Specifies the variable to receive the most significant word of the product. </para> </listitem>",
        "lsb": "<listitem> <para> Specifies the variable to receive the least significant word of the product. </para> </listitem>"
      }
    },
    "imulExtended": {
      "signature": "void imulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)",
      "purpose": "perform a 32- by 32-bit multiply to produce a 64-bit result",
      "parameters": {
        "x": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second multiplicand.. </para> </listitem>",
        "msb": "<listitem> <para> Specifies the variable to receive the most significant word of the product. </para> </listitem>",
        "lsb": "<listitem> <para> Specifies the variable to receive the least significant word of the product. </para> </listitem>"
      }
    },
    "unpackHalf2x16": {
      "signature": "vec2 unpackHalf2x16(uint v)",
      "purpose": "convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities",
      "parameters": {
        "v": "<listitem> <para> Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked. </para> </listitem>"
      }
    },
    "unpackUnorm2x16": {
      "signature": "vec2 unpackUnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm2x16": {
      "signature": "vec2 unpackSnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackUnorm4x8": {
      "signature": "vec2 unpackUnorm4x8(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm4x8": {
      "signature": "vec2 unpackSnorm4x8(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "usubBorrow": {
      "signature": "genUType usubBorrow(genUType x, genUType y, out genUType borrow)",
      "purpose": "subtract unsigned integers and generate borrow",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the subtraction operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the subtraction operation. </para> </listitem>",
        "borrow": "<listitem> <para> Specifies the variable to receive the borrow output of the difference. </para> </listitem>"
      }
    }
  },
  "es3.0": {
    "abs": {
      "signature": "genIType abs(genIType x)",
      "purpose": "return the absolute value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to return the absolute. </para> </listitem>"
      }
    },
    "acos": {
      "signature": "genType acos(genType x)",
      "purpose": "return the arccosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arccosine to return. </para> </listitem>"
      }
    },
    "acosh": {
      "signature": "genType acosh(genType x)",
      "purpose": "return the arc hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "all": {
      "signature": "bool all(bvec x)",
      "purpose": "check whether all elements of a boolean vector are true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "any": {
      "signature": "bool any(bvec x)",
      "purpose": "check whether any element of a boolean vector is true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "asin": {
      "signature": "genType asin(genType x)",
      "purpose": "return the arcsine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arcsine to return. </para> </listitem>"
      }
    },
    "asinh": {
      "signature": "genType asinh(genType x)",
      "purpose": "return the arc hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic sine to return. </para> </listitem>"
      }
    },
    "atan": {
      "signature": "genType atan(genType y_over_x)",
      "purpose": "return the arc-tangent of the parameters",
      "parameters": {
        "y": "<listitem> <para> Specify the numerator of the fraction whose arctangent to return. </para> </listitem>",
        "x": "<listitem> <para> Specify the denominator of the fraction whose arctangent to return. </para> </listitem>",
        "y_over_x": "<listitem> <para> Specify the fraction whose arctangent to return. </para> </listitem>"
      }
    },
    "atanh": {
      "signature": "genType atanh(genType x)",
      "purpose": "return the arc hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "ceil": {
      "signature": "genType ceil(genType x)",
      "purpose": "find the nearest integer that is greater than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "clamp": {
      "signature": "genUType clamp(genUType x, uint minVal, uint maxVal)",
      "purpose": "constrain a value to lie between two further values",
      "parameters": {
        "x": "<listitem> <para> Specify the value to constrain. </para> </listitem>",
        "minVal": "<listitem> <para> Specify the lower end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>",
        "maxVal": "<listitem> <para> Specify the upper end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "cos": {
      "signature": "genType cos(genType angle)",
      "purpose": "return the cosine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the cosine. </para> </listitem>"
      }
    },
    "cosh": {
      "signature": "genType cosh(genType x)",
      "purpose": "return the hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "cross": {
      "signature": "vec3 cross(vec3 x, vec3 y)",
      "purpose": "calculate the cross product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "degrees": {
      "signature": "genType degrees(genType radians)",
      "purpose": "convert a quantity in radians to degrees",
      "parameters": {
        "radians": "<listitem> <para> Specify the quantity, in radians, to be converted to degrees. </para> </listitem>"
      }
    },
    "determinant": {
      "signature": "float determinant(mat4 m)",
      "purpose": "calculate the determinant of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the determinant. </para> </listitem>"
      }
    },
    "dFdx": {
      "signature": "genType dFdx(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdy": {
      "signature": "genType dFdy(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "distance": {
      "signature": "float distance(genType p0, genType p1)",
      "purpose": "calculate the distance between two points",
      "parameters": {
        "p0": "<listitem> <para> Specifies the first of two points </para> </listitem>",
        "p1": "<listitem> <para> Specifies the second of two points </para> </listitem>"
      }
    },
    "dot": {
      "signature": "float dot(genType x, genType y)",
      "purpose": "calculate the dot product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "equal": {
      "signature": "bvec equal(uvec x, uvec y)",
      "purpose": "perform a component-wise equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "exp": {
      "signature": "genType exp(genType x)",
      "purpose": "return the natural exponentiation of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to exponentiate. </para> </listitem>"
      }
    },
    "exp2": {
      "signature": "genType exp2(genType x)",
      "purpose": "return 2 raised to the power of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of the power to which 2 will be raised. </para> </listitem>"
      }
    },
    "faceforward": {
      "signature": "genType faceforward(genType N, genType I, genType Nref)",
      "purpose": "return a vector pointing in the same direction as another",
      "parameters": {
        "N": "<listitem> <para> Specifies the vector to orient. </para> </listitem>",
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "Nref": "<listitem> <para> Specifies the reference vector. </para> </listitem>"
      }
    },
    "floatBitsToInt": {
      "signature": "genIType floatBitsToInt(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floatBitsToUint": {
      "signature": "genUType floatBitsToUint(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floor": {
      "signature": "genType floor(genType x)",
      "purpose": "find the nearest integer less than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "fract": {
      "signature": "genType fract(genType x)",
      "purpose": "compute the fractional part of the argument",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "fwidth": {
      "signature": "genType fwidth(genType p)",
      "purpose": "return the sum of the absolute derivatives in x and y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation-dependent, but must be at least 32. <parameter>texture</parameter> must be one of `GL_TEXTURE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAttachShader": {
      "signature": "void glAttachShader(GLuint program, GLuint shader)",
      "purpose": "Attaches a shader object to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
      }
    },
    "glBeginQuery": {
      "signature": "void glBeginQuery(GLenum target, GLuint id)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glEndQuery": {
      "signature": "void glEndQuery(GLenum target)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glBeginTransformFeedback": {
      "signature": "void glBeginTransformFeedback(GLenum primitiveMode)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glEndTransformFeedback": {
      "signature": "void glEndTransformFeedback(void)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glBindAttribLocation": {
      "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
      "purpose": "Associates a generic vertex attribute index with a named attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
        "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
      }
    },
    "glBindBufferBase": {
      "signature": "void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)",
      "purpose": "bind a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be either `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>"
      }
    },
    "glBindBufferRange": {
      "signature": "void glBindBufferRange(GLenumtarget, GLuintindex, GLuintbuffer, GLintptroffset, GLsizeiptrsize)",
      "purpose": "bind a range within a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be either `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>",
        "offset": "<listitem> <para> The starting offset in basic machine units into the buffer object <parameter>buffer</parameter>. </para> </listitem>",
        "size": "<listitem> <para> The amount of data in machine units that can be read from the buffet object while used as an indexed target. </para> </listitem>"
      }
    },
    "glBindFramebuffer": {
      "signature": "void glBindFramebuffer(GLenum target, GLuint framebuffer)",
      "purpose": "bind a framebuffer to a framebuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target of the binding operation. </para> </listitem>",
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object to bind. </para> </listitem>"
      }
    },
    "glBindRenderbuffer": {
      "signature": "void glBindRenderbuffer(GLenum target, GLuint renderbuffer)",
      "purpose": "bind a renderbuffer to a renderbuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the renderbuffer target of the binding operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of the renderbuffer object to bind. </para> </listitem>"
      }
    },
    "glBindSampler": {
      "signature": "void glBindSampler(GLuint unit, GLuint sampler)",
      "purpose": "bind a named sampler to a texturing target",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the texture unit to which the sampler is bound. </para> </listitem>",
        "sampler": "<listitem> <para> Specifies the name of a sampler. </para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound. Must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`, </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBindTransformFeedback": {
      "signature": "void glBindTransformFeedback(GLenum target, GLuint id)",
      "purpose": "bind a transform feedback object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which to bind the transform feedback object <parameter>id</parameter>. <parameter>target</parameter> must be `GL_TRANSFORM_FEEDBACK`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object reserved by <citerefentry><refentrytitle>glGenTransformFeedbacks</refentrytitle></citerefentry>. </para> </listitem>"
      }
    },
    "glBindVertexArray": {
      "signature": "void glBindVertexArray(GLuint array)",
      "purpose": "bind a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies the name of the vertex array to bind. </para> </listitem>"
      }
    },
    "glBlendColor": {
      "signature": "void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "set the blend color",
      "parameters": {
        "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
      }
    },
    "glBlendEquation": {
      "signature": "void glBlendEquation(GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparate": {
      "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparate": {
      "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlitFramebuffer": {
      "signature": "void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)",
      "purpose": "copy a block of pixels from the read framebuffer to the draw framebuffer",
      "parameters": {
        "srcX0": "<listitem> <para> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </para> </listitem>",
        "dstX0": "<listitem> <para> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </para> </listitem>",
        "mask": "<listitem> <para> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>",
        "filter": "<listitem> <para> Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`. </para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the buffer object's new data store. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied. </para> </listitem>",
        "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`. </para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "updates a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glCheckFramebufferStatus": {
      "signature": "GLenum glCheckFramebufferStatus(GLenum target)",
      "purpose": "check the completeness status of a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the framebuffer completeness check. </para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
      }
    },
    "glClearBufferiv": {
      "signature": "void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferuiv": {
      "signature": "void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfv": {
      "signature": "void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfi": {
      "signature": "void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "specify clear values for the color buffers",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearDepthf": {
      "signature": "void glClearDepthf(GLfloat depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glClientWaitSync": {
      "signature": "GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "block and wait for a sync object to become signaled",
      "parameters": {
        "sync": "<listitem> <para> The sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> may be `GL_SYNC_FLUSH_COMMANDS_BIT`. </para> </listitem>",
        "timeout": "<listitem> <para> The timeout, specified in nanoseconds, for which the implementation should wait for <parameter>sync</parameter> to become signaled. </para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
      }
    },
    "glCompileShader": {
      "signature": "void glCompileShader(GLuint shader)",
      "purpose": "Compiles a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage3D": {
      "signature": "void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage3D": {
      "signature": "void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCopyBufferSubData": {
      "signature": "void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)",
      "purpose": "copy part of the data store of a buffer object to the data store of another buffer object",
      "parameters": {
        "readtarget": "<listitem> <para> Specifies the target from whose data store data should be read. </para> </listitem>",
        "writetarget": "<listitem> <para> Specifies the target to whose data store data should be written. </para> </listitem>",
        "readoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>readtarget</parameter> from which data should be read. </para> </listitem>",
        "writeoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>writetarget</parameter> to which data should be written. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size, in basic machine units, of the data to be copied from <parameter>readtarget</parameter> to <parameter>writetarget</parameter>. </para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "copy pixels into a 2D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_R8`, `GL_RG8`, `GL_RGB565`, `GL_RGB8`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_SRGB8`, `GL_SRGB8_ALPHA8`, `GL_R8I`, `GL_R8UI`, `GL_R16I`, `GL_R16UI`, `GL_R32I`, `GL_R32UI`, `GL_RG8I`, `GL_RG8UI`, `GL_RG16I`, `GL_RG16UI`, `GL_RG32I`, `GL_RG32UI`, `GL_RGBA8I`, `GL_RGBA8UI`, `GL_RGB10_A2UI`, `GL_RGBA16I`, `GL_RGBA16UI`, `GL_RGBA32I`, `GL_RGBA32UI`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCopyTexSubImage3D": {
      "signature": "void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCreateProgram": {
      "signature": "GLuint glCreateProgram(void)",
      "purpose": "Creates a program object",
      "parameters": {}
    },
    "glCreateShader": {
      "signature": "GLuint glCreateShader(GLenum shaderType)",
      "purpose": "Creates a shader object",
      "parameters": {
        "shaderType": "<listitem> <para>Specifies the type of shader to be created. Must be one of `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.</para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing polygons can be culled",
      "parameters": {
        "mode": "<listitem> <para> Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteFramebuffers": {
      "signature": "void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "delete framebuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer objects to be deleted. </para> </listitem>",
        "framebuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> framebuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteProgram": {
      "signature": "void glDeleteProgram(GLuint program)",
      "purpose": "Deletes a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteQueries": {
      "signature": "void glDeleteQueries(GLsizei n, const GLuint * ids)",
      "purpose": "delete named query objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query objects to be deleted. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of query objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteRenderbuffers": {
      "signature": "void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "delete renderbuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer objects to be deleted. </para> </listitem>",
        "renderbuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> renderbuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteSamplers": {
      "signature": "void glDeleteSamplers(GLsizei n, const GLuint * samplers)",
      "purpose": "delete named sampler objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler objects to be deleted. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array of sampler objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteShader": {
      "signature": "void glDeleteShader(GLuint shader)",
      "purpose": "Deletes a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteSync": {
      "signature": "void glDeleteSync(GLsync sync)",
      "purpose": "delete a sync object",
      "parameters": {
        "sync": "<listitem> <para> The sync object to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTransformFeedbacks": {
      "signature": "void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)",
      "purpose": "delete transform feedback objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback objects to delete. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of names of transform feedback objects to delete. </para> </listitem>"
      }
    },
    "glDeleteVertexArrays": {
      "signature": "void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)",
      "purpose": "delete vertex array objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array objects to be deleted. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies the address of an array containing the <parameter>n</parameter> names of the objects to be deleted. </para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
      }
    },
    "glDepthRangef": {
      "signature": "void glDepthRangef(GLfloat n, GLfloat f)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "n": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "f": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDetachShader": {
      "signature": "void glDetachShader(GLuint program, GLuint shader)",
      "purpose": "Detaches a shader object from a program object to which it is attached",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawArraysInstanced": {
      "signature": "void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount)",
      "purpose": "draw multiple instances of a range of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawBuffers": {
      "signature": "void glDrawBuffers(GLsizei n, const GLenum *bufs)",
      "purpose": "Specifies a list of color buffers to be drawn into",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
        "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawElementsInstanced": {
      "signature": "void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)",
      "purpose": "draw multiple instances of a set of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawRangeElements": {
      "signature": "void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnableVertexAttribArray": {
      "signature": "void glEnableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexAttribArray": {
      "signature": "void glDisableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glFenceSync": {
      "signature": "GLsync glFenceSync(GLenum condition, GLbitfield flags)",
      "purpose": "create a new sync object and insert it into the GL command stream",
      "parameters": {
        "condition": "<listitem> <para> Specifies the condition that must be met to set the sync object's state to signaled. <parameter>condition</parameter> must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. </para> </listitem>",
        "flags": "<listitem> <para> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and <parameter>flags</parameter> must be zero.<footnote><para> <parameter>flags</parameter> is a placeholder for anticipated future extensions of fence sync object capabilities. </para> </footnote> </para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish( void)",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush( void)",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFlushMappedBufferRange": {
      "signature": "void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)",
      "purpose": "indicate modifications to a range of a mapped buffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the flush operation. <parameter>target</parameter> must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the start of the buffer subrange, in basic machine units. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the buffer subrange, in basic machine units. </para> </listitem>"
      }
    },
    "glFramebufferRenderbuffer": {
      "signature": "void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
      "purpose": "attach a renderbuffer as a logical buffer to the currently bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "renderbuffertarget": "<listitem> <para> Specifies the renderbuffer target and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of an existing renderbuffer object of type <parameter>renderbuffertarget</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture2D": {
      "signature": "void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer to the currently bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. </para> </listitem>",
        "textarget": "<listitem> <para> Specifies a 2D texture target, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTextureLayer": {
      "signature": "void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)",
      "purpose": "attach a single layer of a texture to a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMMENT`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>",
        "layer": "<listitem> <para> Specifies the layer of <parameter>texture</parameter> to attach. </para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
      }
    },
    "glGenerateMipmap": {
      "signature": "void glGenerateMipmap(GLenum target)",
      "purpose": "generate mipmaps for a specified texture target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture whose mimaps to generate is bound. <parameter>target</parameter> must be `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>"
      }
    },
    "glGenFramebuffers": {
      "signature": "void glGenFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "generate framebuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer object names to generate. </para> </listitem>",
        "framebuffers": "<listitem> <para> Specifies an array in which the generated framebuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenQueries": {
      "signature": "void glGenQueries(GLsizei n, GLuint * ids)",
      "purpose": "generate query object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query object names to be generated. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which the generated query object names are stored. </para> </listitem>"
      }
    },
    "glGenRenderbuffers": {
      "signature": "void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "generate renderbuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer object names to generate. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array in which the generated renderbuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenSamplers": {
      "signature": "void glGenSamplers(GLsizei n, GLuint *samplers)",
      "purpose": "generate sampler object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler object names to generate. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array in which the generated sampler object names are stored. </para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
      }
    },
    "glGenTransformFeedbacks": {
      "signature": "void glGenTransformFeedbacks(GLsizei n, GLuint *ids)",
      "purpose": "reserve transform feedback object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback object names to reserve. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenVertexArrays": {
      "signature": "void glGenVertexArrays(GLsizei n, GLuint *arrays)",
      "purpose": "generate vertex array object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array object names to generate. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies an array in which the generated vertex array object names are stored. </para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64v": {
      "signature": "void glGetInteger64v(GLenum pname, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegeri_v": {
      "signature": "void glGetIntegeri_v(GLenum target, GLuint index, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64i_v": {
      "signature": "void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetActiveAttrib": {
      "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active attribute variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
      }
    },
    "glGetActiveUniform": {
      "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active uniform variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
      }
    },
    "glGetActiveUniformBlockiv": {
      "signature": "void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)",
      "purpose": "query information about an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable to receive the result of the query. </para> </listitem>"
      }
    },
    "glGetActiveUniformBlockName": {
      "signature": "void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)",
      "purpose": "retrieve the name of an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer addressed by <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of characters that were written to <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters to receive the name of the uniform block at <parameter>uniformBlockIndex</parameter>. </para> </listitem>"
      }
    },
    "glGetActiveUniformsiv": {
      "signature": "void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)",
      "purpose": "Returns information about several active uniform variables for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "uniformCount": "<listitem> <para>Specifies both the number of elements in the array of indices <parameter>uniformIndices</parameter> and the number of parameters written to <parameter>params</parameter> upon successful return.</para> </listitem>",
        "uniformIndices": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers containing the indices of uniforms within <parameter>program</parameter> whose parameter <parameter>pname</parameter> should be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the property of each uniform in <parameter>uniformIndices</parameter> that should be written into the corresponding element of <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers which are to receive the value of <parameter>pname</parameter> for each uniform in <parameter>uniformIndices</parameter>.</para> </listitem>"
      }
    },
    "glGetAttachedShaders": {
      "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
      "purpose": "Returns the handles of the shader objects attached to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
        "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
      }
    },
    "glGetAttribLocation": {
      "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of an attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferParameteri64v": {
      "signature": "void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferPointerv": {
      "signature": "void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)",
      "purpose": "return the pointer to a mapped buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the pointer to be returned. The symbolic constant must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError( void)",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetFragDataLocation": {
      "signature": "GLint glGetFragDataLocation(GLuint program, const char * name)",
      "purpose": "query the bindings of color numbers to user-defined varying out variables",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to query </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to query </para> </listitem>"
      }
    },
    "glGetFramebufferAttachmentParameteriv": {
      "signature": "void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)",
      "purpose": "retrieve information about attachments of a bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the query operation. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment within <parameter>target</parameter> </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of <parameter>attachment</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable receive the value of <parameter>pname</parameter> for <parameter>attachment</parameter>. </para> </listitem>"
      }
    },
    "glGetInternalformativ": {
      "signature": "void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)",
      "purpose": "retrieve information about implementation-dependent support for internal formats",
      "parameters": {
        "target": "<listitem> <para> Indicates the usage of the internal format. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format about which to retrieve information. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the type of information to query. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of integers that may be written to <parameter>params</parameter> by the function. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
      }
    },
    "glGetProgramBinary": {
      "signature": "void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary)",
      "purpose": "return a binary representation of a program object's compiled and linked executable source",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose binary representation to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given by <parameter>binary</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of bytes written into <parameter>binary</parameter>. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address an array into which the GL will return <parameter>program</parameter>'s binary representation. </para> </listitem>"
      }
    },
    "glGetProgramInfoLog": {
      "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetProgramiv": {
      "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_DELETE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_LINK_STATUS`, `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH` and `GL_VALIDATE_STATUS`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetQueryiv": {
      "signature": "void glGetQueryiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object target",
      "parameters": {
        "target": "<listitem> <para> Specifies a query object target. Must be `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Must be `GL_CURRENT_QUERY`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryObjectuiv": {
      "signature": "void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT` or `GL_QUERY_RESULT_AVAILABLE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetRenderbufferParameteriv": {
      "signature": "void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)",
      "purpose": "retrieve information about a bound renderbuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the query operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the renderbuffer bound to <parameter>target</parameter>. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of an array to receive the value of the queried parameter. </para> </listitem>"
      }
    },
    "glGetSamplerParameterfv": {
      "signature": "void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameteriv": {
      "signature": "void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetShaderInfoLog": {
      "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetShaderiv": {
      "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetShaderPrecisionFormat": {
      "signature": "void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)",
      "purpose": "retrieve the range and precision for numeric formats supported by the shader compiler",
      "parameters": {
        "shaderType": "<listitem> <para> Specifies the type of shader whose precision to query. <parameter>shaderType</parameter> must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "precisionType": "<listitem> <para> Specifies the numeric format whose precision and range to query. </para> </listitem>",
        "range": "<listitem> <para> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </para> </listitem>",
        "precision": "<listitem> <para> Specifies the address of an integer into which the numeric precision of the implementation is written. </para> </listitem>"
      }
    },
    "glGetShaderSource": {
      "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
      "purpose": "Returns the source code string from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
        "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte* glGetString(GLenum name)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetStringi": {
      "signature": "const GLubyte* glGetStringi(GLenum name, GLuint index)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetSynciv": {
      "signature": "void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)",
      "purpose": "query the properties of a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose properties to query. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the sync object specified in <parameter>sync</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>values</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of an variable to receive the number of integers placed in <parameter>values</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array to receive the values of the queried parameter. </para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTransformFeedbackVarying": {
      "signature": "void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name)",
      "purpose": "retrieve information about varying variables selected for transform feedback",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "index": "<listitem> <para> The index of the varying variable whose information to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The maximum number of characters, including the null terminator, that may be written into <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the number of characters written into <parameter>name</parameter>, excluding the null-terminator. If <parameter>length</parameter> is `NULL` no length is returned. </para> </listitem>",
        "size": "<listitem> <para> The address of a variable that will receive the size of the varying. </para> </listitem>",
        "type": "<listitem> <para> The address of a variable that will receive the type of the varying. </para> </listitem>",
        "name": "<listitem> <para> The address of a buffer into which will be written the name of the varying. </para> </listitem>"
      }
    },
    "glGetUniformfv": {
      "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformiv": {
      "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformuiv": {
      "signature": "void glGetUniformuiv(GLuint program, GLint location, GLuint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformBlockIndex": {
      "signature": "GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters containing the name of the uniform block whose index to retrieve. </para> </listitem>"
      }
    },
    "glGetUniformIndices": {
      "signature": "void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing uniforms whose indices to query. </para> </listitem>",
        "uniformCount": "<listitem> <para> Specifies the number of uniforms whose indices to query. </para> </listitem>",
        "uniformNames": "<listitem> <para> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </para> </listitem>",
        "uniformIndices": "<listitem> <para> Specifies the address of an array that will receive the indices of the uniforms. </para> </listitem>"
      }
    },
    "glGetUniformLocation": {
      "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetVertexAttribfv": {
      "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribiv": {
      "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIiv": {
      "signature": "void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIuiv": {
      "signature": "void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribPointerv": {
      "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
      "purpose": "return the address of the specified generic vertex attribute pointer",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
        "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_FRAGMENT_SHADER_DERIVATIVE_HINT`, and `GL_GENERATE_MIPMAP_HINT` are accepted. </para> </listitem>",
        "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
      }
    },
    "glInvalidateFramebuffer": {
      "signature": "void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)",
      "purpose": "Invalidate the contents of attachments within a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
        "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>"
      }
    },
    "glInvalidateSubFramebuffer": {
      "signature": "void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLintx, GLinty, GLsizei width, GLsizei height)",
      "purpose": "Invalidate portions of the contents of attachments within a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
        "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>",
        "x": "<listitem> <para> Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
        "y": "<listitem> <para> Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the pixel rectangle to invalidate. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the pixel rectangle to invalidate. </para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
      }
    },
    "glIsFramebuffer": {
      "signature": "GLboolean glIsFramebuffer(GLuint framebuffer)",
      "purpose": "determine if a name corresponds to a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies a value that may be the name of a framebuffer object. </para> </listitem>"
      }
    },
    "glIsProgram": {
      "signature": "GLboolean glIsProgram(GLuint program)",
      "purpose": "Determines if a name corresponds to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
      }
    },
    "glIsQuery": {
      "signature": "GLboolean glIsQuery(GLuint id)",
      "purpose": "determine if a name corresponds to a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a query object. </para> </listitem>"
      }
    },
    "glIsRenderbuffer": {
      "signature": "GLboolean glIsRenderbuffer(GLuint renderbuffer)",
      "purpose": "determine if a name corresponds to a renderbuffer object",
      "parameters": {
        "renderbuffer": "<listitem> <para> Specifies a value that may be the name of a renderbuffer object. </para> </listitem>"
      }
    },
    "glIsSampler": {
      "signature": "GLboolean glIsSampler(GLuint id)",
      "purpose": "determine if a name corresponds to a sampler object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a sampler object. </para> </listitem>"
      }
    },
    "glIsShader": {
      "signature": "GLboolean glIsShader(GLuint shader)",
      "purpose": "Determines if a name corresponds to a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
      }
    },
    "glIsSync": {
      "signature": "GLboolean glIsSync(GLsync sync)",
      "purpose": "determine if a name corresponds to a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies a value that may be the name of a sync object. </para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glIsTransformFeedback": {
      "signature": "GLboolean glIsTransformFeedback(GLuint id)",
      "purpose": "determine if a name corresponds to a transform feedback object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a transform feedback object. </para> </listitem>"
      }
    },
    "glIsVertexArray": {
      "signature": "GLboolean glIsVertexArray(GLuint array)",
      "purpose": "determine if a name corresponds to a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies a value that may be the name of a vertex array object. </para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
      }
    },
    "glLinkProgram": {
      "signature": "void glLinkProgram(GLuint program)",
      "purpose": "Links a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
      }
    },
    "glMapBufferRange": {
      "signature": "void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)",
      "purpose": "map a section of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target buffer is bound. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
      }
    },
    "glUnmapBuffer": {
      "signature": "GLboolean glUnmapBuffer(GLenum target)",
      "purpose": "map a section of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target buffer is bound. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
      }
    },
    "glPauseTransformFeedback": {
      "signature": "void glPauseTransformFeedback(void)",
      "purpose": "pause transform feedback operations",
      "parameters": {}
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Four values affect the packing of pixel data into memory: `GL_PACK_ROW_LENGTH`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth values",
      "parameters": {
        "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
        "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
      }
    },
    "glProgramBinary": {
      "signature": "void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load a program object with a program binary",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object into which to load a program binary. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the binary data in binary. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array containing the binary to be loaded into <parameter>program</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the number of bytes contained in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glProgramParameteri": {
      "signature": "void glProgramParameteri(GLuint program, GLenum pname, GLint value)",
      "purpose": "specify a parameter for a program object",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to modify. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value of the parameter specified by <parameter>pname</parameter> for <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glReadBuffer": {
      "signature": "void glReadBuffer(GLenum src)",
      "purpose": "select a color buffer source for pixels",
      "parameters": {
        "src": "<listitem> <para> Specifies a color buffer. Accepted values are `GL_BACK`, `GL_NONE`, and `GL_COLOR_ATTACHMENTi`. </para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RGBA`, and `GL_RGBA_INTEGER`. An implementation-chosen format will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_FORMAT`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_INT`, `GL_INT`, or `GL_FLOAT`. An implementation-chosen type will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_TYPE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
      }
    },
    "glReleaseShaderCompiler": {
      "signature": "void glReleaseShaderCompiler(void)",
      "purpose": "release resources consumed by the implementation's shader compiler",
      "parameters": {}
    },
    "glRenderbufferStorage": {
      "signature": "void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format and dimensions of a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
      }
    },
    "glRenderbufferStorageMultisample": {
      "signature": "void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format, dimensions and sample count of a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "samples": "<listitem> <para> Specifies the number of samples to be used for the renderbuffer object's storage. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
      }
    },
    "glResumeTransformFeedback": {
      "signature": "void glResumeTransformFeedback(void)",
      "purpose": "resume transform feedback operations",
      "parameters": {}
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLfloat value, GLboolean invert)",
      "purpose": "specify multisample coverage parameters",
      "parameters": {
        "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
        "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glSamplerParameterf": {
      "signature": "void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteri": {
      "signature": "void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterfv": {
      "signature": "void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteriv": {
      "signature": "void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glShaderBinary": {
      "signature": "void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load pre-compiled shader binaries",
      "parameters": {
        "count": "<listitem> <para> Specifies the number of shader object handles contained in <parameter>shaders</parameter>. </para> </listitem>",
        "shaders": "<listitem> <para> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the shader binaries contained in <parameter>binary</parameter>. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array of bytes containing pre-compiled binary shader code. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the array whose address is given in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glShaderSource": {
      "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)",
      "purpose": "Replaces the source code in a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
        "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
        "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and back function and reference value for stencil testing",
      "parameters": {
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilFuncSeparate": {
      "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and/or back function and reference value for stencil testing",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the front and back writing of individual bits in the stencil planes",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilMaskSeparate": {
      "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
      "purpose": "control the front and/or back writing of individual bits in the stencil planes",
      "parameters": {
        "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and back stencil test actions",
      "parameters": {
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glStencilOpSeparate": {
      "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and/or back stencil test actions",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage3D": {
      "signature": "void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be one of `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"> <msup><mi mathvariant=\"italic\">n</mi> <mi mathvariant=\"italic\">th</mi> </msup> </math></inlineequation> mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`, </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexStorage2D": {
      "signature": "void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "simultaneously specify storage for all levels of a two-dimensional texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_2D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage3D": {
      "signature": "void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)",
      "purpose": "simultaneously specify storage for all levels of a three-dimensional or two-dimensional array texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_3D`, or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage3D": {
      "signature": "void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTransformFeedbackVaryings": {
      "signature": "void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode)",
      "purpose": "specify values to record in transform feedback buffers",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "count": "<listitem> <para> The number of varying variables used for transform feedback. </para> </listitem>",
        "varyings": "<listitem> <para> An array of <parameter>count</parameter> zero-terminated strings specifying the names of the varying variables to use for transform feedback. </para> </listitem>",
        "bufferMode": "<listitem> <para> Identifies the mode used to capture the varying variables when transform feedback is active. <parameter>bufferMode</parameter> must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`. </para> </listitem>"
      }
    },
    "glUniform1f": {
      "signature": "void glUniform1f(GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2f": {
      "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3f": {
      "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4f": {
      "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1i": {
      "signature": "void glUniform1i(GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2i": {
      "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3i": {
      "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4i": {
      "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1ui": {
      "signature": "void glUniform1ui(GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2ui": {
      "signature": "void glUniform2ui(GLint location, GLuint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3ui": {
      "signature": "void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4ui": {
      "signature": "void glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1fv": {
      "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2fv": {
      "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3fv": {
      "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4fv": {
      "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1iv": {
      "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2iv": {
      "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3iv": {
      "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4iv": {
      "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1uiv": {
      "signature": "void glUniform1uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2uiv": {
      "signature": "void glUniform2uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3uiv": {
      "signature": "void glUniform3uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4uiv": {
      "signature": "void glUniform4uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2fv": {
      "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3fv": {
      "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4fv": {
      "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x3fv": {
      "signature": "void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x2fv": {
      "signature": "void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x4fv": {
      "signature": "void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x2fv": {
      "signature": "void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x4fv": {
      "signature": "void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x3fv": {
      "signature": "void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformBlockBinding": {
      "signature": "void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)",
      "purpose": "assign a binding point to an active uniform block",
      "parameters": {
        "program": "<listitem> <para> The name of a program object containing the active uniform block whose binding to assign. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> The index of the active uniform block within <parameter>program</parameter> whose binding to assign. </para> </listitem>",
        "uniformBlockBinding": "<listitem> <para> Specifies the binding point to which to bind the uniform block with index <parameter>uniformBlockIndex</parameter> within <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glUseProgram": {
      "signature": "void glUseProgram(GLuint program)",
      "purpose": "Installs a program object as part of current rendering state",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
      }
    },
    "glValidateProgram": {
      "signature": "void glValidateProgram(GLuint program)",
      "purpose": "Validates a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
      }
    },
    "glVertexAttrib1f": {
      "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2f": {
      "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3f": {
      "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4f": {
      "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4i": {
      "signature": "void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4ui": {
      "signature": "void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1fv": {
      "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2fv": {
      "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3fv": {
      "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4fv": {
      "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4iv": {
      "signature": "void glVertexAttribI4iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4uiv": {
      "signature": "void glVertexAttribI4uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribDivisor": {
      "signature": "void glVertexAttribDivisor(GLuint index, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes advance during instanced rendering",
      "parameters": {
        "index": "<listitem> <para> Specify the index of the generic vertex attribute. </para> </listitem>",
        "divisor": "<listitem> <para> Specify the number of instances that will pass between updates of the generic attribute at slot <parameter>index</parameter>. </para> </listitem>"
      }
    },
    "glVertexAttribPointer": {
      "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0.</para> </listitem>"
      }
    },
    "glVertexAttribIPointer": {
      "signature": "void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0.</para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glWaitSync": {
      "signature": "void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "instruct the GL server to block until the specified sync object becomes signaled",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> must be zero. </para> </listitem>",
        "timeout": "<listitem> <para> Specifies the timeout that the server should wait before continuing. <parameter>timeout</parameter> must be `GL_TIMEOUT_IGNORED`. </para> </listitem>"
      }
    },
    "greaterThan": {
      "signature": "bvec greaterThan(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "greaterThanEqual": {
      "signature": "bvec greaterThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "intBitsToFloat": {
      "signature": "genType intBitsToFloat(genIType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "uintBitsToFloat": {
      "signature": "genType uintBitsToFloat(genUType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "inverse": {
      "signature": "mat4 inverse(mat4 m)",
      "purpose": "calculate the inverse of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the inverse. </para> </listitem>"
      }
    },
    "inversesqrt": {
      "signature": "genType inversesqrt(genType x)",
      "purpose": "return the inverse of the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the inverse of the square root. </para> </listitem>"
      }
    },
    "isinf": {
      "signature": "genBType isinf(genType x)",
      "purpose": "determine whether the parameter is positive or negative infinity",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for infinity. </para> </listitem>"
      }
    },
    "isnan": {
      "signature": "genBType isnan(genType x)",
      "purpose": "determine whether the parameter is a number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for NaN. </para> </listitem>"
      }
    },
    "length": {
      "signature": "float length(genType x)",
      "purpose": "calculate the length of a vector",
      "parameters": {
        "x": "<listitem> <para> Specifies a vector of which to calculate the length. </para> </listitem>"
      }
    },
    "lessThan": {
      "signature": "bvec lessThan(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "lessThanEqual": {
      "signature": "bvec lessThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "log": {
      "signature": "genType log(genType x)",
      "purpose": "return the natural logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the natural logarithm. </para> </listitem>"
      }
    },
    "log2": {
      "signature": "genType log2(genType x)",
      "purpose": "return the base 2 logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the base 2 logarithm. </para> </listitem>"
      }
    },
    "matrixCompMult": {
      "signature": "mat matrixCompMult(mat x, mat y)",
      "purpose": "perform a component-wise multiplication of two matrices",
      "parameters": {
        "x": "<listitem> <para> Specifies the first matrix multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second matrix multiplicand. </para> </listitem>"
      }
    },
    "max": {
      "signature": "genUType max(genUType x, uint y)",
      "purpose": "return the greater of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "min": {
      "signature": "genUType min(genUType x, uint y)",
      "purpose": "return the lesser of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "mix": {
      "signature": "genType mix(genType x, genType y, genBType a)",
      "purpose": "linearly interpolate between two values",
      "parameters": {
        "x": "<listitem> <para> Specify the start of the range in which to interpolate. </para> </listitem>",
        "y": "<listitem> <para> Specify the end of the range in which to interpolate. </para> </listitem>",
        "a": "<listitem> <para> Specify the value to use to interpolate between <parameter>x</parameter> and <parameter>y</parameter>. </para> </listitem>"
      }
    },
    "mod": {
      "signature": "genType mod(genType x, genType y)",
      "purpose": "compute value of one parameter modulo another",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>",
        "y": "<listitem> <para> Specify the value by which to perform the modulo. </para> </listitem>"
      }
    },
    "modf": {
      "signature": "genType modf(genType x, out genType i)",
      "purpose": "separate a value into its integer and fractional components",
      "parameters": {
        "x": "<listitem> <para> Specify the value to separate. </para> </listitem>",
        "out i": "<listitem> <para> A variable that receives the integer part of the argument. </para> </listitem>"
      }
    },
    "normalize": {
      "signature": "genType normalize(genType v)",
      "purpose": "calculates the unit vector in the same direction as the original vector",
      "parameters": {
        "v": "<listitem> <para> Specifies the vector to normalize. </para> </listitem>"
      }
    },
    "not": {
      "signature": "bvec not(bvec x)",
      "purpose": "logically invert a boolean vector",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be inverted. </para> </listitem>"
      }
    },
    "notEqual": {
      "signature": "bvec notEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise not-equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "outerProduct": {
      "signature": "mat4x3 outerProduct(vec3 c, vec4 r)",
      "purpose": "calculate the outer product of a pair of vectors",
      "parameters": {
        "c": "<listitem> <para> Specifies the parameter to be treated as a column vector. </para> </listitem>",
        "r": "<listitem> <para> Specifies the parameter to be treated as a row vector. </para> </listitem>"
      }
    },
    "packHalf2x16": {
      "signature": "uint packHalf2x16(vec2 v)",
      "purpose": "convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer",
      "parameters": {
        "v": "<listitem> <para> Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result. </para> </listitem>"
      }
    },
    "packUnorm2x16": {
      "signature": "uint packUnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm2x16": {
      "signature": "uint packSnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "pow": {
      "signature": "genType pow(genType x, genType y)",
      "purpose": "return the value of the first parameter raised to the power of the second",
      "parameters": {
        "x": "<listitem> <para> Specify the value to raise to the power <parameter>y</parameter>. </para> </listitem>",
        "y": "<listitem> <para> Specify the power to which to raise <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "radians": {
      "signature": "genType radians(genType degrees)",
      "purpose": "convert a quantity in degrees to radians",
      "parameters": {
        "degrees": "<listitem> <para> Specify the quantity, in degrees, to be converted to radians. </para> </listitem>"
      }
    },
    "reflect": {
      "signature": "genType reflect(genType I, genType N)",
      "purpose": "calculate the reflection direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>"
      }
    },
    "refract": {
      "signature": "genType refract(genType I, genType N, float eta)",
      "purpose": "calculate the refraction direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>",
        "eta": "<listitem> <para> Specifies the ratio of indices of refraction. </para> </listitem>"
      }
    },
    "round": {
      "signature": "genType round(genType x)",
      "purpose": "find the nearest integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "roundEven": {
      "signature": "genType roundEven(genType x)",
      "purpose": "find the nearest even integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "sign": {
      "signature": "genIType sign(genIType x)",
      "purpose": "extract the sign of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value from which to extract the sign. </para> </listitem>"
      }
    },
    "sin": {
      "signature": "genType sin(genType angle)",
      "purpose": "return the sine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the sine. </para> </listitem>"
      }
    },
    "sinh": {
      "signature": "genType sinh(genType x)",
      "purpose": "return the hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic sine to return. </para> </listitem>"
      }
    },
    "smoothstep": {
      "signature": "genType smoothstep(float edge0, float edge1, genType x)",
      "purpose": "perform Hermite interpolation between two values",
      "parameters": {
        "edge0": "<listitem> <para> Specifies the value of the lower edge of the Hermite function. </para> </listitem>",
        "edge1": "<listitem> <para> Specifies the value of the upper edge of the Hermite function. </para> </listitem>",
        "x": "<listitem> <para> Specifies the source value for interpolation. </para> </listitem>"
      }
    },
    "sqrt": {
      "signature": "genType sqrt(genType x)",
      "purpose": "return the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the square root. </para> </listitem>"
      }
    },
    "step": {
      "signature": "genType step(float edge, genType x)",
      "purpose": "generate a step function by comparing two values",
      "parameters": {
        "edge": "<listitem> <para> Specifies the location of the edge of the step function. </para> </listitem>",
        "x": "<listitem> <para> Specify the value to be used to generate the step function. </para> </listitem>"
      }
    },
    "tan": {
      "signature": "genType tan(genType angle)",
      "purpose": "return the tangent of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the tangent. </para> </listitem>"
      }
    },
    "tanh": {
      "signature": "genType tanh(genType x)",
      "purpose": "return the hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "texelFetch": {
      "signature": "gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod)",
      "purpose": "perform a lookup of a single texel within a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>"
      }
    },
    "texelFetchOffset": {
      "signature": "gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)",
      "purpose": "perform a lookup of a single texel within a texture with an offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>"
      }
    },
    "texture": {
      "signature": "float texture(sampler2DArrayShadow sampler, vec4 P)",
      "purpose": "retrieves texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureGrad": {
      "signature": "float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
      "purpose": "perform a texture lookup with explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureGradOffset": {
      "signature": "float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset to be applied to the texture coordinates before sampling. </para> </listitem>"
      }
    },
    "textureLod": {
      "signature": "gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)",
      "purpose": "perform a texture lookup with explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail </para> </listitem>"
      }
    },
    "textureLodOffset": {
      "signature": "gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which texels will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that will be applied to <parameter>P</parameter> before texels are fetched. </para> </listitem>"
      }
    },
    "textureOffset": {
      "signature": "gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias)",
      "purpose": "perform a texture lookup with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProj": {
      "signature": "float textureProj(sampler2DShadow sampler, vec4 P, [float bias)",
      "purpose": "perform a texture lookup with projection",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProjGrad": {
      "signature": "float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
      "purpose": "perform a texture lookup with projection and explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureProjGradOffset": {
      "signature": "float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with projection, explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offsets, in texels at which the texture will be sampled relative to the projection of <parameter>P</parameter>. </para> </listitem>"
      }
    },
    "textureProjLod": {
      "signature": "float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>"
      }
    },
    "textureProjLodOffset": {
      "signature": "float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset, in texels, to be applied to <parameter>P</parameter> before fetching texels. </para> </listitem>"
      }
    },
    "textureProjOffset": {
      "signature": "float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias)",
      "purpose": "perform a texture lookup with projection and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that is applied to <parameter>P</parameter> before sampling occurs. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureSize": {
      "signature": "ivec3 textureSize(sampler2DArrayShadow sampler, int lod)",
      "purpose": "retrieve the dimensions of a level of a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture whose dimensions to retrieve is bound. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the level of the texture for which to retrieve the dimensions. </para> </listitem>"
      }
    },
    "transpose": {
      "signature": "mat4x3 transpose(mat3x4 m)",
      "purpose": "calculate the transpose of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the transpose. </para> </listitem>"
      }
    },
    "trunc": {
      "signature": "genType trunc(genType x)",
      "purpose": "find the truncated value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "unpackHalf2x16": {
      "signature": "vec2 unpackHalf2x16(uint v)",
      "purpose": "convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities",
      "parameters": {
        "v": "<listitem> <para> Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked. </para> </listitem>"
      }
    },
    "unpackUnorm2x16": {
      "signature": "vec2 unpackUnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm2x16": {
      "signature": "vec2 unpackSnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    }
  },
  "es3.1": {
    "abs": {
      "signature": "genIType abs(genIType x)",
      "purpose": "return the absolute value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to return the absolute. </para> </listitem>"
      }
    },
    "acos": {
      "signature": "genType acos(genType x)",
      "purpose": "return the arccosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arccosine to return. </para> </listitem>"
      }
    },
    "acosh": {
      "signature": "genType acosh(genType x)",
      "purpose": "return the arc hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "all": {
      "signature": "bool all(bvec x)",
      "purpose": "check whether all elements of a boolean vector are true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "any": {
      "signature": "bool any(bvec x)",
      "purpose": "check whether any element of a boolean vector is true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "asin": {
      "signature": "genType asin(genType x)",
      "purpose": "return the arcsine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arcsine to return. </para> </listitem>"
      }
    },
    "asinh": {
      "signature": "genType asinh(genType x)",
      "purpose": "return the arc hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic sine to return. </para> </listitem>"
      }
    },
    "atan": {
      "signature": "genType atan(genType y_over_x)",
      "purpose": "return the arc-tangent of the parameters",
      "parameters": {
        "y": "<listitem> <para> Specify the numerator of the fraction whose arctangent to return. </para> </listitem>",
        "x": "<listitem> <para> Specify the denominator of the fraction whose arctangent to return. </para> </listitem>",
        "y_over_x": "<listitem> <para> Specify the fraction whose arctangent to return. </para> </listitem>"
      }
    },
    "atanh": {
      "signature": "genType atanh(genType x)",
      "purpose": "return the arc hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "atomicAdd": {
      "signature": "uint atomicAdd(inout uint mem, uint data)",
      "purpose": "perform an atomic addition to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be added to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicAnd": {
      "signature": "uint atomicAnd(inout uint mem, uint data)",
      "purpose": "perform an atomic logical AND operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically ANDed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicCompSwap": {
      "signature": "uint atomicCompSwap(inout uint mem, uint compare, uint data)",
      "purpose": "perform an atomic compare-exchange operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared and potentially exchanged with <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicCounter": {
      "signature": "uint atomicCounter(atomic_uint c)",
      "purpose": "return the current value of an atomic counter",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter whose value to return. </para> </listitem>"
      }
    },
    "atomicCounterDecrement": {
      "signature": "uint atomicCounterDecrement(atomic_uint c)",
      "purpose": "atomically decrement a counter and return the prior value",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter to decrement. </para> </listitem>"
      }
    },
    "atomicCounterIncrement": {
      "signature": "uint atomicCounterIncrement(atomic_uint c)",
      "purpose": "atomically increment a counter and return the prior value",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter to increment. </para> </listitem>"
      }
    },
    "atomicExchange": {
      "signature": "uint atomicExchange(inout uint mem, uint data)",
      "purpose": "perform an atomic exchange operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be exchanged with <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicMax": {
      "signature": "uint atomicMax(inout uint mem, uint data)",
      "purpose": "perform an atomic max operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicMin": {
      "signature": "uint atomicMin(inout uint mem, uint data)",
      "purpose": "perform an atomic min operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicOr": {
      "signature": "uint atomicOr(inout uint mem, uint data)",
      "purpose": "perform an atomic logical OR operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically ORed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicXor": {
      "signature": "uint atomicXor(inout uint mem, uint data)",
      "purpose": "perform an atomic logical exclusive OR operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically exclusive ORed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "barrier": {
      "signature": "void barrier(void)",
      "purpose": "synchronize execution of multiple shader invocations",
      "parameters": {}
    },
    "bitCount": {
      "signature": "genIType bitCount(genUType value)",
      "purpose": "counts the number of 1 bits in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to count. </para> </listitem>"
      }
    },
    "bitfieldExtract": {
      "signature": "genUType bitfieldExtract(genUType value, int offset, int bits)",
      "purpose": "extract a range of bits from an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the integer from which to extract bits. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the index of the first bit to extract. </para> </listitem>",
        "bits": "<listitem> <para> Specifies the number of bits to extract. </para> </listitem>"
      }
    },
    "bitfieldInsert": {
      "signature": "genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)",
      "purpose": "insert a range of bits into an integer",
      "parameters": {
        "base": "<listitem> <para> Specifies the integer into which to insert <parameter>insert</parameter>. </para> </listitem>",
        "insert": "<listitem> <para> Specifies the value of the bits to insert. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the index of the first bit to insert. </para> </listitem>",
        "bits": "<listitem> <para> Specifies the number of bits to insert. </para> </listitem>"
      }
    },
    "bitfieldReverse": {
      "signature": "genUType bitfieldReverse(genUType value)",
      "purpose": "reverse the order of bits in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to reverse. </para> </listitem>"
      }
    },
    "ceil": {
      "signature": "genType ceil(genType x)",
      "purpose": "find the nearest integer that is greater than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "clamp": {
      "signature": "genUType clamp(genUType x, uint minVal, uint maxVal)",
      "purpose": "constrain a value to lie between two further values",
      "parameters": {
        "x": "<listitem> <para> Specify the value to constrain. </para> </listitem>",
        "minVal": "<listitem> <para> Specify the lower end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>",
        "maxVal": "<listitem> <para> Specify the upper end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "cos": {
      "signature": "genType cos(genType angle)",
      "purpose": "return the cosine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the cosine. </para> </listitem>"
      }
    },
    "cosh": {
      "signature": "genType cosh(genType x)",
      "purpose": "return the hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "cross": {
      "signature": "vec3 cross(vec3 x, vec3 y)",
      "purpose": "calculate the cross product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "degrees": {
      "signature": "genType degrees(genType radians)",
      "purpose": "convert a quantity in radians to degrees",
      "parameters": {
        "radians": "<listitem> <para> Specify the quantity, in radians, to be converted to degrees. </para> </listitem>"
      }
    },
    "determinant": {
      "signature": "float determinant(mat4 m)",
      "purpose": "calculate the determinant of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the determinant. </para> </listitem>"
      }
    },
    "dFdx": {
      "signature": "genType dFdx(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdy": {
      "signature": "genType dFdy(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "distance": {
      "signature": "float distance(genType p0, genType p1)",
      "purpose": "calculate the distance between two points",
      "parameters": {
        "p0": "<listitem> <para> Specifies the first of two points </para> </listitem>",
        "p1": "<listitem> <para> Specifies the second of two points </para> </listitem>"
      }
    },
    "dot": {
      "signature": "float dot(genType x, genType y)",
      "purpose": "calculate the dot product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "equal": {
      "signature": "bvec equal(uvec x, uvec y)",
      "purpose": "perform a component-wise equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "exp": {
      "signature": "genType exp(genType x)",
      "purpose": "return the natural exponentiation of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to exponentiate. </para> </listitem>"
      }
    },
    "exp2": {
      "signature": "genType exp2(genType x)",
      "purpose": "return 2 raised to the power of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of the power to which 2 will be raised. </para> </listitem>"
      }
    },
    "faceforward": {
      "signature": "genType faceforward(genType N, genType I, genType Nref)",
      "purpose": "return a vector pointing in the same direction as another",
      "parameters": {
        "N": "<listitem> <para> Specifies the vector to orient. </para> </listitem>",
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "Nref": "<listitem> <para> Specifies the reference vector. </para> </listitem>"
      }
    },
    "findLSB": {
      "signature": "genIType findLSB(genUType value)",
      "purpose": "find the index of the least significant bit set to 1 in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to scan. </para> </listitem>"
      }
    },
    "findMSB": {
      "signature": "genIType findMSB(genUType value)",
      "purpose": "find the index of the most significant bit set to 1 in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to scan. </para> </listitem>"
      }
    },
    "floatBitsToInt": {
      "signature": "genIType floatBitsToInt(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floatBitsToUint": {
      "signature": "genUType floatBitsToUint(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floor": {
      "signature": "genType floor(genType x)",
      "purpose": "find the nearest integer less than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "fract": {
      "signature": "genType fract(genType x)",
      "purpose": "compute the fractional part of the argument",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "frexp": {
      "signature": "genType frexp(genType x, out genIType exp)",
      "purpose": "split a floating point number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value from which significand and exponent are to be extracted. </para> </listitem>",
        "out exp": "<listitem> <para> Specifies the variable into which to place the exponent </para> </listitem>"
      }
    },
    "fwidth": {
      "signature": "genType fwidth(genType p)",
      "purpose": "return the sum of the absolute derivatives in x and y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "glActiveShaderProgram": {
      "signature": "void glActiveShaderProgram(GLuint pipeline, GLuint program)",
      "purpose": "set the active program object for a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the program pipeline object to set the active program object for. </para> </listitem>",
        "program": "<listitem> <para> Specifies the program object to set as the active program pipeline object <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation-dependent, but must be at least 32. <parameter>texture</parameter> must be one of `GL_TEXTURE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAttachShader": {
      "signature": "void glAttachShader(GLuint program, GLuint shader)",
      "purpose": "Attaches a shader object to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
      }
    },
    "glBeginQuery": {
      "signature": "void glBeginQuery(GLenum target, GLuint id)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glEndQuery": {
      "signature": "void glEndQuery(GLenum target)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glBeginTransformFeedback": {
      "signature": "void glBeginTransformFeedback(GLenum primitiveMode)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glEndTransformFeedback": {
      "signature": "void glEndTransformFeedback(void)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glBindAttribLocation": {
      "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
      "purpose": "Associates a generic vertex attribute index with a named attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
        "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
      }
    },
    "glBindBufferBase": {
      "signature": "void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)",
      "purpose": "bind a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>"
      }
    },
    "glBindBufferRange": {
      "signature": "void glBindBufferRange(GLenumtarget, GLuintindex, GLuintbuffer, GLintptroffset, GLsizeiptrsize)",
      "purpose": "bind a range within a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER` or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>",
        "offset": "<listitem> <para> The starting offset in basic machine units into the buffer object <parameter>buffer</parameter>. </para> </listitem>",
        "size": "<listitem> <para> The amount of data in machine units that can be read from the buffet object while used as an indexed target. </para> </listitem>"
      }
    },
    "glBindFramebuffer": {
      "signature": "void glBindFramebuffer(GLenum target, GLuint framebuffer)",
      "purpose": "bind a framebuffer to a framebuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target of the binding operation. </para> </listitem>",
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object to bind. </para> </listitem>"
      }
    },
    "glBindImageTexture": {
      "signature": "void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)",
      "purpose": "bind a level of a texture to an image unit",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the image unit to which to bind the texture </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of the texture to bind to the image unit. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level of the texture that is to be bound. </para> </listitem>",
        "layered": "<listitem> <para> Specifies whether a layered texture binding is to be established. </para> </listitem>",
        "layer": "<listitem> <para> If <parameter>layered</parameter> is `GL_FALSE`, specifies the layer of <parameter>texture</parameter> to be bound to the image unit. Ignored otherwise. </para> </listitem>",
        "access": "<listitem> <para> Specifies a token indicating the type of access that will be performed on the image. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format that the elements of the image will be treated as for the purposes of formatted loads and stores. </para> </listitem>"
      }
    },
    "glBindProgramPipeline": {
      "signature": "void glBindProgramPipeline(GLuint pipeline)",
      "purpose": "bind a program pipeline to the current context",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of the pipeline object to bind to the context. </para> </listitem>"
      }
    },
    "glBindRenderbuffer": {
      "signature": "void glBindRenderbuffer(GLenum target, GLuint renderbuffer)",
      "purpose": "bind a renderbuffer to a renderbuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the renderbuffer target of the binding operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of the renderbuffer object to bind. </para> </listitem>"
      }
    },
    "glBindSampler": {
      "signature": "void glBindSampler(GLuint unit, GLuint sampler)",
      "purpose": "bind a named sampler to a texturing target",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the texture unit to which the sampler is bound. </para> </listitem>",
        "sampler": "<listitem> <para> Specifies the name of a sampler. </para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound. Must be either `GL_TEXTURE_2D`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, or `GL_TEXTURE_CUBE_MAP`, </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBindTransformFeedback": {
      "signature": "void glBindTransformFeedback(GLenum target, GLuint id)",
      "purpose": "bind a transform feedback object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which to bind the transform feedback object <parameter>id</parameter>. <parameter>target</parameter> must be `GL_TRANSFORM_FEEDBACK`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object reserved by <citerefentry><refentrytitle>glGenTransformFeedbacks</refentrytitle></citerefentry>. </para> </listitem>"
      }
    },
    "glBindVertexArray": {
      "signature": "void glBindVertexArray(GLuint array)",
      "purpose": "bind a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies the name of the vertex array to bind. </para> </listitem>"
      }
    },
    "glBindVertexBuffer": {
      "signature": "void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride)",
      "purpose": "bind a buffer to a vertex buffer bind point",
      "parameters": {
        "bindingindex": "<listitem> <para> The index of the vertex buffer binding point to which to bind the buffer. </para> </listitem>",
        "buffer": "<listitem> <para> The name of an existing buffer to bind to the vertex buffer binding point. </para> </listitem>",
        "offset": "<listitem> <para> The offset of the first element of the buffer. </para> </listitem>",
        "stride": "<listitem> <para> The distance between elements within the buffer. </para> </listitem>"
      }
    },
    "glBlendColor": {
      "signature": "void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "set the blend color",
      "parameters": {
        "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
      }
    },
    "glBlendEquation": {
      "signature": "void glBlendEquation(GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparate": {
      "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparate": {
      "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlitFramebuffer": {
      "signature": "void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)",
      "purpose": "copy a block of pixels from the read framebuffer to the draw framebuffer",
      "parameters": {
        "srcX0": "<listitem> <para> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </para> </listitem>",
        "dstX0": "<listitem> <para> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </para> </listitem>",
        "mask": "<listitem> <para> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>",
        "filter": "<listitem> <para> Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`. </para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the buffer object's new data store. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied. </para> </listitem>",
        "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`. </para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "updates a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glCheckFramebufferStatus": {
      "signature": "GLenum glCheckFramebufferStatus(GLenum target)",
      "purpose": "check the completeness status of a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the framebuffer completeness check. </para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
      }
    },
    "glClearBufferiv": {
      "signature": "void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferuiv": {
      "signature": "void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfv": {
      "signature": "void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfi": {
      "signature": "void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)",
      "purpose": "clear individual buffers of the currently bound draw framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawBuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear a depth render buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear a stencil render buffer to. </para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "specify clear values for the color buffers",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearDepthf": {
      "signature": "void glClearDepthf(GLfloat depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glClientWaitSync": {
      "signature": "GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "block and wait for a sync object to become signaled",
      "parameters": {
        "sync": "<listitem> <para> The sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> may be `GL_SYNC_FLUSH_COMMANDS_BIT`. </para> </listitem>",
        "timeout": "<listitem> <para> The timeout, specified in nanoseconds, for which the implementation should wait for <parameter>sync</parameter> to become signaled. </para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
      }
    },
    "glCompileShader": {
      "signature": "void glCompileShader(GLuint shader)",
      "purpose": "Compiles a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage3D": {
      "signature": "void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage3D": {
      "signature": "void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCopyBufferSubData": {
      "signature": "void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)",
      "purpose": "copy part of the data store of a buffer object to the data store of another buffer object",
      "parameters": {
        "readtarget": "<listitem> <para> Specifies the target from whose data store data should be read. </para> </listitem>",
        "writetarget": "<listitem> <para> Specifies the target to whose data store data should be written. </para> </listitem>",
        "readoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>readtarget</parameter> from which data should be read. </para> </listitem>",
        "writeoffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of <parameter>writetarget</parameter> to which data should be written. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size, in basic machine units, of the data to be copied from <parameter>readtarget</parameter> to <parameter>writetarget</parameter>. </para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "copy pixels into a 2D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_RGBA`, `GL_R8`, `GL_RG8`, `GL_RGB565`, `GL_RGB8`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_SRGB8`, `GL_SRGB8_ALPHA8`, `GL_R8I`, `GL_R8UI`, `GL_R16I`, `GL_R16UI`, `GL_R32I`, `GL_R32UI`, `GL_RG8I`, `GL_RG8UI`, `GL_RG16I`, `GL_RG16UI`, `GL_RG32I`, `GL_RG32UI`, `GL_RGBA8I`, `GL_RGBA8UI`, `GL_RGB10_A2UI`, `GL_RGBA16I`, `GL_RGBA16UI`, `GL_RGBA32I`, `GL_RGBA32UI`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be 0. </para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCopyTexSubImage3D": {
      "signature": "void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCreateProgram": {
      "signature": "GLuint glCreateProgram(void)",
      "purpose": "Creates a program object",
      "parameters": {}
    },
    "glCreateShader": {
      "signature": "GLuint glCreateShader(GLenum shaderType)",
      "purpose": "Creates a shader object",
      "parameters": {
        "shaderType": "<listitem> <para> Specifies the type of shader to be created. `GL_VERTEX_SHADER`, `GL_FRAGMENT_SHADER`, or `GL_COMPUTE_SHADER`, </para> </listitem>"
      }
    },
    "glCreateShaderProgramv": {
      "signature": "GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char **strings)",
      "purpose": "create a stand-alone program from an array of null-terminated source code strings",
      "parameters": {
        "type": "<listitem> <para> Specifies the type of shader to create. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of source code strings in the array <parameter>strings</parameter>. </para> </listitem>",
        "strings": "<listitem> <para> Specifies the address of an array of pointers to source code strings from which to create the program object. </para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing polygons can be culled",
      "parameters": {
        "mode": "<listitem> <para> Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteFramebuffers": {
      "signature": "void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "delete framebuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer objects to be deleted. </para> </listitem>",
        "framebuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> framebuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteProgram": {
      "signature": "void glDeleteProgram(GLuint program)",
      "purpose": "Deletes a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteProgramPipelines": {
      "signature": "void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)",
      "purpose": "delete program pipeline objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of program pipeline objects to delete. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array of names of program pipeline objects to delete. </para> </listitem>"
      }
    },
    "glDeleteQueries": {
      "signature": "void glDeleteQueries(GLsizei n, const GLuint * ids)",
      "purpose": "delete named query objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query objects to be deleted. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of query objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteRenderbuffers": {
      "signature": "void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "delete renderbuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer objects to be deleted. </para> </listitem>",
        "renderbuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> renderbuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteSamplers": {
      "signature": "void glDeleteSamplers(GLsizei n, const GLuint * samplers)",
      "purpose": "delete named sampler objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler objects to be deleted. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array of sampler objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteShader": {
      "signature": "void glDeleteShader(GLuint shader)",
      "purpose": "Deletes a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteSync": {
      "signature": "void glDeleteSync(GLsync sync)",
      "purpose": "delete a sync object",
      "parameters": {
        "sync": "<listitem> <para> The sync object to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTransformFeedbacks": {
      "signature": "void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)",
      "purpose": "delete transform feedback objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback objects to delete. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of names of transform feedback objects to delete. </para> </listitem>"
      }
    },
    "glDeleteVertexArrays": {
      "signature": "void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)",
      "purpose": "delete vertex array objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array objects to be deleted. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies the address of an array containing the <parameter>n</parameter> names of the objects to be deleted. </para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
      }
    },
    "glDepthRangef": {
      "signature": "void glDepthRangef(GLfloat n, GLfloat f)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "n": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "f": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDetachShader": {
      "signature": "void glDetachShader(GLuint program, GLuint shader)",
      "purpose": "Detaches a shader object from a program object to which it is attached",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
      }
    },
    "glDispatchCompute": {
      "signature": "void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)",
      "purpose": "launch one or more compute work groups",
      "parameters": {
        "num_groups_x": "<listitem> <para> The number of work groups to be launched in the X dimension. </para> </listitem>",
        "num_groups_y": "<listitem> <para> The number of work groups to be launched in the Y dimension. </para> </listitem>",
        "num_groups_z": "<listitem> <para> The number of work groups to be launched in the Z dimension. </para> </listitem>"
      }
    },
    "glDispatchComputeIndirect": {
      "signature": "void glDispatchComputeIndirect(GLintptr indirect)",
      "purpose": "launch one or more compute work groups using parameters stored in a buffer",
      "parameters": {
        "indirect": "<listitem> <para> The offset into the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` buffer target at which the dispatch parameters are stored. </para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawArraysIndirect": {
      "signature": "void glDrawArraysIndirect(GLenum mode, const void *indirect)",
      "purpose": "render primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing the draw parameters. </para> </listitem>"
      }
    },
    "glDrawArraysInstanced": {
      "signature": "void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount)",
      "purpose": "draw multiple instances of a range of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawBuffers": {
      "signature": "void glDrawBuffers(GLsizei n, const GLenum *bufs)",
      "purpose": "Specifies a list of color buffers to be drawn into",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
        "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawElementsIndirect": {
      "signature": "void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect)",
      "purpose": "render indexed primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, and `GL_TRIANGLES`, are accepted. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing the draw parameters. </para> </listitem>"
      }
    },
    "glDrawElementsInstanced": {
      "signature": "void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)",
      "purpose": "draw multiple instances of a set of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawRangeElements": {
      "signature": "void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN` and `GL_TRIANGLES` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a byte offset (cast to a pointer type) into the buffer bound to `GL_ELEMENT_ARRAY_BUFFER` to start reading indices from. If no buffer is bound, specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnableVertexAttribArray": {
      "signature": "void glEnableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexAttribArray": {
      "signature": "void glDisableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glFenceSync": {
      "signature": "GLsync glFenceSync(GLenum condition, GLbitfield flags)",
      "purpose": "create a new sync object and insert it into the GL command stream",
      "parameters": {
        "condition": "<listitem> <para> Specifies the condition that must be met to set the sync object's state to signaled. <parameter>condition</parameter> must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. </para> </listitem>",
        "flags": "<listitem> <para> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and <parameter>flags</parameter> must be zero.<footnote><para> <parameter>flags</parameter> is a placeholder for anticipated future extensions of fence sync object capabilities. </para> </footnote> </para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish( void)",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush( void)",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFlushMappedBufferRange": {
      "signature": "void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)",
      "purpose": "indicate modifications to a range of a mapped buffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the flush operation. <parameter>target</parameter> must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the start of the buffer subrange, in basic machine units. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the buffer subrange, in basic machine units. </para> </listitem>"
      }
    },
    "glFramebufferParameteri": {
      "signature": "void glFramebufferParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set a named parameter of a framebuffer",
      "parameters": {
        "target": "<listitem> <para> The target of the operation, which must be `GL_READ_FRAMEBUFFER`, `GL_DRAW_FRAMEBUFFER` or `GL_FRAMEBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> A token indicating the parameter to be modified. </para> </listitem>",
        "param": "<listitem> <para> The new value for the parameter named <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glFramebufferRenderbuffer": {
      "signature": "void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
      "purpose": "attach a renderbuffer as a logical buffer to the currently bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "renderbuffertarget": "<listitem> <para> Specifies the renderbuffer target and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of an existing renderbuffer object of type <parameter>renderbuffertarget</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture2D": {
      "signature": "void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer to the currently bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. </para> </listitem>",
        "textarget": "<listitem> <para> Specifies a 2D texture target, 2D multisample texture target, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTextureLayer": {
      "signature": "void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)",
      "purpose": "attach a single layer of a texture to a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target. <parameter>target</parameter> must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. <parameter>attachment</parameter> must be `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the texture object to attach to the framebuffer attachment point named by <parameter>attachment</parameter>. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of <parameter>texture</parameter> to attach. </para> </listitem>",
        "layer": "<listitem> <para> Specifies the layer of <parameter>texture</parameter> to attach. </para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
      }
    },
    "glGenerateMipmap": {
      "signature": "void glGenerateMipmap(GLenum target)",
      "purpose": "generate mipmaps for a specified texture target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture whose mimaps to generate is bound. <parameter>target</parameter> must be `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>"
      }
    },
    "glGenFramebuffers": {
      "signature": "void glGenFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "generate framebuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer object names to generate. </para> </listitem>",
        "framebuffers": "<listitem> <para> Specifies an array in which the generated framebuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenProgramPipelines": {
      "signature": "void glGenProgramPipelines(GLsizei n, GLuint *pipelines)",
      "purpose": "reserve program pipeline object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of program pipeline object names to reserve. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenQueries": {
      "signature": "void glGenQueries(GLsizei n, GLuint * ids)",
      "purpose": "generate query object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query object names to be generated. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which the generated query object names are stored. </para> </listitem>"
      }
    },
    "glGenRenderbuffers": {
      "signature": "void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "generate renderbuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer object names to generate. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array in which the generated renderbuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenSamplers": {
      "signature": "void glGenSamplers(GLsizei n, GLuint *samplers)",
      "purpose": "generate sampler object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler object names to generate. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array in which the generated sampler object names are stored. </para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
      }
    },
    "glGenTransformFeedbacks": {
      "signature": "void glGenTransformFeedbacks(GLsizei n, GLuint *ids)",
      "purpose": "reserve transform feedback object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback object names to reserve. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenVertexArrays": {
      "signature": "void glGenVertexArrays(GLsizei n, GLuint *arrays)",
      "purpose": "generate vertex array object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array object names to generate. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies an array in which the generated vertex array object names are stored. </para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64v": {
      "signature": "void glGetInteger64v(GLenum pname, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetBooleani_v": {
      "signature": "void glGetBooleani_v(GLenum target, GLuint index, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegeri_v": {
      "signature": "void glGetIntegeri_v(GLenum target, GLuint index, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64i_v": {
      "signature": "void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetActiveAttrib": {
      "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active attribute variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
      }
    },
    "glGetActiveUniform": {
      "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active uniform variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
      }
    },
    "glGetActiveUniformBlockiv": {
      "signature": "void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)",
      "purpose": "query information about an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable to receive the result of the query. </para> </listitem>"
      }
    },
    "glGetActiveUniformBlockName": {
      "signature": "void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)",
      "purpose": "retrieve the name of an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer addressed by <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of characters that were written to <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters to receive the name of the uniform block at <parameter>uniformBlockIndex</parameter>. </para> </listitem>"
      }
    },
    "glGetActiveUniformsiv": {
      "signature": "void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)",
      "purpose": "Returns information about several active uniform variables for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "uniformCount": "<listitem> <para>Specifies both the number of elements in the array of indices <parameter>uniformIndices</parameter> and the number of parameters written to <parameter>params</parameter> upon successful return.</para> </listitem>",
        "uniformIndices": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers containing the indices of uniforms within <parameter>program</parameter> whose parameter <parameter>pname</parameter> should be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the property of each uniform in <parameter>uniformIndices</parameter> that should be written into the corresponding element of <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers which are to receive the value of <parameter>pname</parameter> for each uniform in <parameter>uniformIndices</parameter>.</para> </listitem>"
      }
    },
    "glGetAttachedShaders": {
      "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
      "purpose": "Returns the handles of the shader objects attached to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
        "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
      }
    },
    "glGetAttribLocation": {
      "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of an attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferParameteri64v": {
      "signature": "void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS_FLAGS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_MAP_LENGTH`, `GL_BUFFER_MAP_OFFSET`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferPointerv": {
      "signature": "void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)",
      "purpose": "return the pointer to a mapped buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, or `GL_UNIFORM_BUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the pointer to be returned. The symbolic constant must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError( void)",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetFragDataLocation": {
      "signature": "GLint glGetFragDataLocation(GLuint program, const char * name)",
      "purpose": "query the bindings of color numbers to user-defined varying out variables",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to query </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to query </para> </listitem>"
      }
    },
    "glGetFramebufferAttachmentParameteriv": {
      "signature": "void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)",
      "purpose": "retrieve information about attachments of a bound framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the query operation. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment within <parameter>target</parameter> </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of <parameter>attachment</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable receive the value of <parameter>pname</parameter> for <parameter>attachment</parameter>. </para> </listitem>"
      }
    },
    "glGetFramebufferParameteriv": {
      "signature": "void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "retrieve a named parameter from a framebuffer",
      "parameters": {
        "target": "<listitem> <para> The target of the operation, which must be `GL_READ_FRAMEBUFFER`, `GL_DRAW_FRAMEBUFFER` or `GL_FRAMEBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> A token indicating the parameter to be retrieved. </para> </listitem>",
        "params": "<listitem> <para> The address of a variable to receive the value of the parameter named <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetInternalformativ": {
      "signature": "void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)",
      "purpose": "retrieve information about implementation-dependent support for internal formats",
      "parameters": {
        "target": "<listitem> <para> Indicates the usage of the internal format. <parameter>target</parameter> must be `GL_RENDERBUFFER` or `GL_TEXTURE_2D_MULTISAMPLE`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format about which to retrieve information. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the type of information to query. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of integers that may be written to <parameter>params</parameter> by the function. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
      }
    },
    "glGetMultisamplefv": {
      "signature": "void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)",
      "purpose": "retrieve the location of a sample",
      "parameters": {
        "pname": "<listitem> <para> Specifies the sample parameter name. <parameter>pname</parameter> must be `GL_SAMPLE_POSITION`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the sample whose position to query. </para> </listitem>",
        "val": "<listitem> <para> Specifies the address of an array to receive the position of the sample. </para> </listitem>"
      }
    },
    "glGetProgramBinary": {
      "signature": "void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary)",
      "purpose": "return a binary representation of a program object's compiled and linked executable source",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose binary representation to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given by <parameter>binary</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of bytes written into <parameter>binary</parameter>. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address an array into which the GL will return <parameter>program</parameter>'s binary representation. </para> </listitem>"
      }
    },
    "glGetProgramInfoLog": {
      "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetProgramInterfaceiv": {
      "signature": "void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params)",
      "purpose": "query a property of an interface in a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose interface to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> to query. </para> </listitem>",
        "pname": "<listitem> <para> The name of the parameter within <parameter>programInterface</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> The address of a variable to retrieve the value of <parameter>pname</parameter> for the program interface. </para> </listitem>"
      }
    },
    "glGetProgramiv": {
      "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_COMPUTE_WORK_GROUP_SIZE`, `GL_DELETE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_LINK_STATUS`, `GL_PROGRAM_BINARY_LENGTH`, `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, `GL_PROGRAM_SEPARABLE`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH` and `GL_VALIDATE_STATUS`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetProgramPipelineiv": {
      "signature": "void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)",
      "purpose": "retrieve properties of a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object whose parameter retrieve. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to retrieve. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which will be written the value or values of <parameter>pname</parameter> for <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramPipelineInfoLog": {
      "signature": "void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)",
      "purpose": "retrieve the info log string from a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object from which to retrieve the info log. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of characters, including the null terminator, that may be written into <parameter>infoLog</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable into which will be written the number of characters written into <parameter>infoLog</parameter>. </para> </listitem>",
        "infoLog": "<listitem> <para> Specifies the address of an array of characters into which will be written the info log for <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramResourceiv": {
      "signature": "void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params)",
      "purpose": "retrieve values for multiple properties of a single active resource within a program object",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramResourceIndex": {
      "signature": "GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the index of a named resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the index of. </para> </listitem>"
      }
    },
    "glGetProgramResourceLocation": {
      "signature": "GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the location of a named resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the location of. </para> </listitem>"
      }
    },
    "glGetProgramResourceName": {
      "signature": "void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name)",
      "purpose": "query the name of an indexed resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the indexed resource. </para> </listitem>",
        "index": "<listitem> <para> The index of the resource within <parameter>programInterface</parameter> of <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> The size of the character array whose address is given by <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the length of the resource name. </para> </listitem>",
        "name": "<listitem> <para> The address of a character array into which will be written the name of the resource. </para> </listitem>"
      }
    },
    "glGetQueryiv": {
      "signature": "void glGetQueryiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object target",
      "parameters": {
        "target": "<listitem> <para> Specifies a query object target. Must be `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Must be `GL_CURRENT_QUERY`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryObjectuiv": {
      "signature": "void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT` or `GL_QUERY_RESULT_AVAILABLE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetRenderbufferParameteriv": {
      "signature": "void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)",
      "purpose": "retrieve information about a bound renderbuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the query operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the renderbuffer bound to <parameter>target</parameter>. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of an array to receive the value of the queried parameter. </para> </listitem>"
      }
    },
    "glGetSamplerParameterfv": {
      "signature": "void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameteriv": {
      "signature": "void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetShaderInfoLog": {
      "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetShaderiv": {
      "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetShaderPrecisionFormat": {
      "signature": "void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)",
      "purpose": "retrieve the range and precision for numeric formats supported by the shader compiler",
      "parameters": {
        "shaderType": "<listitem> <para> Specifies the type of shader whose precision to query. <parameter>shaderType</parameter> must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "precisionType": "<listitem> <para> Specifies the numeric format whose precision and range to query. </para> </listitem>",
        "range": "<listitem> <para> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </para> </listitem>",
        "precision": "<listitem> <para> Specifies the address of an integer into which the numeric precision of the implementation is written. </para> </listitem>"
      }
    },
    "glGetShaderSource": {
      "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
      "purpose": "Returns the source code string from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
        "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte* glGetString(GLenum name)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetStringi": {
      "signature": "const GLubyte* glGetStringi(GLenum name, GLuint index)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_EXTENSIONS`, `GL_RENDERER`, `GL_SHADING_LANGUAGE_VERSION`, `GL_VENDOR`, or `GL_VERSION`. <function>glGetStringi</function> accepts only the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetSynciv": {
      "signature": "void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)",
      "purpose": "query the properties of a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose properties to query. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the sync object specified in <parameter>sync</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>values</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of an variable to receive the number of integers placed in <parameter>values</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array to receive the values of the queried parameter. </para> </listitem>"
      }
    },
    "glGetTexLevelParameterfv": {
      "signature": "void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values for a specific level of detail",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture, one of `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_SAMPLES`, `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_STENCIL_SIZE`, `GL_TEXTURE_SHARED_SIZE`, `GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`, `GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE`, and `GL_TEXTURE_COMPRESSED` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexLevelParameteriv": {
      "signature": "void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values for a specific level of detail",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture, one of `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_SAMPLES`, `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_STENCIL_SIZE`, `GL_TEXTURE_SHARED_SIZE`, `GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`, `GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE`, and `GL_TEXTURE_COMPRESSED` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTransformFeedbackVarying": {
      "signature": "void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name)",
      "purpose": "retrieve information about varying variables selected for transform feedback",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "index": "<listitem> <para> The index of the varying variable whose information to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The maximum number of characters, including the null terminator, that may be written into <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the number of characters written into <parameter>name</parameter>, excluding the null-terminator. If <parameter>length</parameter> is `NULL` no length is returned. </para> </listitem>",
        "size": "<listitem> <para> The address of a variable that will receive the size of the varying. </para> </listitem>",
        "type": "<listitem> <para> The address of a variable that will receive the type of the varying. </para> </listitem>",
        "name": "<listitem> <para> The address of a buffer into which will be written the name of the varying. </para> </listitem>"
      }
    },
    "glGetUniformfv": {
      "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformiv": {
      "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformuiv": {
      "signature": "void glGetUniformuiv(GLuint program, GLint location, GLuint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformBlockIndex": {
      "signature": "GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters containing the name of the uniform block whose index to retrieve. </para> </listitem>"
      }
    },
    "glGetUniformIndices": {
      "signature": "void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing uniforms whose indices to query. </para> </listitem>",
        "uniformCount": "<listitem> <para> Specifies the number of uniforms whose indices to query. </para> </listitem>",
        "uniformNames": "<listitem> <para> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </para> </listitem>",
        "uniformIndices": "<listitem> <para> Specifies the address of an array that will receive the indices of the uniforms. </para> </listitem>"
      }
    },
    "glGetUniformLocation": {
      "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetVertexAttribfv": {
      "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribiv": {
      "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIiv": {
      "signature": "void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIuiv": {
      "signature": "void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_CURRENT_VERTEX_ATTRIB`, `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_BINDING`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribPointerv": {
      "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
      "purpose": "return the address of the specified generic vertex attribute pointer",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
        "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_FRAGMENT_SHADER_DERIVATIVE_HINT`, and `GL_GENERATE_MIPMAP_HINT` are accepted. </para> </listitem>",
        "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
      }
    },
    "glInvalidateFramebuffer": {
      "signature": "void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)",
      "purpose": "Invalidate the contents of attachments within a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
        "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>"
      }
    },
    "glInvalidateSubFramebuffer": {
      "signature": "void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLintx, GLinty, GLsizei width, GLsizei height)",
      "purpose": "Invalidate portions of the contents of attachments within a framebuffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the invalidate operation. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies how many attachments are supplied in the <parameter>attachments</parameter> list. </para> </listitem>",
        "attachments": "<listitem> <para> A list of <parameter>numAttachments</parameter> attachments to invalidate. </para> </listitem>",
        "x": "<listitem> <para> Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
        "y": "<listitem> <para> Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the pixel rectangle to invalidate. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the pixel rectangle to invalidate. </para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
      }
    },
    "glIsFramebuffer": {
      "signature": "GLboolean glIsFramebuffer(GLuint framebuffer)",
      "purpose": "determine if a name corresponds to a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies a value that may be the name of a framebuffer object. </para> </listitem>"
      }
    },
    "glIsProgram": {
      "signature": "GLboolean glIsProgram(GLuint program)",
      "purpose": "Determines if a name corresponds to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
      }
    },
    "glIsProgramPipeline": {
      "signature": "GLboolean glIsProgramPipeline(GLuint pipeline)",
      "purpose": "determine if a name corresponds to a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies a value that may be the name of a program pipeline object. </para> </listitem>"
      }
    },
    "glIsQuery": {
      "signature": "GLboolean glIsQuery(GLuint id)",
      "purpose": "determine if a name corresponds to a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a query object. </para> </listitem>"
      }
    },
    "glIsRenderbuffer": {
      "signature": "GLboolean glIsRenderbuffer(GLuint renderbuffer)",
      "purpose": "determine if a name corresponds to a renderbuffer object",
      "parameters": {
        "renderbuffer": "<listitem> <para> Specifies a value that may be the name of a renderbuffer object. </para> </listitem>"
      }
    },
    "glIsSampler": {
      "signature": "GLboolean glIsSampler(GLuint id)",
      "purpose": "determine if a name corresponds to a sampler object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a sampler object. </para> </listitem>"
      }
    },
    "glIsShader": {
      "signature": "GLboolean glIsShader(GLuint shader)",
      "purpose": "Determines if a name corresponds to a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
      }
    },
    "glIsSync": {
      "signature": "GLboolean glIsSync(GLsync sync)",
      "purpose": "determine if a name corresponds to a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies a value that may be the name of a sync object. </para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glIsTransformFeedback": {
      "signature": "GLboolean glIsTransformFeedback(GLuint id)",
      "purpose": "determine if a name corresponds to a transform feedback object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a transform feedback object. </para> </listitem>"
      }
    },
    "glIsVertexArray": {
      "signature": "GLboolean glIsVertexArray(GLuint array)",
      "purpose": "determine if a name corresponds to a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies a value that may be the name of a vertex array object. </para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
      }
    },
    "glLinkProgram": {
      "signature": "void glLinkProgram(GLuint program)",
      "purpose": "Links a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
      }
    },
    "glMapBufferRange": {
      "signature": "void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)",
      "purpose": "map a section of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target buffer is bound. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
      }
    },
    "glUnmapBuffer": {
      "signature": "GLboolean glUnmapBuffer(GLenum target)",
      "purpose": "map a section of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target buffer is bound. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the range. </para> </listitem>"
      }
    },
    "glMemoryBarrier": {
      "signature": "void glMemoryBarrier(GLbitfield barriers)",
      "purpose": "defines a barrier ordering memory transactions",
      "parameters": {
        "barriers": "<listitem> <para> Specifies the barriers to insert. Must be a bitwise combination of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers will be inserted. </para> </listitem>"
      }
    },
    "glMemoryBarrierByRegion": {
      "signature": "void glMemoryBarrierByRegion(GLbitfield barriers)",
      "purpose": "defines a barrier ordering memory transactions",
      "parameters": {
        "barriers": "<listitem> <para> Specifies the barriers to insert. Must be a bitwise combination of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers will be inserted. </para> </listitem>"
      }
    },
    "glPauseTransformFeedback": {
      "signature": "void glPauseTransformFeedback(void)",
      "purpose": "pause transform feedback operations",
      "parameters": {}
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Four values affect the packing of pixel data into memory: `GL_PACK_ROW_LENGTH`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth values",
      "parameters": {
        "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
        "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
      }
    },
    "glProgramBinary": {
      "signature": "void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load a program object with a program binary",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object into which to load a program binary. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the binary data in binary. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array containing the binary to be loaded into <parameter>program</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the number of bytes contained in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glProgramParameteri": {
      "signature": "void glProgramParameteri(GLuint program, GLenum pname, GLint value)",
      "purpose": "specify a parameter for a program object",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to modify. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value of the parameter specified by <parameter>pname</parameter> for <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glProgramUniform1f": {
      "signature": "void glProgramUniform1f(GLuint program, GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2f": {
      "signature": "void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3f": {
      "signature": "void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4f": {
      "signature": "void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1i": {
      "signature": "void glProgramUniform1i(GLuint program, GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2i": {
      "signature": "void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3i": {
      "signature": "void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4i": {
      "signature": "void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1ui": {
      "signature": "void glProgramUniform1ui(GLuint program, GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2ui": {
      "signature": "void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3ui": {
      "signature": "void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4ui": {
      "signature": "void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1fv": {
      "signature": "void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2fv": {
      "signature": "void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3fv": {
      "signature": "void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4fv": {
      "signature": "void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1iv": {
      "signature": "void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2iv": {
      "signature": "void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3iv": {
      "signature": "void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4iv": {
      "signature": "void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1uiv": {
      "signature": "void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2uiv": {
      "signature": "void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3uiv": {
      "signature": "void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4uiv": {
      "signature": "void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2fv": {
      "signature": "void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3fv": {
      "signature": "void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4fv": {
      "signature": "void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2x3fv": {
      "signature": "void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3x2fv": {
      "signature": "void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2x4fv": {
      "signature": "void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4x2fv": {
      "signature": "void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3x4fv": {
      "signature": "void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4x3fv": {
      "signature": "void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glReadBuffer": {
      "signature": "void glReadBuffer(GLenum src)",
      "purpose": "select a color buffer source for pixels",
      "parameters": {
        "src": "<listitem> <para> Specifies a color buffer. Accepted values are `GL_BACK`, `GL_NONE`, and `GL_COLOR_ATTACHMENTi`. </para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RGBA`, and `GL_RGBA_INTEGER`. An implementation-chosen format will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_FORMAT`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_INT`, or `GL_FLOAT`. An implementation-chosen type will also be accepted. This can be queried with <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> and `GL_IMPLEMENTATION_COLOR_READ_TYPE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
      }
    },
    "glReleaseShaderCompiler": {
      "signature": "void glReleaseShaderCompiler(void)",
      "purpose": "release resources consumed by the implementation's shader compiler",
      "parameters": {}
    },
    "glRenderbufferStorage": {
      "signature": "void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format and dimensions of a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
      }
    },
    "glRenderbufferStorageMultisample": {
      "signature": "void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format, dimensions and sample count of a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para> Specifies a binding to which the target of the allocation and must be `GL_RENDERBUFFER`. </para> </listitem>",
        "samples": "<listitem> <para> Specifies the number of samples to be used for the renderbuffer object's storage. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format to use for the renderbuffer object's image. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the renderbuffer, in pixels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the renderbuffer, in pixels. </para> </listitem>"
      }
    },
    "glResumeTransformFeedback": {
      "signature": "void glResumeTransformFeedback(void)",
      "purpose": "resume transform feedback operations",
      "parameters": {}
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLfloat value, GLboolean invert)",
      "purpose": "specify multisample coverage parameters",
      "parameters": {
        "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
        "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glSampleMaski": {
      "signature": "void glSampleMaski(GLuint maskNumber, GLbitfield mask)",
      "purpose": "set the value of a sub-word of the sample mask",
      "parameters": {
        "maskNumber": "<listitem> <para> Specifies which 32-bit sub-word of the sample mask to update. </para> </listitem>",
        "mask": "<listitem> <para> Specifies the new value of the mask sub-word. </para> </listitem>"
      }
    },
    "glSamplerParameterf": {
      "signature": "void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteri": {
      "signature": "void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterfv": {
      "signature": "void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteriv": {
      "signature": "void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glShaderBinary": {
      "signature": "void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load pre-compiled shader binaries",
      "parameters": {
        "count": "<listitem> <para> Specifies the number of shader object handles contained in <parameter>shaders</parameter>. </para> </listitem>",
        "shaders": "<listitem> <para> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the shader binaries contained in <parameter>binary</parameter>. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array of bytes containing pre-compiled binary shader code. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the array whose address is given in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glShaderSource": {
      "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)",
      "purpose": "Replaces the source code in a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
        "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
        "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and back function and reference value for stencil testing",
      "parameters": {
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilFuncSeparate": {
      "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and/or back function and reference value for stencil testing",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. Stencil comparison operations and queries of <parameter>ref</parameter> clamp its value to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the front and back writing of individual bits in the stencil planes",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilMaskSeparate": {
      "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
      "purpose": "control the front and/or back writing of individual bits in the stencil planes",
      "parameters": {
        "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and back stencil test actions",
      "parameters": {
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glStencilOpSeparate": {
      "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and/or back stencil test actions",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage3D": {
      "signature": "void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be one of `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"> <msup><mi mathvariant=\"italic\">n</mi> <mi mathvariant=\"italic\">th</mi> </msup> </math></inlineequation> mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`, </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glTexStorage2D": {
      "signature": "void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "simultaneously specify storage for all levels of a two-dimensional texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_2D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage2DMultisample": {
      "signature": "void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be `GL_TEXTURE_2D_MULTISAMPLE`. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexStorage3D": {
      "signature": "void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)",
      "purpose": "simultaneously specify storage for all levels of a three-dimensional or two-dimensional array texture",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the operation. <parameter>target</parameter> must be one of `GL_TEXTURE_3D`, or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage3D": {
      "signature": "void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RED_INTEGER`, `GL_RG`, `GL_RG_INTEGER`, `GL_RGB`, `GL_RGB_INTEGER`, `GL_RGBA`, `GL_RGBA_INTEGER`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE`, and `GL_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, `GL_UNSIGNED_INT_24_8`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTransformFeedbackVaryings": {
      "signature": "void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode)",
      "purpose": "specify values to record in transform feedback buffers",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "count": "<listitem> <para> The number of varying variables used for transform feedback. </para> </listitem>",
        "varyings": "<listitem> <para> An array of <parameter>count</parameter> zero-terminated strings specifying the names of the varying variables to use for transform feedback. </para> </listitem>",
        "bufferMode": "<listitem> <para> Identifies the mode used to capture the varying variables when transform feedback is active. <parameter>bufferMode</parameter> must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`. </para> </listitem>"
      }
    },
    "glUniform1f": {
      "signature": "void glUniform1f(GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2f": {
      "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3f": {
      "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4f": {
      "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1i": {
      "signature": "void glUniform1i(GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2i": {
      "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3i": {
      "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4i": {
      "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1ui": {
      "signature": "void glUniform1ui(GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2ui": {
      "signature": "void glUniform2ui(GLint location, GLuint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3ui": {
      "signature": "void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4ui": {
      "signature": "void glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1fv": {
      "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2fv": {
      "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3fv": {
      "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4fv": {
      "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1iv": {
      "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2iv": {
      "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3iv": {
      "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4iv": {
      "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1uiv": {
      "signature": "void glUniform1uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2uiv": {
      "signature": "void glUniform2uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3uiv": {
      "signature": "void glUniform3uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4uiv": {
      "signature": "void glUniform4uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2fv": {
      "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3fv": {
      "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4fv": {
      "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x3fv": {
      "signature": "void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x2fv": {
      "signature": "void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x4fv": {
      "signature": "void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x2fv": {
      "signature": "void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x4fv": {
      "signature": "void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x3fv": {
      "signature": "void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformBlockBinding": {
      "signature": "void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)",
      "purpose": "assign a binding point to an active uniform block",
      "parameters": {
        "program": "<listitem> <para> The name of a program object containing the active uniform block whose binding to assign. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> The index of the active uniform block within <parameter>program</parameter> whose binding to assign. </para> </listitem>",
        "uniformBlockBinding": "<listitem> <para> Specifies the binding point to which to bind the uniform block with index <parameter>uniformBlockIndex</parameter> within <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glUseProgram": {
      "signature": "void glUseProgram(GLuint program)",
      "purpose": "Installs a program object as part of current rendering state",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
      }
    },
    "glUseProgramStages": {
      "signature": "void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)",
      "purpose": "bind stages of a program object to a program pipeline",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the program pipeline object to which to bind stages from <parameter>program</parameter>. </para> </listitem>",
        "stages": "<listitem> <para> Specifies a set of program stages to bind to the program pipeline object. </para> </listitem>",
        "program": "<listitem> <para> Specifies the program object containing the shader executables to use in <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glValidateProgram": {
      "signature": "void glValidateProgram(GLuint program)",
      "purpose": "Validates a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
      }
    },
    "glValidateProgramPipeline": {
      "signature": "void glValidateProgramPipeline(GLuint pipeline)",
      "purpose": "validate a program pipeline object against current GL state",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object to validate. </para> </listitem>"
      }
    },
    "glVertexAttrib1f": {
      "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2f": {
      "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3f": {
      "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4f": {
      "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4i": {
      "signature": "void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4ui": {
      "signature": "void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1fv": {
      "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2fv": {
      "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3fv": {
      "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4fv": {
      "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4iv": {
      "signature": "void glVertexAttribI4iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4uiv": {
      "signature": "void glVertexAttribI4uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribBinding": {
      "signature": "void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)",
      "purpose": "associate a vertex attribute and a vertex buffer binding",
      "parameters": {
        "attribindex": "<listitem> <para> The index of the attribute to associate with a vertex buffer binding. </para> </listitem>",
        "bindingindex": "<listitem> <para> The index of the vertex buffer binding with which to associate the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribDivisor": {
      "signature": "void glVertexAttribDivisor(GLuint index, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes advance during instanced rendering",
      "parameters": {
        "index": "<listitem> <para> Specify the index of the generic vertex attribute. </para> </listitem>",
        "divisor": "<listitem> <para> Specify the number of instances that will pass between updates of the generic attribute at slot <parameter>index</parameter>. </para> </listitem>"
      }
    },
    "glVertexAttribFormat": {
      "signature": "void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para> The generic vertex attribute array being described. </para> </listitem>",
        "size": "<listitem> <para> The number of values per vertex that are stored in the array. </para> </listitem>",
        "type": "<listitem> <para> The type of the data stored in the array. </para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para> An offset to the first element relative to the start of the vertex buffer binding. </para> </listitem>"
      }
    },
    "glVertexAttribIFormat": {
      "signature": "void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para> The generic vertex attribute array being described. </para> </listitem>",
        "size": "<listitem> <para> The number of values per vertex that are stored in the array. </para> </listitem>",
        "type": "<listitem> <para> The type of the data stored in the array. </para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para> An offset to the first element relative to the start of the vertex buffer binding. </para> </listitem>"
      }
    },
    "glVertexAttribPointer": {
      "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0. </para> </listitem>"
      }
    },
    "glVertexAttribIPointer": {
      "signature": "void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by both functions. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted by <function>glVertexAttribPointer</function>. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`.</para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the `GL_ARRAY_BUFFER` target, <parameter>pointer</parameter> specifies an offset of into the array in the data store of that buffer. The initial value is 0. </para> </listitem>"
      }
    },
    "glVertexBindingDivisor": {
      "signature": "void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes advance",
      "parameters": {
        "bindingindex": "<listitem> <para> The index of the binding whose divisor to modify. </para> </listitem>",
        "divisor": "<listitem> <para> The new value for the instance step rate to apply. </para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glWaitSync": {
      "signature": "void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "instruct the GL server to block until the specified sync object becomes signaled",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> must be zero. </para> </listitem>",
        "timeout": "<listitem> <para> Specifies the timeout that the server should wait before continuing. <parameter>timeout</parameter> must be `GL_TIMEOUT_IGNORED`. </para> </listitem>"
      }
    },
    "greaterThan": {
      "signature": "bvec greaterThan(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "greaterThanEqual": {
      "signature": "bvec greaterThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "groupMemoryBarrier": {
      "signature": "void groupMemoryBarrier(void)",
      "purpose": "controls the ordering of memory transaction issued shader invocation relative to a work group",
      "parameters": {}
    },
    "imageLoad": {
      "signature": "gvec4 imageLoad(gimage2DArray image, ivec3 P)",
      "purpose": "load a single texel from an image",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit from which to load a texel. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate from which to load the texel. </para> </listitem>"
      }
    },
    "imageSize": {
      "signature": "ivec3 imageSize(gimage2DArray image)",
      "purpose": "retrieve the dimensions of an image",
      "parameters": {
        "image": "<listitem> <para> Specifies the image to which the texture whose dimensions to retrieve is bound. </para> </listitem>"
      }
    },
    "imageStore": {
      "signature": "void imageStore(gimage2DArray image, ivec3 P, gvec4 data)",
      "purpose": "write a single texel into an image",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store a texel. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the texel. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to store into the image. </para> </listitem>"
      }
    },
    "intBitsToFloat": {
      "signature": "genType intBitsToFloat(genIType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "uintBitsToFloat": {
      "signature": "genType uintBitsToFloat(genUType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "inverse": {
      "signature": "mat4 inverse(mat4 m)",
      "purpose": "calculate the inverse of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the inverse. </para> </listitem>"
      }
    },
    "inversesqrt": {
      "signature": "genType inversesqrt(genType x)",
      "purpose": "return the inverse of the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the inverse of the square root. </para> </listitem>"
      }
    },
    "isinf": {
      "signature": "genBType isinf(genType x)",
      "purpose": "determine whether the parameter is positive or negative infinity",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for infinity. </para> </listitem>"
      }
    },
    "isnan": {
      "signature": "genBType isnan(genType x)",
      "purpose": "determine whether the parameter is a number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for NaN. </para> </listitem>"
      }
    },
    "ldexp": {
      "signature": "genType ldexp(genType x, genIType exp)",
      "purpose": "assemble a floating point number from a value and exponent",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used as a source of significand. </para> </listitem>",
        "exp": "<listitem> <para> Specifies the value to be used as a source of exponent. </para> </listitem>"
      }
    },
    "length": {
      "signature": "float length(genType x)",
      "purpose": "calculate the length of a vector",
      "parameters": {
        "x": "<listitem> <para> Specifies a vector of which to calculate the length. </para> </listitem>"
      }
    },
    "lessThan": {
      "signature": "bvec lessThan(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "lessThanEqual": {
      "signature": "bvec lessThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "log": {
      "signature": "genType log(genType x)",
      "purpose": "return the natural logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the natural logarithm. </para> </listitem>"
      }
    },
    "log2": {
      "signature": "genType log2(genType x)",
      "purpose": "return the base 2 logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the base 2 logarithm. </para> </listitem>"
      }
    },
    "matrixCompMult": {
      "signature": "mat matrixCompMult(mat x, mat y)",
      "purpose": "perform a component-wise multiplication of two matrices",
      "parameters": {
        "x": "<listitem> <para> Specifies the first matrix multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second matrix multiplicand. </para> </listitem>"
      }
    },
    "max": {
      "signature": "genUType max(genUType x, uint y)",
      "purpose": "return the greater of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "memoryBarrier": {
      "signature": "void memoryBarrier(void)",
      "purpose": "controls the ordering of memory transactions issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierAtomicCounter": {
      "signature": "void memoryBarrierAtomicCounter(void)",
      "purpose": "controls the ordering of operations on atomic counters issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierBuffer": {
      "signature": "void memoryBarrierBuffer(void)",
      "purpose": "controls the ordering of operations on buffer variables issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierImage": {
      "signature": "void memoryBarrierImage(void)",
      "purpose": "controls the ordering of operations on image variables issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierShared": {
      "signature": "void memoryBarrierShared(void)",
      "purpose": "controls the ordering of operations on shared variables issued by a single shader invocation",
      "parameters": {}
    },
    "min": {
      "signature": "genUType min(genUType x, uint y)",
      "purpose": "return the lesser of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "mix": {
      "signature": "genType mix(genType x, genType y, genBType a)",
      "purpose": "linearly interpolate between two values",
      "parameters": {
        "x": "<listitem> <para> Specify the start of the range in which to interpolate. </para> </listitem>",
        "y": "<listitem> <para> Specify the end of the range in which to interpolate. </para> </listitem>",
        "a": "<listitem> <para> Specify the value to use to interpolate between <parameter>x</parameter> and <parameter>y</parameter>. </para> </listitem>"
      }
    },
    "mod": {
      "signature": "genType mod(genType x, genType y)",
      "purpose": "compute value of one parameter modulo another",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>",
        "y": "<listitem> <para> Specify the value by which to perform the modulo. </para> </listitem>"
      }
    },
    "modf": {
      "signature": "genType modf(genType x, out genType i)",
      "purpose": "separate a value into its integer and fractional components",
      "parameters": {
        "x": "<listitem> <para> Specify the value to separate. </para> </listitem>",
        "out i": "<listitem> <para> A variable that receives the integer part of the argument. </para> </listitem>"
      }
    },
    "normalize": {
      "signature": "genType normalize(genType v)",
      "purpose": "calculates the unit vector in the same direction as the original vector",
      "parameters": {
        "v": "<listitem> <para> Specifies the vector to normalize. </para> </listitem>"
      }
    },
    "not": {
      "signature": "bvec not(bvec x)",
      "purpose": "logically invert a boolean vector",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be inverted. </para> </listitem>"
      }
    },
    "notEqual": {
      "signature": "bvec notEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise not-equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "outerProduct": {
      "signature": "mat4x3 outerProduct(vec3 c, vec4 r)",
      "purpose": "calculate the outer product of a pair of vectors",
      "parameters": {
        "c": "<listitem> <para> Specifies the parameter to be treated as a column vector. </para> </listitem>",
        "r": "<listitem> <para> Specifies the parameter to be treated as a row vector. </para> </listitem>"
      }
    },
    "packHalf2x16": {
      "signature": "uint packHalf2x16(vec2 v)",
      "purpose": "convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer",
      "parameters": {
        "v": "<listitem> <para> Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result. </para> </listitem>"
      }
    },
    "packUnorm2x16": {
      "signature": "uint packUnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm2x16": {
      "signature": "uint packSnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packUnorm4x8": {
      "signature": "uint packUnorm4x8(vec4 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm4x8": {
      "signature": "uint packSnorm4x8(vec4 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "pow": {
      "signature": "genType pow(genType x, genType y)",
      "purpose": "return the value of the first parameter raised to the power of the second",
      "parameters": {
        "x": "<listitem> <para> Specify the value to raise to the power <parameter>y</parameter>. </para> </listitem>",
        "y": "<listitem> <para> Specify the power to which to raise <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "radians": {
      "signature": "genType radians(genType degrees)",
      "purpose": "convert a quantity in degrees to radians",
      "parameters": {
        "degrees": "<listitem> <para> Specify the quantity, in degrees, to be converted to radians. </para> </listitem>"
      }
    },
    "reflect": {
      "signature": "genType reflect(genType I, genType N)",
      "purpose": "calculate the reflection direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>"
      }
    },
    "refract": {
      "signature": "genType refract(genType I, genType N, float eta)",
      "purpose": "calculate the refraction direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>",
        "eta": "<listitem> <para> Specifies the ratio of indices of refraction. </para> </listitem>"
      }
    },
    "round": {
      "signature": "genType round(genType x)",
      "purpose": "find the nearest integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "roundEven": {
      "signature": "genType roundEven(genType x)",
      "purpose": "find the nearest even integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "sign": {
      "signature": "genIType sign(genIType x)",
      "purpose": "extract the sign of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value from which to extract the sign. </para> </listitem>"
      }
    },
    "sin": {
      "signature": "genType sin(genType angle)",
      "purpose": "return the sine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the sine. </para> </listitem>"
      }
    },
    "sinh": {
      "signature": "genType sinh(genType x)",
      "purpose": "return the hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic sine to return. </para> </listitem>"
      }
    },
    "smoothstep": {
      "signature": "genType smoothstep(float edge0, float edge1, genType x)",
      "purpose": "perform Hermite interpolation between two values",
      "parameters": {
        "edge0": "<listitem> <para> Specifies the value of the lower edge of the Hermite function. </para> </listitem>",
        "edge1": "<listitem> <para> Specifies the value of the upper edge of the Hermite function. </para> </listitem>",
        "x": "<listitem> <para> Specifies the source value for interpolation. </para> </listitem>"
      }
    },
    "sqrt": {
      "signature": "genType sqrt(genType x)",
      "purpose": "return the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the square root. </para> </listitem>"
      }
    },
    "step": {
      "signature": "genType step(float edge, genType x)",
      "purpose": "generate a step function by comparing two values",
      "parameters": {
        "edge": "<listitem> <para> Specifies the location of the edge of the step function. </para> </listitem>",
        "x": "<listitem> <para> Specify the value to be used to generate the step function. </para> </listitem>"
      }
    },
    "tan": {
      "signature": "genType tan(genType angle)",
      "purpose": "return the tangent of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the tangent. </para> </listitem>"
      }
    },
    "tanh": {
      "signature": "genType tanh(genType x)",
      "purpose": "return the hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "texelFetch": {
      "signature": "gvec4 texelFetch(gsampler2DMS sampler, ivec2 P, int sample)",
      "purpose": "perform a lookup of a single texel within a texture",
      "parameters": {
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "sample": "<listitem> <para> For multisampled fetches, specifies which sample within the texel from which the data will be returned. </para> </listitem>"
      }
    },
    "texelFetchOffset": {
      "signature": "gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)",
      "purpose": "perform a lookup of a single texel within a texture with an offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>"
      }
    },
    "texture": {
      "signature": "float texture(sampler2DArrayShadow sampler, vec4 P)",
      "purpose": "retrieves texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureGather": {
      "signature": "vec4 textureGather(samplerCubeShadow sampler, vec3 P, float refZ)",
      "purpose": "gathers four texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>"
      }
    },
    "textureGatherOffset": {
      "signature": "vec4 textureGatherOffset(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset)",
      "purpose": "gathers four texels from a texture with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset from the specified texture coordinate <parameter>P</parameter> from which the texels will be gathered. </para> </listitem>"
      }
    },
    "textureGrad": {
      "signature": "float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
      "purpose": "perform a texture lookup with explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureGradOffset": {
      "signature": "float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset to be applied to the texture coordinates before sampling. </para> </listitem>"
      }
    },
    "textureLod": {
      "signature": "gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)",
      "purpose": "perform a texture lookup with explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail </para> </listitem>"
      }
    },
    "textureLodOffset": {
      "signature": "gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which texels will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that will be applied to <parameter>P</parameter> before texels are fetched. </para> </listitem>"
      }
    },
    "textureOffset": {
      "signature": "gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias)",
      "purpose": "perform a texture lookup with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProj": {
      "signature": "float textureProj(sampler2DShadow sampler, vec4 P, [float bias)",
      "purpose": "perform a texture lookup with projection",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProjGrad": {
      "signature": "float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)",
      "purpose": "perform a texture lookup with projection and explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureProjGradOffset": {
      "signature": "float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with projection, explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offsets, in texels at which the texture will be sampled relative to the projection of <parameter>P</parameter>. </para> </listitem>"
      }
    },
    "textureProjLod": {
      "signature": "float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>"
      }
    },
    "textureProjLodOffset": {
      "signature": "float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset, in texels, to be applied to <parameter>P</parameter> before fetching texels. </para> </listitem>"
      }
    },
    "textureProjOffset": {
      "signature": "float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias)",
      "purpose": "perform a texture lookup with projection and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that is applied to <parameter>P</parameter> before sampling occurs. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureSize": {
      "signature": "ivec2 textureSize(sampler2DMS sampler)",
      "purpose": "retrieve the dimensions of a level of a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture whose dimensions to retrieve is bound. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the level of the texture for which to retrieve the dimensions. </para> </listitem>"
      }
    },
    "transpose": {
      "signature": "mat4x3 transpose(mat3x4 m)",
      "purpose": "calculate the transpose of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the transpose. </para> </listitem>"
      }
    },
    "trunc": {
      "signature": "genType trunc(genType x)",
      "purpose": "find the truncated value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "uaddCarry": {
      "signature": "genUType uaddCarry(genUType x, genUType y, out genUType carry)",
      "purpose": "add unsigned integers and generate carry",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the summation operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the summation operation. </para> </listitem>",
        "carry": "<listitem> <para> Specifies the variable to receive the carry output of the sum. </para> </listitem>"
      }
    },
    "umulExtended": {
      "signature": "void umulExtended(genUType x, genUType y, out genUType msb, out genUType lsb)",
      "purpose": "perform a 32- by 32-bit multiply to produce a 64-bit result",
      "parameters": {
        "x": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second multiplicand.. </para> </listitem>",
        "msb": "<listitem> <para> Specifies the variable to receive the most significant word of the product. </para> </listitem>",
        "lsb": "<listitem> <para> Specifies the variable to receive the least significant word of the product. </para> </listitem>"
      }
    },
    "imulExtended": {
      "signature": "void imulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)",
      "purpose": "perform a 32- by 32-bit multiply to produce a 64-bit result",
      "parameters": {
        "x": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second multiplicand.. </para> </listitem>",
        "msb": "<listitem> <para> Specifies the variable to receive the most significant word of the product. </para> </listitem>",
        "lsb": "<listitem> <para> Specifies the variable to receive the least significant word of the product. </para> </listitem>"
      }
    },
    "unpackHalf2x16": {
      "signature": "vec2 unpackHalf2x16(uint v)",
      "purpose": "convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities",
      "parameters": {
        "v": "<listitem> <para> Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked. </para> </listitem>"
      }
    },
    "unpackUnorm2x16": {
      "signature": "vec2 unpackUnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm2x16": {
      "signature": "vec2 unpackSnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackUnorm4x8": {
      "signature": "vec2 unpackUnorm4x8(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm4x8": {
      "signature": "vec2 unpackSnorm4x8(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "usubBorrow": {
      "signature": "genUType usubBorrow(genUType x, genUType y, out genUType borrow)",
      "purpose": "subtract unsigned integers and generate borrow",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the subtraction operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the subtraction operation. </para> </listitem>",
        "borrow": "<listitem> <para> Specifies the variable to receive the borrow output of the difference. </para> </listitem>"
      }
    }
  },
  "gl2.1": {
    "glAccum": {
      "signature": "void glAccum(GLenum op, GLfloat value)",
      "purpose": "operate on the accumulation buffer",
      "parameters": {
        "op": "<listitem> <para> Specifies the accumulation buffer operation. Symbolic constants `GL_ACCUM`, `GL_LOAD`, `GL_ADD`, `GL_MULT`, and `GL_RETURN` are accepted. </para> </listitem>",
        "value": "<listitem> <para> Specifies a floating-point value used in the accumulation buffer operation. <parameter>op</parameter> determines how <parameter>value</parameter> is used. </para> </listitem>"
      }
    },
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. <parameter>texture</parameter> must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to the larger of (`GL_MAX_TEXTURE_COORDS` - 1) and (`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` - 1). The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAlphaFunc": {
      "signature": "void glAlphaFunc(GLenum func, GLclampf ref)",
      "purpose": "specify the alpha test function",
      "parameters": {
        "func": "<listitem> <para> Specifies the alpha comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>, where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0. </para> </listitem>"
      }
    },
    "glAreTexturesResident": {
      "signature": "GLboolean glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences)",
      "purpose": "determine if textures are loaded in texture memory",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be queried. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array containing the names of the textures to be queried. </para> </listitem>",
        "residences": "<listitem> <para> Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of <parameter>textures</parameter> is returned in the corresponding element of <parameter>residences</parameter>. </para> </listitem>"
      }
    },
    "glArrayElement": {
      "signature": "void glArrayElement(GLint i)",
      "purpose": "render a vertex using the specified vertex array element",
      "parameters": {
        "i": "<listitem> <para> Specifies an index into the enabled vertex data arrays. </para> </listitem>"
      }
    },
    "glAttachShader": {
      "signature": "void glAttachShader(GLuint program, GLuint shader)",
      "purpose": "Attaches a shader object to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
      }
    },
    "glBegin": {
      "signature": "void glBegin(GLenum mode)",
      "purpose": "delimit the vertices of a primitive or a group of like primitives",
      "parameters": {
        "mode": "<listitem> <para> Specifies the primitive or primitives that will be created from vertices presented between <function>glBegin</function> and the subsequent <citerefentry><refentrytitle>glEnd</refentrytitle></citerefentry>. Ten symbolic constants are accepted: `GL_POINTS`, `GL_LINES`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_QUADS`, `GL_QUAD_STRIP`, and `GL_POLYGON`. </para> </listitem>"
      }
    },
    "glEnd": {
      "signature": "void glEnd(void)",
      "purpose": "delimit the vertices of a primitive or a group of like primitives",
      "parameters": {
        "mode": "<listitem> <para> Specifies the primitive or primitives that will be created from vertices presented between <function>glBegin</function> and the subsequent <citerefentry><refentrytitle>glEnd</refentrytitle></citerefentry>. Ten symbolic constants are accepted: `GL_POINTS`, `GL_LINES`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_QUADS`, `GL_QUAD_STRIP`, and `GL_POLYGON`. </para> </listitem>"
      }
    },
    "glBeginQuery": {
      "signature": "void glBeginQuery(GLenum target, GLuint id)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <citerefentry><refentrytitle>glEndQuery</refentrytitle></citerefentry>. The symbolic constant must be `GL_SAMPLES_PASSED`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glEndQuery": {
      "signature": "void glEndQuery(GLenum target)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <citerefentry><refentrytitle>glEndQuery</refentrytitle></citerefentry>. The symbolic constant must be `GL_SAMPLES_PASSED`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glBindAttribLocation": {
      "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
      "purpose": "Associates a generic vertex attribute index with a named attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
        "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound. Must be either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBitmap": {
      "signature": "void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap)",
      "purpose": "draw a bitmap",
      "parameters": {
        "width": "<listitem> <para> Specify the pixel width and height of the bitmap image. </para> </listitem>",
        "xorig": "<listitem> <para> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </para> </listitem>",
        "xmove": "<listitem> <para> Specify the <emphasis>x</emphasis> and <emphasis>y</emphasis> offsets to be added to the current raster position after the bitmap is drawn. </para> </listitem>",
        "bitmap": "<listitem> <para> Specifies the address of the bitmap image. </para> </listitem>"
      }
    },
    "glBlendColor": {
      "signature": "void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)",
      "purpose": "set the blend color",
      "parameters": {
        "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
      }
    },
    "glBlendEquation": {
      "signature": "void glBlendEquation(GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparate": {
      "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, and `GL_SRC_ALPHA_SATURATE`. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparate": {
      "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, and `GL_SRC_ALPHA_SATURATE`. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for <parameter>srcRGB</parameter>. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for <parameter>dstRGB</parameter>. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the buffer object's new data store. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied. </para> </listitem>",
        "usage": "<listitem> <para> Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`. </para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "updates a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glCallList": {
      "signature": "void glCallList(GLuint list)",
      "purpose": "execute a display list",
      "parameters": {
        "list": "<listitem> <para> Specifies the integer name of the display list to be executed. </para> </listitem>"
      }
    },
    "glCallLists": {
      "signature": "void glCallLists(GLsizei n, GLenum type, const void * lists)",
      "purpose": "execute a list of display lists",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of display lists to be executed. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of values in <parameter>lists</parameter>. Symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_FLOAT`, `GL_2_BYTES`, `GL_3_BYTES`, and `GL_4_BYTES` are accepted. </para> </listitem>",
        "lists": "<listitem> <para> Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of <parameter>type</parameter>. </para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The four masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, `GL_ACCUM_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
      }
    },
    "glClearAccum": {
      "signature": "void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "specify clear values for the accumulation buffer",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)",
      "purpose": "specify clear values for the color buffers",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearDepth": {
      "signature": "void glClearDepth(GLclampd depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearIndex": {
      "signature": "void glClearIndex(GLfloat c)",
      "purpose": "specify the clear value for the color index buffers",
      "parameters": {
        "c": "<listitem> <para> Specifies the index used when the color index buffers are cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glClientActiveTexture": {
      "signature": "void glClientActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. <parameter>texture</parameter> must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to the value of `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glClipPlane": {
      "signature": "void glClipPlane(GLenum plane, const GLdouble * equation)",
      "purpose": "specify a plane against which all geometry is clipped",
      "parameters": {
        "plane": "<listitem> <para> Specifies which clipping plane is being positioned. Symbolic names of the form `GL_CLIP_PLANE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> is an integer between 0 and `GL_MAX_CLIP_PLANES` <inlineequation><math> <mn>-1</mn> </math></inlineequation>, are accepted. </para> </listitem>",
        "equation": "<listitem> <para> Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation. </para> </listitem>"
      }
    },
    "glColor3b": {
      "signature": "void glColor3b(GLbyte red, GLbyte green, GLbyte blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3s": {
      "signature": "void glColor3s(GLshort red, GLshort green, GLshort blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3i": {
      "signature": "void glColor3i(GLint red, GLint green, GLint blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3f": {
      "signature": "void glColor3f(GLfloat red, GLfloat green, GLfloat blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3d": {
      "signature": "void glColor3d(GLdouble red, GLdouble green, GLdouble blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3ub": {
      "signature": "void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3us": {
      "signature": "void glColor3us(GLushort red, GLushort green, GLushort blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3ui": {
      "signature": "void glColor3ui(GLuint red, GLuint green, GLuint blue)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4b": {
      "signature": "void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4s": {
      "signature": "void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4i": {
      "signature": "void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4f": {
      "signature": "void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4d": {
      "signature": "void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4ub": {
      "signature": "void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4us": {
      "signature": "void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4ui": {
      "signature": "void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3bv": {
      "signature": "void glColor3bv(const GLbyte * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3sv": {
      "signature": "void glColor3sv(const GLshort * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3iv": {
      "signature": "void glColor3iv(const GLint * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3fv": {
      "signature": "void glColor3fv(const GLfloat * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3dv": {
      "signature": "void glColor3dv(const GLdouble * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3ubv": {
      "signature": "void glColor3ubv(const GLubyte * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3usv": {
      "signature": "void glColor3usv(const GLushort * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor3uiv": {
      "signature": "void glColor3uiv(const GLuint * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4bv": {
      "signature": "void glColor4bv(const GLbyte * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4sv": {
      "signature": "void glColor4sv(const GLshort * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4iv": {
      "signature": "void glColor4iv(const GLint * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4fv": {
      "signature": "void glColor4fv(const GLfloat * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4dv": {
      "signature": "void glColor4dv(const GLdouble * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4ubv": {
      "signature": "void glColor4ubv(const GLubyte * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4usv": {
      "signature": "void glColor4usv(const GLushort * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColor4uiv": {
      "signature": "void glColor4uiv(const GLuint * v)",
      "purpose": "set the current color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current color. </para> </listitem>",
        "alpha": "<listitem> <para> Specifies a new alpha value for the current color. Included only in the four-argument <function>glColor4</function> commands. </para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha can or cannot be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components can be written. </para> </listitem>"
      }
    },
    "glColorMaterial": {
      "signature": "void glColorMaterial(GLenum face, GLenum mode)",
      "purpose": "cause a material color to track the current color",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. The initial value is `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mode": "<listitem> <para> Specifies which of several material parameters track the current color. Accepted values are `GL_EMISSION`, `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, and `GL_AMBIENT_AND_DIFFUSE`. The initial value is `GL_AMBIENT_AND_DIFFUSE`. </para> </listitem>"
      }
    },
    "glColorPointer": {
      "signature": "void glColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of colors",
      "parameters": {
        "size": "<listitem> <para> Specifies the number of components per color. Must be 3 or 4. The initial value is 4. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of each color component in the array. Symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_FLOAT`, and `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive colors. If <parameter>stride</parameter> is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glColorSubTable": {
      "signature": "void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data)",
      "purpose": "respecify a portion of a color table",
      "parameters": {
        "target": "<listitem> <para> Must be one of `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, or `GL_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "start": "<listitem> <para> The starting index of the portion of the color table to be replaced. </para> </listitem>",
        "count": "<listitem> <para> The number of table entries to replace. </para> </listitem>",
        "format": "<listitem> <para> The format of the pixel data in <parameter>data</parameter>. The allowable values are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`. </para> </listitem>",
        "type": "<listitem> <para> The type of the pixel data in <parameter>data</parameter>. The allowable values are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table. </para> </listitem>"
      }
    },
    "glColorTable": {
      "signature": "void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * data)",
      "purpose": "define a color lookup table",
      "parameters": {
        "target": "<listitem> <para> Must be one of `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, `GL_POST_COLOR_MATRIX_COLOR_TABLE`, `GL_PROXY_COLOR_TABLE`, `GL_PROXY_POST_CONVOLUTION_COLOR_TABLE`, or `GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format of the color table. The allowable values are `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, and `GL_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> The number of entries in the color lookup table specified by <parameter>data</parameter>. </para> </listitem>",
        "format": "<listitem> <para> The format of the pixel data in <parameter>data</parameter>. The allowable values are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`. </para> </listitem>",
        "type": "<listitem> <para> The type of the pixel data in <parameter>data</parameter>. The allowable values are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Pointer to a one-dimensional array of pixel data that is processed to build the color table. </para> </listitem>"
      }
    },
    "glColorTableParameterfv": {
      "signature": "void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set color lookup table parameters",
      "parameters": {
        "target": "<listitem> <para> The target color table. Must be `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, or `GL_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "pname": "<listitem> <para> The symbolic name of a texture color lookup table parameter. Must be one of `GL_COLOR_TABLE_SCALE` or `GL_COLOR_TABLE_BIAS`. </para> </listitem>",
        "params": "<listitem> <para> A pointer to an array where the values of the parameters are stored. </para> </listitem>"
      }
    },
    "glColorTableParameteriv": {
      "signature": "void glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set color lookup table parameters",
      "parameters": {
        "target": "<listitem> <para> The target color table. Must be `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, or `GL_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "pname": "<listitem> <para> The symbolic name of a texture color lookup table parameter. Must be one of `GL_COLOR_TABLE_SCALE` or `GL_COLOR_TABLE_BIAS`. </para> </listitem>",
        "params": "<listitem> <para> A pointer to an array where the values of the parameters are stored. </para> </listitem>"
      }
    },
    "glCompileShader": {
      "signature": "void glCompileShader(GLuint shader)",
      "purpose": "Compiles a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
      }
    },
    "glCompressedTexImage1D": {
      "signature": "void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a one-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be Must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage3D": {
      "signature": "void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support 3D texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support 3D texture images that are at least 16 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support 3D texture images that are at least 16 texels deep. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage1D": {
      "signature": "void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a one-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage3D": {
      "signature": "void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glConvolutionFilter1D": {
      "signature": "void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * data)",
      "purpose": "define a one-dimensional convolution filter",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_CONVOLUTION_1D`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format of the convolution filter kernel. The allowable values are `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> The width of the pixel array referenced by <parameter>data</parameter>. </para> </listitem>",
        "format": "<listitem> <para> The format of the pixel data in <parameter>data</parameter>. The allowable values are `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_INTENSITY`, `GL_RGB`, and `GL_RGBA`. </para> </listitem>",
        "type": "<listitem> <para> The type of the pixel data in <parameter>data</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "data": "<listitem> <para> Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel. </para> </listitem>"
      }
    },
    "glConvolutionFilter2D": {
      "signature": "void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "define a two-dimensional convolution filter",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_CONVOLUTION_2D`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format of the convolution filter kernel. The allowable values are `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> The width of the pixel array referenced by <parameter>data</parameter>. </para> </listitem>",
        "height": "<listitem> <para> The height of the pixel array referenced by <parameter>data</parameter>. </para> </listitem>",
        "format": "<listitem> <para> The format of the pixel data in <parameter>data</parameter>. The allowable values are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> The type of the pixel data in <parameter>data</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "data": "<listitem> <para> Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel. </para> </listitem>"
      }
    },
    "glConvolutionParameterf": {
      "signature": "void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)",
      "purpose": "set convolution parameters",
      "parameters": {
        "target": "<listitem> <para> The target for the convolution parameter. Must be one of `GL_CONVOLUTION_1D`, `GL_CONVOLUTION_2D`, or `GL_SEPARABLE_2D`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be set. Must be `GL_CONVOLUTION_BORDER_MODE`. </para> </listitem>",
        "params": "<listitem> <para> The parameter value. Must be one of `GL_REDUCE`, `GL_CONSTANT_BORDER`, `GL_REPLICATE_BORDER`. </para> <para> </para> </listitem>"
      }
    },
    "glConvolutionParameteri": {
      "signature": "void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)",
      "purpose": "set convolution parameters",
      "parameters": {
        "target": "<listitem> <para> The target for the convolution parameter. Must be one of `GL_CONVOLUTION_1D`, `GL_CONVOLUTION_2D`, or `GL_SEPARABLE_2D`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be set. Must be `GL_CONVOLUTION_BORDER_MODE`. </para> </listitem>",
        "params": "<listitem> <para> The parameter value. Must be one of `GL_REDUCE`, `GL_CONSTANT_BORDER`, `GL_REPLICATE_BORDER`. </para> <para> </para> </listitem>"
      }
    },
    "glConvolutionParameterfv": {
      "signature": "void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set convolution parameters",
      "parameters": {
        "target": "<listitem> <para> The target for the convolution parameter. Must be one of `GL_CONVOLUTION_1D`, `GL_CONVOLUTION_2D`, or `GL_SEPARABLE_2D`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be set. Must be `GL_CONVOLUTION_BORDER_MODE`. </para> </listitem>",
        "params": "<listitem> <para> The parameter value. Must be one of `GL_REDUCE`, `GL_CONSTANT_BORDER`, `GL_REPLICATE_BORDER`. </para> <para> </para> </listitem>"
      }
    },
    "glConvolutionParameteriv": {
      "signature": "void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set convolution parameters",
      "parameters": {
        "target": "<listitem> <para> The target for the convolution parameter. Must be one of `GL_CONVOLUTION_1D`, `GL_CONVOLUTION_2D`, or `GL_SEPARABLE_2D`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be set. Must be `GL_CONVOLUTION_BORDER_MODE`. </para> </listitem>",
        "params": "<listitem> <para> The parameter value. Must be one of `GL_REDUCE`, `GL_CONSTANT_BORDER`, `GL_REPLICATE_BORDER`. </para> <para> </para> </listitem>"
      }
    },
    "glCopyColorSubTable": {
      "signature": "void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)",
      "purpose": "respecify a portion of a color table",
      "parameters": {
        "target": "<listitem> <para> Must be one of `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, or `GL_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "start": "<listitem> <para> The starting index of the portion of the color table to be replaced. </para> </listitem>",
        "x": "<listitem> <para> The window coordinates of the left corner of the row of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> The number of table entries to replace. </para> </listitem>"
      }
    },
    "glCopyColorTable": {
      "signature": "void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)",
      "purpose": "copy pixels into a color table",
      "parameters": {
        "target": "<listitem> <para> The color table target. Must be `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, or `GL_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal storage format of the texture image. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "x": "<listitem> <para> The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </para> </listitem>",
        "y": "<listitem> <para> The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </para> </listitem>",
        "width": "<listitem> <para> The width of the pixel rectangle. </para> </listitem>"
      }
    },
    "glCopyConvolutionFilter1D": {
      "signature": "void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)",
      "purpose": "copy pixels into a one-dimensional convolution filter",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_CONVOLUTION_1D`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format of the convolution filter kernel. The allowable values are `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "x": "<listitem> <para> The window space coordinates of the lower-left coordinate of the pixel array to copy. </para> </listitem>",
        "width": "<listitem> <para> The width of the pixel array to copy. </para> </listitem>"
      }
    },
    "glCopyConvolutionFilter2D": {
      "signature": "void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy pixels into a two-dimensional convolution filter",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_CONVOLUTION_2D`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format of the convolution filter kernel. The allowable values are `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "x": "<listitem> <para> The window space coordinates of the lower-left coordinate of the pixel array to copy. </para> </listitem>",
        "width": "<listitem> <para> The width of the pixel array to copy. </para> </listitem>",
        "height": "<listitem> <para> The height of the pixel array to copy. </para> </listitem>"
      }
    },
    "glCopyPixels": {
      "signature": "void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)",
      "purpose": "copy pixels in the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </para> </listitem>",
        "type": "<listitem> <para> Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants `GL_COLOR`, `GL_DEPTH`, and `GL_STENCIL` are accepted. </para> </listitem>"
      }
    },
    "glCopyTexImage1D": {
      "signature": "void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)",
      "purpose": "copy pixels into a 1D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_COMPRESSED_ALPHA`, `GL_COMPRESSED_LUMINANCE`, `GL_COMPRESSED_LUMINANCE_ALPHA`, `GL_COMPRESSED_INTENSITY`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SLUMINANCE`, `GL_SLUMINANCE8`, `GL_SLUMINANCE_ALPHA`, `GL_SLUMINANCE8_ALPHA8`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the left corner of the row of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. Must be 0 or <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. The height of the texture image is 1. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "copy pixels into a 2D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_COMPRESSED_ALPHA`, `GL_COMPRESSED_LUMINANCE`, `GL_COMPRESSED_LUMINANCE_ALPHA`, `GL_COMPRESSED_INTENSITY`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SLUMINANCE`, `GL_SLUMINANCE8`, `GL_SLUMINANCE_ALPHA`, `GL_SLUMINANCE8_ALPHA8`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. Must be 0 or <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. Must be 0 or <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">m</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">m</mi></math></inlineequation>. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>"
      }
    },
    "glCopyTexSubImage1D": {
      "signature": "void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)",
      "purpose": "copy a one-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies the texel offset within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the left corner of the row of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCopyTexSubImage3D": {
      "signature": "void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>"
      }
    },
    "glCreateProgram": {
      "signature": "GLuint glCreateProgram(void)",
      "purpose": "Creates a program object",
      "parameters": {}
    },
    "glCreateShader": {
      "signature": "GLuint glCreateShader(GLenum shaderType)",
      "purpose": "Creates a shader object",
      "parameters": {
        "shaderType": "<listitem> <para>Specifies the type of shader to be created. Must be either `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.</para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing facets can be culled",
      "parameters": {
        "mode": "<listitem> <para> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteLists": {
      "signature": "void glDeleteLists(GLuint list, GLsizei range)",
      "purpose": "delete a contiguous group of display lists",
      "parameters": {
        "list": "<listitem> <para> Specifies the integer name of the first display list to delete. </para> </listitem>",
        "range": "<listitem> <para> Specifies the number of display lists to delete. </para> </listitem>"
      }
    },
    "glDeleteProgram": {
      "signature": "void glDeleteProgram(GLuint program)",
      "purpose": "Deletes a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteQueries": {
      "signature": "void glDeleteQueries(GLsizei n, const GLuint * ids)",
      "purpose": "delete named query objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query objects to be deleted. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of query objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteShader": {
      "signature": "void glDeleteShader(GLuint shader)",
      "purpose": "Deletes a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
      }
    },
    "glDepthRange": {
      "signature": "void glDepthRange(GLclampd nearVal, GLclampd farVal)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "nearVal": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "farVal": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDetachShader": {
      "signature": "void glDetachShader(GLuint program, GLuint shader)",
      "purpose": "Detaches a shader object from a program object to which it is attached",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_QUAD_STRIP`, `GL_QUADS`, and `GL_POLYGON` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawBuffer": {
      "signature": "void glDrawBuffer(GLenum mode)",
      "purpose": "specify which color buffers are to be drawn into",
      "parameters": {
        "mode": "<listitem> <para> Specifies up to four color buffers to be drawn into. Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, `GL_FRONT_AND_BACK`, and `GL_AUX`<emphasis>i</emphasis>, where <emphasis>i</emphasis> is between 0 and the value of `GL_AUX_BUFFERS` minus 1, are accepted. (`GL_AUX_BUFFERS` is not the upper limit; use <citerefentry><refentrytitle>glGet</refentrytitle></citerefentry> to query the number of available aux buffers.) The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for double-buffered contexts. </para> </listitem>"
      }
    },
    "glDrawBuffers": {
      "signature": "void glDrawBuffers(GLsizei n, const GLenum *bufs)",
      "purpose": "Specifies a list of color buffers to be drawn into",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
        "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_QUAD_STRIP`, `GL_QUADS`, and `GL_POLYGON` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawPixels": {
      "signature": "void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "write a block of pixels to the frame buffer",
      "parameters": {
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Symbolic constants `GL_COLOR_INDEX`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA` are accepted. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the pixel data. </para> </listitem>"
      }
    },
    "glDrawRangeElements": {
      "signature": "void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_QUAD_STRIP`, `GL_QUADS`, and `GL_POLYGON` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glEdgeFlag": {
      "signature": "void glEdgeFlag(GLboolean flag)",
      "purpose": "flag edges as either boundary or nonboundary",
      "parameters": {
        "flag": "<listitem> <para> Specifies the current edge flag value, either `GL_TRUE` or `GL_FALSE`. The initial value is `GL_TRUE`. </para> </listitem>"
      }
    },
    "glEdgeFlagv": {
      "signature": "void glEdgeFlagv(const GLboolean * flag)",
      "purpose": "flag edges as either boundary or nonboundary",
      "parameters": {
        "flag": "<listitem> <para> Specifies the current edge flag value, either `GL_TRUE` or `GL_FALSE`. The initial value is `GL_TRUE`. </para> </listitem>"
      }
    },
    "glEdgeFlagPointer": {
      "signature": "void glEdgeFlagPointer(GLsizei stride, const void * pointer)",
      "purpose": "define an array of edge flags",
      "parameters": {
        "stride": "<listitem> <para> Specifies the byte offset between consecutive edge flags. If <parameter>stride</parameter> is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first edge flag in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnableClientState": {
      "signature": "void glEnableClientState(GLenum cap)",
      "purpose": "enable or disable client-side capability",
      "parameters": {
        "cap": "<listitem> <para> Specifies the capability to enable. Symbolic constants `GL_COLOR_ARRAY`, `GL_EDGE_FLAG_ARRAY`, `GL_FOG_COORD_ARRAY`, `GL_INDEX_ARRAY`, `GL_NORMAL_ARRAY`, `GL_SECONDARY_COLOR_ARRAY`, `GL_TEXTURE_COORD_ARRAY`, and `GL_VERTEX_ARRAY` are accepted. </para> </listitem>"
      }
    },
    "glDisableClientState": {
      "signature": "void glDisableClientState(GLenum cap)",
      "purpose": "enable or disable client-side capability",
      "parameters": {
        "cap": "<listitem> <para> Specifies the capability to enable. Symbolic constants `GL_COLOR_ARRAY`, `GL_EDGE_FLAG_ARRAY`, `GL_FOG_COORD_ARRAY`, `GL_INDEX_ARRAY`, `GL_NORMAL_ARRAY`, `GL_SECONDARY_COLOR_ARRAY`, `GL_TEXTURE_COORD_ARRAY`, and `GL_VERTEX_ARRAY` are accepted. </para> </listitem>"
      }
    },
    "glEnableVertexAttribArray": {
      "signature": "void glEnableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexAttribArray": {
      "signature": "void glDisableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glEvalCoord1f": {
      "signature": "void glEvalCoord1f(GLfloat u)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord1d": {
      "signature": "void glEvalCoord1d(GLdouble u)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord2f": {
      "signature": "void glEvalCoord2f(GLfloat u, GLfloat v)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord2d": {
      "signature": "void glEvalCoord2d(GLdouble u, GLdouble v)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord1fv": {
      "signature": "void glEvalCoord1fv(const GLfloat * u)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord1dv": {
      "signature": "void glEvalCoord1dv(const GLdouble * u)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord2fv": {
      "signature": "void glEvalCoord2fv(const GLfloat * u)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalCoord2dv": {
      "signature": "void glEvalCoord2dv(const GLdouble * u)",
      "purpose": "evaluate enabled one- and two-dimensional maps",
      "parameters": {
        "u": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap1</refentrytitle></citerefentry> or <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. </para> </listitem>",
        "v": "<listitem> <para> Specifies a value that is the domain coordinate <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> to the basis function defined in a previous <citerefentry><refentrytitle>glMap2</refentrytitle></citerefentry> command. This argument is not present in a <function>glEvalCoord1</function> command. </para> </listitem>"
      }
    },
    "glEvalMesh1": {
      "signature": "void glEvalMesh1(GLenum mode, GLint i1, GLint i2)",
      "purpose": "compute a one- or two-dimensional grid of points or lines",
      "parameters": {
        "mode": "<listitem> <para> In <function>glEvalMesh1</function>, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants `GL_POINT` and `GL_LINE` are accepted. </para> </listitem>",
        "i1": "<listitem> <para> Specify the first and last integer values for grid domain variable <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>. </para> </listitem>"
      }
    },
    "glEvalMesh2": {
      "signature": "void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)",
      "purpose": "compute a one- or two-dimensional grid of points or lines",
      "parameters": {
        "mode": "<listitem> <para> In <function>glEvalMesh1</function>, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants `GL_POINT` and `GL_LINE` are accepted. </para> </listitem>",
        "i1": "<listitem> <para> Specify the first and last integer values for grid domain variable <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>. </para> </listitem>"
      }
    },
    "glEvalPoint1": {
      "signature": "void glEvalPoint1(GLint i)",
      "purpose": "generate and evaluate a single point in a mesh",
      "parameters": {
        "i": "<listitem> <para> Specifies the integer value for grid domain variable <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>. </para> </listitem>",
        "j": "<listitem> <para> Specifies the integer value for grid domain variable <inlineequation><math><mi mathvariant=\"italic\">j</mi></math></inlineequation> (<function>glEvalPoint2</function> only). </para> </listitem>"
      }
    },
    "glEvalPoint2": {
      "signature": "void glEvalPoint2(GLint i, GLint j)",
      "purpose": "generate and evaluate a single point in a mesh",
      "parameters": {
        "i": "<listitem> <para> Specifies the integer value for grid domain variable <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>. </para> </listitem>",
        "j": "<listitem> <para> Specifies the integer value for grid domain variable <inlineequation><math><mi mathvariant=\"italic\">j</mi></math></inlineequation> (<function>glEvalPoint2</function> only). </para> </listitem>"
      }
    },
    "glFeedbackBuffer": {
      "signature": "void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer)",
      "purpose": "controls feedback mode",
      "parameters": {
        "size": "<listitem> <para> Specifies the maximum number of values that can be written into <parameter>buffer</parameter>. </para> </listitem>",
        "type": "<listitem> <para> Specifies a symbolic constant that describes the information that will be returned for each vertex. `GL_2D`, `GL_3D`, `GL_3D_COLOR`, `GL_3D_COLOR_TEXTURE`, and `GL_4D_COLOR_TEXTURE` are accepted. </para> </listitem>",
        "buffer": "<listitem> <para> Returns the feedback data. </para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish( void)",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush( void)",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFogf": {
      "signature": "void glFogf(GLenum pname, GLfloat param)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, `GL_FOG_END`, `GL_FOG_INDEX`, and `GL_FOG_COORD_SRC` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glFogi": {
      "signature": "void glFogi(GLenum pname, GLint param)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, `GL_FOG_END`, `GL_FOG_INDEX`, and `GL_FOG_COORD_SRC` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glFogfv": {
      "signature": "void glFogfv(GLenum pname, const GLfloat * params)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, `GL_FOG_END`, `GL_FOG_INDEX`, and `GL_FOG_COORD_SRC` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glFogiv": {
      "signature": "void glFogiv(GLenum pname, const GLint * params)",
      "purpose": "specify fog parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued fog parameter. `GL_FOG_MODE`, `GL_FOG_DENSITY`, `GL_FOG_START`, `GL_FOG_END`, `GL_FOG_INDEX`, and `GL_FOG_COORD_SRC` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glFogCoordd": {
      "signature": "void glFogCoordd(GLdouble coord)",
      "purpose": "set the current fog coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specify the fog distance. </para> </listitem>"
      }
    },
    "glFogCoordf": {
      "signature": "void glFogCoordf(GLfloat coord)",
      "purpose": "set the current fog coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specify the fog distance. </para> </listitem>"
      }
    },
    "glFogCoorddv": {
      "signature": "void glFogCoorddv(GLdouble * coord)",
      "purpose": "set the current fog coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specify the fog distance. </para> </listitem>"
      }
    },
    "glFogCoordfv": {
      "signature": "void glFogCoordfv(GLfloat * coord)",
      "purpose": "set the current fog coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specify the fog distance. </para> </listitem>"
      }
    },
    "glFogCoordPointer": {
      "signature": "void glFogCoordPointer(GLenum type, GLsizei stride, void * pointer)",
      "purpose": "define an array of fog coordinates",
      "parameters": {
        "type": "<listitem> <para> Specifies the data type of each fog coordinate. Symbolic constants `GL_FLOAT`, or `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive fog coordinates. If <parameter>stride</parameter> is 0, the array elements are understood to be tightly packed. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
      }
    },
    "glFrustum": {
      "signature": "void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)",
      "purpose": "multiply the current matrix by a perspective matrix",
      "parameters": {
        "left": "<listitem> <para> Specify the coordinates for the left and right vertical clipping planes. </para> </listitem>",
        "bottom": "<listitem> <para> Specify the coordinates for the bottom and top horizontal clipping planes. </para> </listitem>",
        "nearVal": "<listitem> <para> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
      }
    },
    "glGenLists": {
      "signature": "GLuint glGenLists(GLsizei range)",
      "purpose": "generate a contiguous set of empty display lists",
      "parameters": {
        "range": "<listitem> <para> Specifies the number of contiguous empty display lists to be generated. </para> </listitem>"
      }
    },
    "glGenQueries": {
      "signature": "void glGenQueries(GLsizei n, GLuint * ids)",
      "purpose": "generate query object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query object names to be generated. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which the generated query object names are stored. </para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetDoublev": {
      "signature": "void glGetDoublev(GLenum pname, GLdouble * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * params)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned. The symbolic constants in the list below are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetActiveAttrib": {
      "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active attribute variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
      }
    },
    "glGetActiveUniform": {
      "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active uniform variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
      }
    },
    "glGetAttachedShaders": {
      "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
      "purpose": "Returns the handles of the shader objects attached to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
        "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
      }
    },
    "glGetAttribLocation": {
      "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of an attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the symbolic name of a buffer object parameter. Accepted values are `GL_BUFFER_ACCESS`, `GL_BUFFER_MAPPED`, `GL_BUFFER_SIZE`, or `GL_BUFFER_USAGE`. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferPointerv": {
      "signature": "void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)",
      "purpose": "return the pointer to a mapped buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the pointer to be returned. The symbolic constant must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetBufferSubData": {
      "signature": "void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data)",
      "purpose": "returns a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being returned. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the location where buffer object data is returned. </para> </listitem>"
      }
    },
    "glGetClipPlane": {
      "signature": "void glGetClipPlane(GLenum plane, GLdouble * equation)",
      "purpose": "return the coefficients of the specified clipping plane",
      "parameters": {
        "plane": "<listitem> <para> Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form `GL_CLIP_PLANE` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> where i ranges from 0 to the value of `GL_MAX_CLIP_PLANES` - 1. </para> </listitem>",
        "equation": "<listitem> <para> Returns four double-precision values that are the coefficients of the plane equation of <parameter>plane</parameter> in eye coordinates. The initial value is (0, 0, 0, 0). </para> </listitem>"
      }
    },
    "glGetColorTable": {
      "signature": "void glGetColorTable(GLenum target, GLenum format, GLenum type, void * table)",
      "purpose": "retrieve contents of a color lookup table",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, or `GL_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "format": "<listitem> <para> The format of the pixel data in <parameter>table</parameter>. The possible values are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_LUMINANCE`, `GL_LUMINANCE_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`. </para> </listitem>",
        "type": "<listitem> <para> The type of the pixel data in <parameter>table</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "table": "<listitem> <para> Pointer to a one-dimensional array of pixel data containing the contents of the color table. </para> </listitem>"
      }
    },
    "glGetColorTableParameterfv": {
      "signature": "void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "get color lookup table parameters",
      "parameters": {
        "target": "<listitem> <para> The target color table. Must be `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, `GL_POST_COLOR_MATRIX_COLOR_TABLE`, `GL_PROXY_COLOR_TABLE`, `GL_PROXY_POST_CONVOLUTION_COLOR_TABLE`, or `GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "pname": "<listitem> <para> The symbolic name of a color lookup table parameter. Must be one of `GL_COLOR_TABLE_BIAS`, `GL_COLOR_TABLE_SCALE`, `GL_COLOR_TABLE_FORMAT`, `GL_COLOR_TABLE_WIDTH`, `GL_COLOR_TABLE_RED_SIZE`, `GL_COLOR_TABLE_GREEN_SIZE`, `GL_COLOR_TABLE_BLUE_SIZE`, `GL_COLOR_TABLE_ALPHA_SIZE`, `GL_COLOR_TABLE_LUMINANCE_SIZE`, or `GL_COLOR_TABLE_INTENSITY_SIZE`. </para> </listitem>",
        "params": "<listitem> <para> A pointer to an array where the values of the parameter will be stored. </para> </listitem>"
      }
    },
    "glGetColorTableParameteriv": {
      "signature": "void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "get color lookup table parameters",
      "parameters": {
        "target": "<listitem> <para> The target color table. Must be `GL_COLOR_TABLE`, `GL_POST_CONVOLUTION_COLOR_TABLE`, `GL_POST_COLOR_MATRIX_COLOR_TABLE`, `GL_PROXY_COLOR_TABLE`, `GL_PROXY_POST_CONVOLUTION_COLOR_TABLE`, or `GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE`. </para> </listitem>",
        "pname": "<listitem> <para> The symbolic name of a color lookup table parameter. Must be one of `GL_COLOR_TABLE_BIAS`, `GL_COLOR_TABLE_SCALE`, `GL_COLOR_TABLE_FORMAT`, `GL_COLOR_TABLE_WIDTH`, `GL_COLOR_TABLE_RED_SIZE`, `GL_COLOR_TABLE_GREEN_SIZE`, `GL_COLOR_TABLE_BLUE_SIZE`, `GL_COLOR_TABLE_ALPHA_SIZE`, `GL_COLOR_TABLE_LUMINANCE_SIZE`, or `GL_COLOR_TABLE_INTENSITY_SIZE`. </para> </listitem>",
        "params": "<listitem> <para> A pointer to an array where the values of the parameter will be stored. </para> </listitem>"
      }
    },
    "glGetCompressedTexImage": {
      "signature": "void glGetCompressedTexImage(GLenum target, GLint lod, void * img)",
      "purpose": "return a compressed texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies which texture is to be obtained. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, and `GL_TEXTURE_3D` `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` are accepted. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "img": "<listitem> <para> Returns the compressed texture image. </para> </listitem>"
      }
    },
    "glGetConvolutionFilter": {
      "signature": "void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, void * image)",
      "purpose": "get current 1D or 2D convolution filter kernel",
      "parameters": {
        "target": "<listitem> <para> The filter to be retrieved. Must be one of `GL_CONVOLUTION_1D` or `GL_CONVOLUTION_2D`. </para> </listitem>",
        "format": "<listitem> <para> Format of the output image. Must be one of `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, or `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Data type of components in the output image. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "image": "<listitem> <para> Pointer to storage for the output image. </para> </listitem>"
      }
    },
    "glGetConvolutionParameterfv": {
      "signature": "void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "get convolution parameters",
      "parameters": {
        "target": "<listitem> <para> The filter whose parameters are to be retrieved. Must be one of `GL_CONVOLUTION_1D`, `GL_CONVOLUTION_2D`, or `GL_SEPARABLE_2D`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be retrieved. Must be one of `GL_CONVOLUTION_BORDER_MODE`, `GL_CONVOLUTION_BORDER_COLOR`, `GL_CONVOLUTION_FILTER_SCALE`, `GL_CONVOLUTION_FILTER_BIAS`, `GL_CONVOLUTION_FORMAT`, `GL_CONVOLUTION_WIDTH`, `GL_CONVOLUTION_HEIGHT`, `GL_MAX_CONVOLUTION_WIDTH`, or `GL_MAX_CONVOLUTION_HEIGHT`. </para> </listitem>",
        "params": "<listitem> <para> Pointer to storage for the parameters to be retrieved. </para> </listitem>"
      }
    },
    "glGetConvolutionParameteriv": {
      "signature": "void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "get convolution parameters",
      "parameters": {
        "target": "<listitem> <para> The filter whose parameters are to be retrieved. Must be one of `GL_CONVOLUTION_1D`, `GL_CONVOLUTION_2D`, or `GL_SEPARABLE_2D`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be retrieved. Must be one of `GL_CONVOLUTION_BORDER_MODE`, `GL_CONVOLUTION_BORDER_COLOR`, `GL_CONVOLUTION_FILTER_SCALE`, `GL_CONVOLUTION_FILTER_BIAS`, `GL_CONVOLUTION_FORMAT`, `GL_CONVOLUTION_WIDTH`, `GL_CONVOLUTION_HEIGHT`, `GL_MAX_CONVOLUTION_WIDTH`, or `GL_MAX_CONVOLUTION_HEIGHT`. </para> </listitem>",
        "params": "<listitem> <para> Pointer to storage for the parameters to be retrieved. </para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError( void)",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetHistogram": {
      "signature": "void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values)",
      "purpose": "get histogram table",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_HISTOGRAM`. </para> </listitem>",
        "reset": "<listitem> <para> If `GL_TRUE`, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If `GL_FALSE`, none of the counters in the histogram table is modified. </para> </listitem>",
        "format": "<listitem> <para> The format of values to be returned in <parameter>values</parameter>. Must be one of `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, or `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> The type of values to be returned in <parameter>values</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "values": "<listitem> <para> A pointer to storage for the returned histogram table. </para> </listitem>"
      }
    },
    "glGetHistogramParameterfv": {
      "signature": "void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "get histogram parameters",
      "parameters": {
        "target": "<listitem> <para> Must be one of `GL_HISTOGRAM` or `GL_PROXY_HISTOGRAM`. </para> </listitem>",
        "pname": "<listitem> <para> The name of the parameter to be retrieved. Must be one of `GL_HISTOGRAM_WIDTH`, `GL_HISTOGRAM_FORMAT`, `GL_HISTOGRAM_RED_SIZE`, `GL_HISTOGRAM_GREEN_SIZE`, `GL_HISTOGRAM_BLUE_SIZE`, `GL_HISTOGRAM_ALPHA_SIZE`, `GL_HISTOGRAM_LUMINANCE_SIZE`, or `GL_HISTOGRAM_SINK`. </para> </listitem>",
        "params": "<listitem> <para> Pointer to storage for the returned values. </para> </listitem>"
      }
    },
    "glGetHistogramParameteriv": {
      "signature": "void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "get histogram parameters",
      "parameters": {
        "target": "<listitem> <para> Must be one of `GL_HISTOGRAM` or `GL_PROXY_HISTOGRAM`. </para> </listitem>",
        "pname": "<listitem> <para> The name of the parameter to be retrieved. Must be one of `GL_HISTOGRAM_WIDTH`, `GL_HISTOGRAM_FORMAT`, `GL_HISTOGRAM_RED_SIZE`, `GL_HISTOGRAM_GREEN_SIZE`, `GL_HISTOGRAM_BLUE_SIZE`, `GL_HISTOGRAM_ALPHA_SIZE`, `GL_HISTOGRAM_LUMINANCE_SIZE`, or `GL_HISTOGRAM_SINK`. </para> </listitem>",
        "params": "<listitem> <para> Pointer to storage for the returned values. </para> </listitem>"
      }
    },
    "glGetLightfv": {
      "signature": "void glGetLightfv(GLenum light, GLenum pname, GLfloat * params)",
      "purpose": "return light source parameter values",
      "parameters": {
        "light": "<listitem> <para> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> where <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> ranges from 0 to the value of `GL_MAX_LIGHTS` - 1. </para> </listitem>",
        "pname": "<listitem> <para> Specifies a light source parameter for <parameter>light</parameter>. Accepted symbolic names are `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_POSITION`, `GL_SPOT_DIRECTION`, `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetLightiv": {
      "signature": "void glGetLightiv(GLenum light, GLenum pname, GLint * params)",
      "purpose": "return light source parameter values",
      "parameters": {
        "light": "<listitem> <para> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> where <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> ranges from 0 to the value of `GL_MAX_LIGHTS` - 1. </para> </listitem>",
        "pname": "<listitem> <para> Specifies a light source parameter for <parameter>light</parameter>. Accepted symbolic names are `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_POSITION`, `GL_SPOT_DIRECTION`, `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMapdv": {
      "signature": "void glGetMapdv(GLenum target, GLenum query, GLdouble * v)",
      "purpose": "return evaluator parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of a map. Accepted values are `GL_MAP1_COLOR_4`, `GL_MAP1_INDEX`, `GL_MAP1_NORMAL`, `GL_MAP1_TEXTURE_COORD_1`, `GL_MAP1_TEXTURE_COORD_2`, `GL_MAP1_TEXTURE_COORD_3`, `GL_MAP1_TEXTURE_COORD_4`, `GL_MAP1_VERTEX_3`, `GL_MAP1_VERTEX_4`, `GL_MAP2_COLOR_4`, `GL_MAP2_INDEX`, `GL_MAP2_NORMAL`, `GL_MAP2_TEXTURE_COORD_1`, `GL_MAP2_TEXTURE_COORD_2`, `GL_MAP2_TEXTURE_COORD_3`, `GL_MAP2_TEXTURE_COORD_4`, `GL_MAP2_VERTEX_3`, and `GL_MAP2_VERTEX_4`. </para> </listitem>",
        "query": "<listitem> <para> Specifies which parameter to return. Symbolic names `GL_COEFF`, `GL_ORDER`, and `GL_DOMAIN` are accepted. </para> </listitem>",
        "v": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMapfv": {
      "signature": "void glGetMapfv(GLenum target, GLenum query, GLfloat * v)",
      "purpose": "return evaluator parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of a map. Accepted values are `GL_MAP1_COLOR_4`, `GL_MAP1_INDEX`, `GL_MAP1_NORMAL`, `GL_MAP1_TEXTURE_COORD_1`, `GL_MAP1_TEXTURE_COORD_2`, `GL_MAP1_TEXTURE_COORD_3`, `GL_MAP1_TEXTURE_COORD_4`, `GL_MAP1_VERTEX_3`, `GL_MAP1_VERTEX_4`, `GL_MAP2_COLOR_4`, `GL_MAP2_INDEX`, `GL_MAP2_NORMAL`, `GL_MAP2_TEXTURE_COORD_1`, `GL_MAP2_TEXTURE_COORD_2`, `GL_MAP2_TEXTURE_COORD_3`, `GL_MAP2_TEXTURE_COORD_4`, `GL_MAP2_VERTEX_3`, and `GL_MAP2_VERTEX_4`. </para> </listitem>",
        "query": "<listitem> <para> Specifies which parameter to return. Symbolic names `GL_COEFF`, `GL_ORDER`, and `GL_DOMAIN` are accepted. </para> </listitem>",
        "v": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMapiv": {
      "signature": "void glGetMapiv(GLenum target, GLenum query, GLint * v)",
      "purpose": "return evaluator parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of a map. Accepted values are `GL_MAP1_COLOR_4`, `GL_MAP1_INDEX`, `GL_MAP1_NORMAL`, `GL_MAP1_TEXTURE_COORD_1`, `GL_MAP1_TEXTURE_COORD_2`, `GL_MAP1_TEXTURE_COORD_3`, `GL_MAP1_TEXTURE_COORD_4`, `GL_MAP1_VERTEX_3`, `GL_MAP1_VERTEX_4`, `GL_MAP2_COLOR_4`, `GL_MAP2_INDEX`, `GL_MAP2_NORMAL`, `GL_MAP2_TEXTURE_COORD_1`, `GL_MAP2_TEXTURE_COORD_2`, `GL_MAP2_TEXTURE_COORD_3`, `GL_MAP2_TEXTURE_COORD_4`, `GL_MAP2_VERTEX_3`, and `GL_MAP2_VERTEX_4`. </para> </listitem>",
        "query": "<listitem> <para> Specifies which parameter to return. Symbolic names `GL_COEFF`, `GL_ORDER`, and `GL_DOMAIN` are accepted. </para> </listitem>",
        "v": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMaterialfv": {
      "signature": "void glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params)",
      "purpose": "return material parameters",
      "parameters": {
        "face": "<listitem> <para> Specifies which of the two materials is being queried. `GL_FRONT` or `GL_BACK` are accepted, representing the front and back materials, respectively. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the material parameter to return. `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_EMISSION`, `GL_SHININESS`, and `GL_COLOR_INDEXES` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMaterialiv": {
      "signature": "void glGetMaterialiv(GLenum face, GLenum pname, GLint * params)",
      "purpose": "return material parameters",
      "parameters": {
        "face": "<listitem> <para> Specifies which of the two materials is being queried. `GL_FRONT` or `GL_BACK` are accepted, representing the front and back materials, respectively. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the material parameter to return. `GL_AMBIENT`, `GL_DIFFUSE`, `GL_SPECULAR`, `GL_EMISSION`, `GL_SHININESS`, and `GL_COLOR_INDEXES` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetMinmax": {
      "signature": "void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, void * values)",
      "purpose": "get minimum and maximum pixel values",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_MINMAX`. </para> </listitem>",
        "reset": "<listitem> <para> If `GL_TRUE`, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If `GL_FALSE`, the minmax table is unaltered. </para> </listitem>",
        "format": "<listitem> <para> The format of the data to be returned in <parameter>values</parameter>. Must be one of `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, or `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "types": "<listitem> <para> The type of the data to be returned in <parameter>values</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "values": "<listitem> <para> A pointer to storage for the returned values. </para> </listitem>"
      }
    },
    "glGetMinmaxParameterfv": {
      "signature": "void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "get minmax parameters",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_MINMAX`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be retrieved. Must be one of `GL_MINMAX_FORMAT` or `GL_MINMAX_SINK`. </para> </listitem>",
        "params": "<listitem> <para> A pointer to storage for the retrieved parameters. </para> </listitem>"
      }
    },
    "glGetMinmaxParameteriv": {
      "signature": "void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "get minmax parameters",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_MINMAX`. </para> </listitem>",
        "pname": "<listitem> <para> The parameter to be retrieved. Must be one of `GL_MINMAX_FORMAT` or `GL_MINMAX_SINK`. </para> </listitem>",
        "params": "<listitem> <para> A pointer to storage for the retrieved parameters. </para> </listitem>"
      }
    },
    "glGetPixelMapfv": {
      "signature": "void glGetPixelMapfv(GLenum map, GLfloat * data)",
      "purpose": "return the specified pixel map",
      "parameters": {
        "map": "<listitem> <para> Specifies the name of the pixel map to return. Accepted values are `GL_PIXEL_MAP_I_TO_I`, `GL_PIXEL_MAP_S_TO_S`, `GL_PIXEL_MAP_I_TO_R`, `GL_PIXEL_MAP_I_TO_G`, `GL_PIXEL_MAP_I_TO_B`, `GL_PIXEL_MAP_I_TO_A`, `GL_PIXEL_MAP_R_TO_R`, `GL_PIXEL_MAP_G_TO_G`, `GL_PIXEL_MAP_B_TO_B`, and `GL_PIXEL_MAP_A_TO_A`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel map contents. </para> </listitem>"
      }
    },
    "glGetPixelMapuiv": {
      "signature": "void glGetPixelMapuiv(GLenum map, GLuint * data)",
      "purpose": "return the specified pixel map",
      "parameters": {
        "map": "<listitem> <para> Specifies the name of the pixel map to return. Accepted values are `GL_PIXEL_MAP_I_TO_I`, `GL_PIXEL_MAP_S_TO_S`, `GL_PIXEL_MAP_I_TO_R`, `GL_PIXEL_MAP_I_TO_G`, `GL_PIXEL_MAP_I_TO_B`, `GL_PIXEL_MAP_I_TO_A`, `GL_PIXEL_MAP_R_TO_R`, `GL_PIXEL_MAP_G_TO_G`, `GL_PIXEL_MAP_B_TO_B`, and `GL_PIXEL_MAP_A_TO_A`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel map contents. </para> </listitem>"
      }
    },
    "glGetPixelMapusv": {
      "signature": "void glGetPixelMapusv(GLenum map, GLushort * data)",
      "purpose": "return the specified pixel map",
      "parameters": {
        "map": "<listitem> <para> Specifies the name of the pixel map to return. Accepted values are `GL_PIXEL_MAP_I_TO_I`, `GL_PIXEL_MAP_S_TO_S`, `GL_PIXEL_MAP_I_TO_R`, `GL_PIXEL_MAP_I_TO_G`, `GL_PIXEL_MAP_I_TO_B`, `GL_PIXEL_MAP_I_TO_A`, `GL_PIXEL_MAP_R_TO_R`, `GL_PIXEL_MAP_G_TO_G`, `GL_PIXEL_MAP_B_TO_B`, and `GL_PIXEL_MAP_A_TO_A`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel map contents. </para> </listitem>"
      }
    },
    "glGetPointerv": {
      "signature": "void glGetPointerv(GLenum pname, void ** params)",
      "purpose": "return the address of the specified pointer",
      "parameters": {
        "pname": "<listitem> <para> Specifies the array or buffer pointer to be returned. Symbolic constants `GL_COLOR_ARRAY_POINTER`, `GL_EDGE_FLAG_ARRAY_POINTER`, `GL_FOG_COORD_ARRAY_POINTER`, `GL_FEEDBACK_BUFFER_POINTER`, `GL_INDEX_ARRAY_POINTER`, `GL_NORMAL_ARRAY_POINTER`, `GL_SECONDARY_COLOR_ARRAY_POINTER`, `GL_SELECTION_BUFFER_POINTER`, `GL_TEXTURE_COORD_ARRAY_POINTER`, or `GL_VERTEX_ARRAY_POINTER` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetPolygonStipple": {
      "signature": "void glGetPolygonStipple(GLubyte * pattern)",
      "purpose": "return the polygon stipple pattern",
      "parameters": {
        "pattern": "<listitem> <para> Returns the stipple pattern. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glGetProgramiv": {
      "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_DELETE_STATUS`, `GL_LINK_STATUS`, `GL_VALIDATE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetProgramInfoLog": {
      "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetQueryiv": {
      "signature": "void glGetQueryiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object target",
      "parameters": {
        "target": "<listitem> <para> Specifies a query object target. Must be `GL_SAMPLES_PASSED`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryObjectiv": {
      "signature": "void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT` or `GL_QUERY_RESULT_AVAILABLE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryObjectuiv": {
      "signature": "void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT` or `GL_QUERY_RESULT_AVAILABLE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetSeparableFilter": {
      "signature": "void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span)",
      "purpose": "get separable convolution filter kernel images",
      "parameters": {
        "target": "<listitem> <para> The separable filter to be retrieved. Must be `GL_SEPARABLE_2D`. </para> </listitem>",
        "format": "<listitem> <para> Format of the output images. Must be one of `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR` `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, or `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Data type of components in the output images. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "row": "<listitem> <para> Pointer to storage for the row filter image. </para> </listitem>",
        "column": "<listitem> <para> Pointer to storage for the column filter image. </para> </listitem>",
        "span": "<listitem> <para> Pointer to storage for the span filter image (currently unused). </para> </listitem>"
      }
    },
    "glGetShaderiv": {
      "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetShaderInfoLog": {
      "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetShaderSource": {
      "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
      "purpose": "Returns the source code string from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
        "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte* glGetString(GLenum name)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, `GL_SHADING_LANGUAGE_VERSION`, or `GL_EXTENSIONS`. </para> </listitem>"
      }
    },
    "glGetTexEnvfv": {
      "signature": "void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV`, `GL_TEXTURE_FILTER_CONTROL`, or `GL_POINT_SPRITE`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture environment parameter. Accepted values are `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_ENV_COLOR`, `GL_TEXTURE_LOD_BIAS`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexEnviv": {
      "signature": "void glGetTexEnviv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV`, `GL_TEXTURE_FILTER_CONTROL`, or `GL_POINT_SPRITE`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture environment parameter. Accepted values are `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_ENV_COLOR`, `GL_TEXTURE_LOD_BIAS`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexGendv": {
      "signature": "void glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params)",
      "purpose": "return texture coordinate generation parameters",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the value(s) to be returned. Must be either `GL_TEXTURE_GEN_MODE` or the name of one of the texture generation plane equations: `GL_OBJECT_PLANE` or `GL_EYE_PLANE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexGenfv": {
      "signature": "void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params)",
      "purpose": "return texture coordinate generation parameters",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the value(s) to be returned. Must be either `GL_TEXTURE_GEN_MODE` or the name of one of the texture generation plane equations: `GL_OBJECT_PLANE` or `GL_EYE_PLANE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexGeniv": {
      "signature": "void glGetTexGeniv(GLenum coord, GLenum pname, GLint * params)",
      "purpose": "return texture coordinate generation parameters",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the value(s) to be returned. Must be either `GL_TEXTURE_GEN_MODE` or the name of one of the texture generation plane equations: `GL_OBJECT_PLANE` or `GL_EYE_PLANE`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexImage": {
      "signature": "void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * img)",
      "purpose": "return a texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies which texture is to be obtained. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` are accepted. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "format": "<listitem> <para> Specifies a pixel format for the returned data. The supported formats are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "img": "<listitem> <para> Returns the texture image. Should be a pointer to an array of the type specified by <parameter>type</parameter>. </para> </listitem>"
      }
    },
    "glGetTexLevelParameterfv": {
      "signature": "void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values for a specific level of detail",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_BORDER`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_LUMINANCE_SIZE`, `GL_TEXTURE_INTENSITY_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexLevelParameteriv": {
      "signature": "void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values for a specific level of detail",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_BORDER`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_LUMINANCE_SIZE`, `GL_TEXTURE_INTENSITY_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_PRIORITY`, `GL_TEXTURE_RESIDENT`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_DEPTH_TEXTURE_MODE`, and `GL_GENERATE_MIPMAP` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "target": "<listitem> <para> Specifies the symbolic name of the target texture. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, and `GL_TEXTURE_CUBE_MAP` are accepted. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a texture parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_PRIORITY`, `GL_TEXTURE_RESIDENT`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_DEPTH_TEXTURE_MODE`, and `GL_GENERATE_MIPMAP` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the texture parameters. </para> </listitem>"
      }
    },
    "glGetUniformfv": {
      "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformiv": {
      "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformLocation": {
      "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetVertexAttribdv": {
      "signature": "void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribfv": {
      "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribiv": {
      "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribPointerv": {
      "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
      "purpose": "return the address of the specified generic vertex attribute pointer",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
        "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_FOG_HINT`, `GL_GENERATE_MIPMAP_HINT`, `GL_LINE_SMOOTH_HINT`, `GL_PERSPECTIVE_CORRECTION_HINT`, `GL_POINT_SMOOTH_HINT`, `GL_POLYGON_SMOOTH_HINT`, `GL_TEXTURE_COMPRESSION_HINT`, and `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` are accepted. </para> </listitem>",
        "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
      }
    },
    "glHistogram": {
      "signature": "void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)",
      "purpose": "define histogram table",
      "parameters": {
        "target": "<listitem> <para> The histogram whose parameters are to be set. Must be one of `GL_HISTOGRAM` or `GL_PROXY_HISTOGRAM`. </para> </listitem>",
        "width": "<listitem> <para> The number of entries in the histogram table. Must be a power of 2. </para> </listitem>",
        "internalformat": "<listitem> <para> The format of entries in the histogram table. Must be one of `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "sink": "<listitem> <para> If `GL_TRUE`, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If `GL_FALSE`, pixels will proceed to the minmax process after histogramming. </para> </listitem>"
      }
    },
    "glIndexs": {
      "signature": "void glIndexs(GLshort c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexi": {
      "signature": "void glIndexi(GLint c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexf": {
      "signature": "void glIndexf(GLfloat c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexd": {
      "signature": "void glIndexd(GLdouble c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexub": {
      "signature": "void glIndexub(GLubyte c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexsv": {
      "signature": "void glIndexsv(const GLshort * c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexiv": {
      "signature": "void glIndexiv(const GLint * c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexfv": {
      "signature": "void glIndexfv(const GLfloat * c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexdv": {
      "signature": "void glIndexdv(const GLdouble * c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexubv": {
      "signature": "void glIndexubv(const GLubyte * c)",
      "purpose": "set the current color index",
      "parameters": {
        "c": "<listitem> <para> Specifies the new value for the current color index. </para> <para> </para> </listitem>"
      }
    },
    "glIndexMask": {
      "signature": "void glIndexMask(GLuint mask)",
      "purpose": "control the writing of individual bits in the color index buffers",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glIndexPointer": {
      "signature": "void glIndexPointer(GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of color indexes",
      "parameters": {
        "type": "<listitem> <para> Specifies the data type of each color index in the array. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_INT`, `GL_FLOAT`, and `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive color indexes. If <parameter>stride</parameter> is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first index in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glInitNames": {
      "signature": "void glInitNames( void)",
      "purpose": "initialize the name stack",
      "parameters": {}
    },
    "glInterleavedArrays": {
      "signature": "void glInterleavedArrays(GLenum format, GLsizei stride, const void * pointer)",
      "purpose": "simultaneously specify and enable several interleaved arrays",
      "parameters": {
        "format": "<listitem> <para> Specifies the type of array to enable. Symbolic constants `GL_V2F`, `GL_V3F`, `GL_C4UB_V2F`, `GL_C4UB_V3F`, `GL_C3F_V3F`, `GL_N3F_V3F`, `GL_C4F_N3F_V3F`, `GL_T2F_V3F`, `GL_T4F_V4F`, `GL_T2F_C4UB_V3F`, `GL_T2F_C3F_V3F`, `GL_T2F_N3F_V3F`, `GL_T2F_C4F_N3F_V3F`, and `GL_T4F_C4F_N3F_V4F` are accepted. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the offset in bytes between each aggregate array element. </para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glIsList": {
      "signature": "GLboolean glIsList(GLuint list)",
      "purpose": "determine if a name corresponds to a display list",
      "parameters": {
        "list": "<listitem> <para> Specifies a potential display list name. </para> </listitem>"
      }
    },
    "glIsProgram": {
      "signature": "GLboolean glIsProgram(GLuint program)",
      "purpose": "Determines if a name corresponds to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
      }
    },
    "glIsQuery": {
      "signature": "GLboolean glIsQuery(GLuint id)",
      "purpose": "determine if a name corresponds to a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a query object. </para> </listitem>"
      }
    },
    "glIsShader": {
      "signature": "GLboolean glIsShader(GLuint shader)",
      "purpose": "Determines if a name corresponds to a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glLightf": {
      "signature": "void glLightf(GLenum light, GLenum pname, GLfloat param)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to the value of `GL_MAX_LIGHTS` - 1. </para> </listitem>",
        "pname": "<listitem> <para> Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLighti": {
      "signature": "void glLighti(GLenum light, GLenum pname, GLint param)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to the value of `GL_MAX_LIGHTS` - 1. </para> </listitem>",
        "pname": "<listitem> <para> Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLightfv": {
      "signature": "void glLightfv(GLenum light, GLenum pname, const GLfloat * params)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to the value of `GL_MAX_LIGHTS` - 1. </para> </listitem>",
        "pname": "<listitem> <para> Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLightiv": {
      "signature": "void glLightiv(GLenum light, GLenum pname, const GLint * params)",
      "purpose": "set light source parameters",
      "parameters": {
        "light": "<listitem> <para> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form `GL_LIGHT` <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to the value of `GL_MAX_LIGHTS` - 1. </para> </listitem>",
        "pname": "<listitem> <para> Specifies a single-valued light source parameter for <parameter>light</parameter>. `GL_SPOT_EXPONENT`, `GL_SPOT_CUTOFF`, `GL_CONSTANT_ATTENUATION`, `GL_LINEAR_ATTENUATION`, and `GL_QUADRATIC_ATTENUATION` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter <parameter>pname</parameter> of light source <parameter>light</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLightModelf": {
      "signature": "void glLightModelf(GLenum pname, GLfloat param)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued lighting model parameter. `GL_LIGHT_MODEL_LOCAL_VIEWER`, `GL_LIGHT_MODEL_COLOR_CONTROL`, and `GL_LIGHT_MODEL_TWO_SIDE` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>param</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLightModeli": {
      "signature": "void glLightModeli(GLenum pname, GLint param)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued lighting model parameter. `GL_LIGHT_MODEL_LOCAL_VIEWER`, `GL_LIGHT_MODEL_COLOR_CONTROL`, and `GL_LIGHT_MODEL_TWO_SIDE` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>param</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLightModelfv": {
      "signature": "void glLightModelfv(GLenum pname, const GLfloat * params)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued lighting model parameter. `GL_LIGHT_MODEL_LOCAL_VIEWER`, `GL_LIGHT_MODEL_COLOR_CONTROL`, and `GL_LIGHT_MODEL_TWO_SIDE` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>param</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLightModeliv": {
      "signature": "void glLightModeliv(GLenum pname, const GLint * params)",
      "purpose": "set the lighting model parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued lighting model parameter. `GL_LIGHT_MODEL_LOCAL_VIEWER`, `GL_LIGHT_MODEL_COLOR_CONTROL`, and `GL_LIGHT_MODEL_TWO_SIDE` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>param</parameter> will be set to. </para> </listitem>"
      }
    },
    "glLineStipple": {
      "signature": "void glLineStipple(GLint factor, GLushort pattern)",
      "purpose": "specify the line stipple pattern",
      "parameters": {
        "factor": "<listitem> <para> Specifies a multiplier for each bit in the line stipple pattern. If <parameter>factor</parameter> is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. <parameter>factor</parameter> is clamped to the range [1, 256] and defaults to 1. </para> </listitem>",
        "pattern": "<listitem> <para> Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1's. </para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
      }
    },
    "glLinkProgram": {
      "signature": "void glLinkProgram(GLuint program)",
      "purpose": "Links a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
      }
    },
    "glListBase": {
      "signature": "void glListBase(GLuint base)",
      "purpose": "set the display-list base for ",
      "parameters": {
        "base": "<listitem> <para> Specifies an integer offset that will be added to <citerefentry><refentrytitle>glCallLists</refentrytitle></citerefentry> offsets to generate display-list names. The initial value is 0. </para> </listitem>"
      }
    },
    "glLoadIdentity": {
      "signature": "void glLoadIdentity( void)",
      "purpose": "replace the current matrix with the identity matrix",
      "parameters": {}
    },
    "glLoadMatrixd": {
      "signature": "void glLoadMatrixd(const GLdouble * m)",
      "purpose": "replace the current matrix with the specified matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies a pointer to 16 consecutive values, which are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> column-major matrix. </para> </listitem>"
      }
    },
    "glLoadMatrixf": {
      "signature": "void glLoadMatrixf(const GLfloat * m)",
      "purpose": "replace the current matrix with the specified matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies a pointer to 16 consecutive values, which are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> column-major matrix. </para> </listitem>"
      }
    },
    "glLoadName": {
      "signature": "void glLoadName(GLuint name)",
      "purpose": "load a name onto the name stack",
      "parameters": {
        "name": "<listitem> <para> Specifies a name that will replace the top value on the name stack. </para> </listitem>"
      }
    },
    "glLoadTransposeMatrixd": {
      "signature": "void glLoadTransposeMatrixd(const GLdouble * m)",
      "purpose": "replace the current matrix with the specified row-major ordered matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies a pointer to 16 consecutive values, which are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> row-major matrix. </para> </listitem>"
      }
    },
    "glLoadTransposeMatrixf": {
      "signature": "void glLoadTransposeMatrixf(const GLfloat * m)",
      "purpose": "replace the current matrix with the specified row-major ordered matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies a pointer to 16 consecutive values, which are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> row-major matrix. </para> </listitem>"
      }
    },
    "glLogicOp": {
      "signature": "void glLogicOp(GLenum opcode)",
      "purpose": "specify a logical pixel operation for color index rendering",
      "parameters": {
        "opcode": "<listitem> <para> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: `GL_CLEAR`, `GL_SET`, `GL_COPY`, `GL_COPY_INVERTED`, `GL_NOOP`, `GL_INVERT`, `GL_AND`, `GL_NAND`, `GL_OR`, `GL_NOR`, `GL_XOR`, `GL_EQUIV`, `GL_AND_REVERSE`, `GL_AND_INVERTED`, `GL_OR_REVERSE`, and `GL_OR_INVERTED`. The initial value is `GL_COPY`. </para> </listitem>"
      }
    },
    "glMap1f": {
      "signature": "void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points)",
      "purpose": "define a one-dimensional evaluator",
      "parameters": {
        "target": "<listitem> <para> Specifies the kind of values that are generated by the evaluator. Symbolic constants `GL_MAP1_VERTEX_3`, `GL_MAP1_VERTEX_4`, `GL_MAP1_INDEX`, `GL_MAP1_COLOR_4`, `GL_MAP1_NORMAL`, `GL_MAP1_TEXTURE_COORD_1`, `GL_MAP1_TEXTURE_COORD_2`, `GL_MAP1_TEXTURE_COORD_3`, and `GL_MAP1_TEXTURE_COORD_4` are accepted. </para> </listitem>",
        "u1": "<listitem> <para> Specify a linear mapping of <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation>, as presented to <citerefentry><refentrytitle>glEvalCoord1</refentrytitle></citerefentry>, to <inlineequation><math> <mover><mi mathvariant=\"italic\">u</mi><mo /></mover> </math></inlineequation>, the variable that is evaluated by the equations specified by this command. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in <parameter>points</parameter>. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </para> </listitem>",
        "order": "<listitem> <para> Specifies the number of control points. Must be positive. </para> </listitem>",
        "points": "<listitem> <para> Specifies a pointer to the array of control points. </para> </listitem>"
      }
    },
    "glMap1d": {
      "signature": "void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points)",
      "purpose": "define a one-dimensional evaluator",
      "parameters": {
        "target": "<listitem> <para> Specifies the kind of values that are generated by the evaluator. Symbolic constants `GL_MAP1_VERTEX_3`, `GL_MAP1_VERTEX_4`, `GL_MAP1_INDEX`, `GL_MAP1_COLOR_4`, `GL_MAP1_NORMAL`, `GL_MAP1_TEXTURE_COORD_1`, `GL_MAP1_TEXTURE_COORD_2`, `GL_MAP1_TEXTURE_COORD_3`, and `GL_MAP1_TEXTURE_COORD_4` are accepted. </para> </listitem>",
        "u1": "<listitem> <para> Specify a linear mapping of <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation>, as presented to <citerefentry><refentrytitle>glEvalCoord1</refentrytitle></citerefentry>, to <inlineequation><math> <mover><mi mathvariant=\"italic\">u</mi><mo /></mover> </math></inlineequation>, the variable that is evaluated by the equations specified by this command. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in <parameter>points</parameter>. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </para> </listitem>",
        "order": "<listitem> <para> Specifies the number of control points. Must be positive. </para> </listitem>",
        "points": "<listitem> <para> Specifies a pointer to the array of control points. </para> </listitem>"
      }
    },
    "glMap2f": {
      "signature": "void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points)",
      "purpose": "define a two-dimensional evaluator",
      "parameters": {
        "target": "<listitem> <para> Specifies the kind of values that are generated by the evaluator. Symbolic constants `GL_MAP2_VERTEX_3`, `GL_MAP2_VERTEX_4`, `GL_MAP2_INDEX`, `GL_MAP2_COLOR_4`, `GL_MAP2_NORMAL`, `GL_MAP2_TEXTURE_COORD_1`, `GL_MAP2_TEXTURE_COORD_2`, `GL_MAP2_TEXTURE_COORD_3`, and `GL_MAP2_TEXTURE_COORD_4` are accepted. </para> </listitem>",
        "u1": "<listitem> <para> Specify a linear mapping of <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation>, as presented to <citerefentry><refentrytitle>glEvalCoord2</refentrytitle></citerefentry>, to <inlineequation><math> <mover><mi mathvariant=\"italic\">u</mi><mo /></mover> </math></inlineequation>, one of the two variables that are evaluated by the equations specified by this command. Initially, <parameter>u1</parameter> is 0 and <parameter>u2</parameter> is 1. </para> </listitem>",
        "ustride": "<listitem> <para> Specifies the number of floats or doubles between the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mi mathvariant=\"italic\">ij</mi> </msub> </math></inlineequation> and the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mfenced open=\"\" close=\"\"> <mrow> <mfenced open=\"(\" close=\")\"> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>+</mo> <mn>1</mn> </mrow> </mfenced> <mo /> <mi mathvariant=\"italic\">j</mi> </mrow> </mfenced> </msub> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">j</mi></math></inlineequation> are the <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of <parameter>ustride</parameter> is 0. </para> </listitem>",
        "uorder": "<listitem> <para> Specifies the dimension of the control point array in the <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> axis. Must be positive. The initial value is 1. </para> </listitem>",
        "v1": "<listitem> <para> Specify a linear mapping of <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation>, as presented to <citerefentry><refentrytitle>glEvalCoord2</refentrytitle></citerefentry>, to <inlineequation><math> <mover><mi mathvariant=\"italic\">v</mi><mo /></mover> </math></inlineequation>, one of the two variables that are evaluated by the equations specified by this command. Initially, <parameter>v1</parameter> is 0 and <parameter>v2</parameter> is 1. </para> </listitem>",
        "vstride": "<listitem> <para> Specifies the number of floats or doubles between the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mi mathvariant=\"italic\">ij</mi> </msub> </math></inlineequation> and the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mfenced open=\"\" close=\"\"> <mrow> <mi mathvariant=\"italic\">i</mi> <mo /> <mfenced open=\"(\" close=\")\"> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>+</mo> <mn>1</mn> </mrow> </mfenced> </mrow> </mfenced> </msub> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">j</mi></math></inlineequation> are the <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of <parameter>vstride</parameter> is 0. </para> </listitem>",
        "vorder": "<listitem> <para> Specifies the dimension of the control point array in the <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> axis. Must be positive. The initial value is 1. </para> </listitem>",
        "points": "<listitem> <para> Specifies a pointer to the array of control points. </para> </listitem>"
      }
    },
    "glMap2d": {
      "signature": "void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points)",
      "purpose": "define a two-dimensional evaluator",
      "parameters": {
        "target": "<listitem> <para> Specifies the kind of values that are generated by the evaluator. Symbolic constants `GL_MAP2_VERTEX_3`, `GL_MAP2_VERTEX_4`, `GL_MAP2_INDEX`, `GL_MAP2_COLOR_4`, `GL_MAP2_NORMAL`, `GL_MAP2_TEXTURE_COORD_1`, `GL_MAP2_TEXTURE_COORD_2`, `GL_MAP2_TEXTURE_COORD_3`, and `GL_MAP2_TEXTURE_COORD_4` are accepted. </para> </listitem>",
        "u1": "<listitem> <para> Specify a linear mapping of <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation>, as presented to <citerefentry><refentrytitle>glEvalCoord2</refentrytitle></citerefentry>, to <inlineequation><math> <mover><mi mathvariant=\"italic\">u</mi><mo /></mover> </math></inlineequation>, one of the two variables that are evaluated by the equations specified by this command. Initially, <parameter>u1</parameter> is 0 and <parameter>u2</parameter> is 1. </para> </listitem>",
        "ustride": "<listitem> <para> Specifies the number of floats or doubles between the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mi mathvariant=\"italic\">ij</mi> </msub> </math></inlineequation> and the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mfenced open=\"\" close=\"\"> <mrow> <mfenced open=\"(\" close=\")\"> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>+</mo> <mn>1</mn> </mrow> </mfenced> <mo /> <mi mathvariant=\"italic\">j</mi> </mrow> </mfenced> </msub> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">j</mi></math></inlineequation> are the <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of <parameter>ustride</parameter> is 0. </para> </listitem>",
        "uorder": "<listitem> <para> Specifies the dimension of the control point array in the <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> axis. Must be positive. The initial value is 1. </para> </listitem>",
        "v1": "<listitem> <para> Specify a linear mapping of <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation>, as presented to <citerefentry><refentrytitle>glEvalCoord2</refentrytitle></citerefentry>, to <inlineequation><math> <mover><mi mathvariant=\"italic\">v</mi><mo /></mover> </math></inlineequation>, one of the two variables that are evaluated by the equations specified by this command. Initially, <parameter>v1</parameter> is 0 and <parameter>v2</parameter> is 1. </para> </listitem>",
        "vstride": "<listitem> <para> Specifies the number of floats or doubles between the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mi mathvariant=\"italic\">ij</mi> </msub> </math></inlineequation> and the beginning of control point <inlineequation><math> <msub><mi mathvariant=\"italic\">R</mi> <mfenced open=\"\" close=\"\"> <mrow> <mi mathvariant=\"italic\">i</mi> <mo /> <mfenced open=\"(\" close=\")\"> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>+</mo> <mn>1</mn> </mrow> </mfenced> </mrow> </mfenced> </msub> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">j</mi></math></inlineequation> are the <inlineequation><math><mi mathvariant=\"italic\">u</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of <parameter>vstride</parameter> is 0. </para> </listitem>",
        "vorder": "<listitem> <para> Specifies the dimension of the control point array in the <inlineequation><math><mi mathvariant=\"italic\">v</mi></math></inlineequation> axis. Must be positive. The initial value is 1. </para> </listitem>",
        "points": "<listitem> <para> Specifies a pointer to the array of control points. </para> </listitem>"
      }
    },
    "glMapBuffer": {
      "signature": "void * glMapBuffer(GLenum target, GLenum access)",
      "purpose": "map a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object being mapped. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "access": "<listitem> <para> Specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`. </para> </listitem>"
      }
    },
    "glUnmapBuffer": {
      "signature": "GLboolean glUnmapBuffer(GLenum target)",
      "purpose": "map a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target buffer object being mapped. The symbolic constant must be `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, or `GL_PIXEL_UNPACK_BUFFER`. </para> </listitem>",
        "access": "<listitem> <para> Specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`. </para> </listitem>"
      }
    },
    "glMapGrid1d": {
      "signature": "void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)",
      "purpose": "define a one- or two-dimensional mesh",
      "parameters": {
        "un": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>u1</parameter>, <parameter>u2</parameter>]. Must be positive. </para> </listitem>",
        "u1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mi mathvariant=\"italic\">un</mi> </mrow> </math></inlineequation>. </para> </listitem>",
        "vn": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>v1</parameter>, <parameter>v2</parameter>] (<function>glMapGrid2</function> only). </para> </listitem>",
        "v1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mi mathvariant=\"italic\">vn</mi> </mrow> </math></inlineequation> (<function>glMapGrid2</function> only). </para> </listitem>"
      }
    },
    "glMapGrid1f": {
      "signature": "void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)",
      "purpose": "define a one- or two-dimensional mesh",
      "parameters": {
        "un": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>u1</parameter>, <parameter>u2</parameter>]. Must be positive. </para> </listitem>",
        "u1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mi mathvariant=\"italic\">un</mi> </mrow> </math></inlineequation>. </para> </listitem>",
        "vn": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>v1</parameter>, <parameter>v2</parameter>] (<function>glMapGrid2</function> only). </para> </listitem>",
        "v1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mi mathvariant=\"italic\">vn</mi> </mrow> </math></inlineequation> (<function>glMapGrid2</function> only). </para> </listitem>"
      }
    },
    "glMapGrid2d": {
      "signature": "void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)",
      "purpose": "define a one- or two-dimensional mesh",
      "parameters": {
        "un": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>u1</parameter>, <parameter>u2</parameter>]. Must be positive. </para> </listitem>",
        "u1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mi mathvariant=\"italic\">un</mi> </mrow> </math></inlineequation>. </para> </listitem>",
        "vn": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>v1</parameter>, <parameter>v2</parameter>] (<function>glMapGrid2</function> only). </para> </listitem>",
        "v1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mi mathvariant=\"italic\">vn</mi> </mrow> </math></inlineequation> (<function>glMapGrid2</function> only). </para> </listitem>"
      }
    },
    "glMapGrid2f": {
      "signature": "void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)",
      "purpose": "define a one- or two-dimensional mesh",
      "parameters": {
        "un": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>u1</parameter>, <parameter>u2</parameter>]. Must be positive. </para> </listitem>",
        "u1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">i</mi> <mo>=</mo> <mi mathvariant=\"italic\">un</mi> </mrow> </math></inlineequation>. </para> </listitem>",
        "vn": "<listitem> <para> Specifies the number of partitions in the grid range interval [<parameter>v1</parameter>, <parameter>v2</parameter>] (<function>glMapGrid2</function> only). </para> </listitem>",
        "v1": "<listitem> <para> Specify the mappings for integer grid domain values <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mn>0</mn> </mrow> </math></inlineequation> and <inlineequation><math> <mrow> <mi mathvariant=\"italic\">j</mi> <mo>=</mo> <mi mathvariant=\"italic\">vn</mi> </mrow> </math></inlineequation> (<function>glMapGrid2</function> only). </para> </listitem>"
      }
    },
    "glMaterialf": {
      "signature": "void glMaterialf(GLenum face, GLenum pname, GLfloat param)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para> Specifies which face or faces are being updated. Must be one of `GL_FRONT`, `GL_BACK`, or `GL_FRONT_AND_BACK`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter `GL_SHININESS` will be set to. </para> </listitem>"
      }
    },
    "glMateriali": {
      "signature": "void glMateriali(GLenum face, GLenum pname, GLint param)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para> Specifies which face or faces are being updated. Must be one of `GL_FRONT`, `GL_BACK`, or `GL_FRONT_AND_BACK`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter `GL_SHININESS` will be set to. </para> </listitem>"
      }
    },
    "glMaterialfv": {
      "signature": "void glMaterialfv(GLenum face, GLenum pname, const GLfloat * params)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para> Specifies which face or faces are being updated. Must be one of `GL_FRONT`, `GL_BACK`, or `GL_FRONT_AND_BACK`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter `GL_SHININESS` will be set to. </para> </listitem>"
      }
    },
    "glMaterialiv": {
      "signature": "void glMaterialiv(GLenum face, GLenum pname, const GLint * params)",
      "purpose": "specify material parameters for the lighting model",
      "parameters": {
        "face": "<listitem> <para> Specifies which face or faces are being updated. Must be one of `GL_FRONT`, `GL_BACK`, or `GL_FRONT_AND_BACK`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the single-valued material parameter of the face or faces that is being updated. Must be `GL_SHININESS`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that parameter `GL_SHININESS` will be set to. </para> </listitem>"
      }
    },
    "glMatrixMode": {
      "signature": "void glMatrixMode(GLenum mode)",
      "purpose": "specify which matrix is the current matrix",
      "parameters": {
        "mode": "<listitem> <para> Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: `GL_MODELVIEW`, `GL_PROJECTION`, and `GL_TEXTURE`. The initial value is `GL_MODELVIEW`. Additionally, if the <code>ARB_imaging</code> extension is supported, `GL_COLOR` is also accepted. </para> </listitem>"
      }
    },
    "glMinmax": {
      "signature": "void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)",
      "purpose": "define minmax table",
      "parameters": {
        "target": "<listitem> <para> The minmax table whose parameters are to be set. Must be `GL_MINMAX`. </para> </listitem>",
        "internalformat": "<listitem> <para> The format of entries in the minmax table. Must be one of `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "sink": "<listitem> <para> If `GL_TRUE`, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If `GL_FALSE`, pixels will proceed to the final conversion process after minmax. </para> </listitem>"
      }
    },
    "glMultiDrawArrays": {
      "signature": "void glMultiDrawArrays(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount)",
      "purpose": "render multiple sets of primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_QUAD_STRIP`, `GL_QUADS`, and `GL_POLYGON` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Points to an array of starting indices in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Points to an array of the number of indices to be rendered. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the size of the first and count </para> </listitem>"
      }
    },
    "glMultiDrawElements": {
      "signature": "void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void ** indices, GLsizei primcount)",
      "purpose": "render multiple sets of primitives by specifying indices of array data elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_QUAD_STRIP`, `GL_QUADS`, and `GL_POLYGON` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Points to an array of the elements counts. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "primcount": "<listitem> <para> Specifies the size of the <parameter>count</parameter> array. </para> </listitem>"
      }
    },
    "glMultiTexCoord1s": {
      "signature": "void glMultiTexCoord1s(GLenum target, GLshort s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1i": {
      "signature": "void glMultiTexCoord1i(GLenum target, GLint s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1f": {
      "signature": "void glMultiTexCoord1f(GLenum target, GLfloat s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1d": {
      "signature": "void glMultiTexCoord1d(GLenum target, GLdouble s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2s": {
      "signature": "void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2i": {
      "signature": "void glMultiTexCoord2i(GLenum target, GLint s, GLint t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2f": {
      "signature": "void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2d": {
      "signature": "void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3s": {
      "signature": "void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3i": {
      "signature": "void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3f": {
      "signature": "void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3d": {
      "signature": "void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4s": {
      "signature": "void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4i": {
      "signature": "void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4f": {
      "signature": "void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4d": {
      "signature": "void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1sv": {
      "signature": "void glMultiTexCoord1sv(GLenum target, const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1iv": {
      "signature": "void glMultiTexCoord1iv(GLenum target, const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1fv": {
      "signature": "void glMultiTexCoord1fv(GLenum target, const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord1dv": {
      "signature": "void glMultiTexCoord1dv(GLenum target, const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2sv": {
      "signature": "void glMultiTexCoord2sv(GLenum target, const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2iv": {
      "signature": "void glMultiTexCoord2iv(GLenum target, const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2fv": {
      "signature": "void glMultiTexCoord2fv(GLenum target, const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord2dv": {
      "signature": "void glMultiTexCoord2dv(GLenum target, const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3sv": {
      "signature": "void glMultiTexCoord3sv(GLenum target, const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3iv": {
      "signature": "void glMultiTexCoord3iv(GLenum target, const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3fv": {
      "signature": "void glMultiTexCoord3fv(GLenum target, const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord3dv": {
      "signature": "void glMultiTexCoord3dv(GLenum target, const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4sv": {
      "signature": "void glMultiTexCoord4sv(GLenum target, const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4iv": {
      "signature": "void glMultiTexCoord4iv(GLenum target, const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4fv": {
      "signature": "void glMultiTexCoord4fv(GLenum target, const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultiTexCoord4dv": {
      "signature": "void glMultiTexCoord4dv(GLenum target, const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "target": "<listitem> <para> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of `GL_TEXTURE`<inlineequation><math><mi mathvariant=\"italic\">i</mi></math></inlineequation>, where i ranges from 0 to `GL_MAX_TEXTURE_COORDS` - 1, which is an implementation-dependent value. </para> </listitem>",
        "s": "<listitem> <para> Specify <parameter>s</parameter>, <parameter>t</parameter>, <parameter>r</parameter>, and <parameter>q</parameter> texture coordinates for <parameter>target</parameter> texture unit. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glMultMatrixd": {
      "signature": "void glMultMatrixd(const GLdouble * m)",
      "purpose": "multiply the current matrix with the specified matrix",
      "parameters": {
        "m": "<listitem> <para> Points to 16 consecutive values that are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> column-major matrix. </para> </listitem>"
      }
    },
    "glMultMatrixf": {
      "signature": "void glMultMatrixf(const GLfloat * m)",
      "purpose": "multiply the current matrix with the specified matrix",
      "parameters": {
        "m": "<listitem> <para> Points to 16 consecutive values that are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> column-major matrix. </para> </listitem>"
      }
    },
    "glMultTransposeMatrixd": {
      "signature": "void glMultTransposeMatrixd(const GLdouble * m)",
      "purpose": "multiply the current matrix with the specified row-major ordered matrix",
      "parameters": {
        "m": "<listitem> <para> Points to 16 consecutive values that are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> row-major matrix. </para> </listitem>"
      }
    },
    "glMultTransposeMatrixf": {
      "signature": "void glMultTransposeMatrixf(const GLfloat * m)",
      "purpose": "multiply the current matrix with the specified row-major ordered matrix",
      "parameters": {
        "m": "<listitem> <para> Points to 16 consecutive values that are used as the elements of a <inlineequation><math> <mrow> <mn>4</mn> <mo /> <mn>4</mn> </mrow> </math></inlineequation> row-major matrix. </para> </listitem>"
      }
    },
    "glNewList": {
      "signature": "void glNewList(GLuint list, GLenum mode)",
      "purpose": "create or replace a display list",
      "parameters": {
        "list": "<listitem> <para> Specifies the display-list name. </para> </listitem>",
        "mode": "<listitem> <para> Specifies the compilation mode, which can be `GL_COMPILE` or `GL_COMPILE_AND_EXECUTE`. </para> </listitem>"
      }
    },
    "glEndList": {
      "signature": "void glEndList( void)",
      "purpose": "create or replace a display list",
      "parameters": {
        "list": "<listitem> <para> Specifies the display-list name. </para> </listitem>",
        "mode": "<listitem> <para> Specifies the compilation mode, which can be `GL_COMPILE` or `GL_COMPILE_AND_EXECUTE`. </para> </listitem>"
      }
    },
    "glNormal3b": {
      "signature": "void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3d": {
      "signature": "void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3f": {
      "signature": "void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3i": {
      "signature": "void glNormal3i(GLint nx, GLint ny, GLint nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3s": {
      "signature": "void glNormal3s(GLshort nx, GLshort ny, GLshort nz)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3bv": {
      "signature": "void glNormal3bv(const GLbyte * v)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3dv": {
      "signature": "void glNormal3dv(const GLdouble * v)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3fv": {
      "signature": "void glNormal3fv(const GLfloat * v)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3iv": {
      "signature": "void glNormal3iv(const GLint * v)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormal3sv": {
      "signature": "void glNormal3sv(const GLshort * v)",
      "purpose": "set the current normal vector",
      "parameters": {
        "nx": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </para> <para> </para> </listitem>"
      }
    },
    "glNormalPointer": {
      "signature": "void glNormalPointer(GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of normals",
      "parameters": {
        "type": "<listitem> <para> Specifies the data type of each coordinate in the array. Symbolic constants `GL_BYTE`, `GL_SHORT`, `GL_INT`, `GL_FLOAT`, and `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive normals. If <parameter>stride</parameter> is 0, the normals are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glOrtho": {
      "signature": "void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)",
      "purpose": "multiply the current matrix with an orthographic matrix",
      "parameters": {
        "left": "<listitem> <para> Specify the coordinates for the left and right vertical clipping planes. </para> </listitem>",
        "bottom": "<listitem> <para> Specify the coordinates for the bottom and top horizontal clipping planes. </para> </listitem>",
        "nearVal": "<listitem> <para> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </para> </listitem>"
      }
    },
    "glPassThrough": {
      "signature": "void glPassThrough(GLfloat token)",
      "purpose": "place a marker in the feedback buffer",
      "parameters": {
        "token": "<listitem> <para> Specifies a marker value to be placed in the feedback buffer following a `GL_PASS_THROUGH_TOKEN`. </para> </listitem>"
      }
    },
    "glPixelMapfv": {
      "signature": "void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values)",
      "purpose": "set up pixel transfer maps",
      "parameters": {
        "map": "<listitem> <para> Specifies a symbolic map name. Must be one of the following: `GL_PIXEL_MAP_I_TO_I`, `GL_PIXEL_MAP_S_TO_S`, `GL_PIXEL_MAP_I_TO_R`, `GL_PIXEL_MAP_I_TO_G`, `GL_PIXEL_MAP_I_TO_B`, `GL_PIXEL_MAP_I_TO_A`, `GL_PIXEL_MAP_R_TO_R`, `GL_PIXEL_MAP_G_TO_G`, `GL_PIXEL_MAP_B_TO_B`, or `GL_PIXEL_MAP_A_TO_A`. </para> </listitem>",
        "mapsize": "<listitem> <para> Specifies the size of the map being defined. </para> </listitem>",
        "values": "<listitem> <para> Specifies an array of <parameter>mapsize</parameter> values. </para> </listitem>"
      }
    },
    "glPixelMapuiv": {
      "signature": "void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values)",
      "purpose": "set up pixel transfer maps",
      "parameters": {
        "map": "<listitem> <para> Specifies a symbolic map name. Must be one of the following: `GL_PIXEL_MAP_I_TO_I`, `GL_PIXEL_MAP_S_TO_S`, `GL_PIXEL_MAP_I_TO_R`, `GL_PIXEL_MAP_I_TO_G`, `GL_PIXEL_MAP_I_TO_B`, `GL_PIXEL_MAP_I_TO_A`, `GL_PIXEL_MAP_R_TO_R`, `GL_PIXEL_MAP_G_TO_G`, `GL_PIXEL_MAP_B_TO_B`, or `GL_PIXEL_MAP_A_TO_A`. </para> </listitem>",
        "mapsize": "<listitem> <para> Specifies the size of the map being defined. </para> </listitem>",
        "values": "<listitem> <para> Specifies an array of <parameter>mapsize</parameter> values. </para> </listitem>"
      }
    },
    "glPixelMapusv": {
      "signature": "void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values)",
      "purpose": "set up pixel transfer maps",
      "parameters": {
        "map": "<listitem> <para> Specifies a symbolic map name. Must be one of the following: `GL_PIXEL_MAP_I_TO_I`, `GL_PIXEL_MAP_S_TO_S`, `GL_PIXEL_MAP_I_TO_R`, `GL_PIXEL_MAP_I_TO_G`, `GL_PIXEL_MAP_I_TO_B`, `GL_PIXEL_MAP_I_TO_A`, `GL_PIXEL_MAP_R_TO_R`, `GL_PIXEL_MAP_G_TO_G`, `GL_PIXEL_MAP_B_TO_B`, or `GL_PIXEL_MAP_A_TO_A`. </para> </listitem>",
        "mapsize": "<listitem> <para> Specifies the size of the map being defined. </para> </listitem>",
        "values": "<listitem> <para> Specifies an array of <parameter>mapsize</parameter> values. </para> </listitem>"
      }
    },
    "glPixelStoref": {
      "signature": "void glPixelStoref(GLenum pname, GLfloat param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`, `GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`, `GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPixelTransferf": {
      "signature": "void glPixelTransferf(GLenum pname, GLfloat param)",
      "purpose": "set pixel transfer modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: `GL_MAP_COLOR`, `GL_MAP_STENCIL`, `GL_INDEX_SHIFT`, `GL_INDEX_OFFSET`, `GL_RED_SCALE`, `GL_RED_BIAS`, `GL_GREEN_SCALE`, `GL_GREEN_BIAS`, `GL_BLUE_SCALE`, `GL_BLUE_BIAS`, `GL_ALPHA_SCALE`, `GL_ALPHA_BIAS`, `GL_DEPTH_SCALE`, or `GL_DEPTH_BIAS`. </para> <para> Additionally, if the <code>ARB_imaging</code> extension is supported, the following symbolic names are accepted: `GL_POST_COLOR_MATRIX_RED_SCALE`, `GL_POST_COLOR_MATRIX_GREEN_SCALE`, `GL_POST_COLOR_MATRIX_BLUE_SCALE`, `GL_POST_COLOR_MATRIX_ALPHA_SCALE`, `GL_POST_COLOR_MATRIX_RED_BIAS`, `GL_POST_COLOR_MATRIX_GREEN_BIAS`, `GL_POST_COLOR_MATRIX_BLUE_BIAS`, `GL_POST_COLOR_MATRIX_ALPHA_BIAS`, `GL_POST_CONVOLUTION_RED_SCALE`, `GL_POST_CONVOLUTION_GREEN_SCALE`, `GL_POST_CONVOLUTION_BLUE_SCALE`, `GL_POST_CONVOLUTION_ALPHA_SCALE`, `GL_POST_CONVOLUTION_RED_BIAS`, `GL_POST_CONVOLUTION_GREEN_BIAS`, `GL_POST_CONVOLUTION_BLUE_BIAS`, and `GL_POST_CONVOLUTION_ALPHA_BIAS`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPixelTransferi": {
      "signature": "void glPixelTransferi(GLenum pname, GLint param)",
      "purpose": "set pixel transfer modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: `GL_MAP_COLOR`, `GL_MAP_STENCIL`, `GL_INDEX_SHIFT`, `GL_INDEX_OFFSET`, `GL_RED_SCALE`, `GL_RED_BIAS`, `GL_GREEN_SCALE`, `GL_GREEN_BIAS`, `GL_BLUE_SCALE`, `GL_BLUE_BIAS`, `GL_ALPHA_SCALE`, `GL_ALPHA_BIAS`, `GL_DEPTH_SCALE`, or `GL_DEPTH_BIAS`. </para> <para> Additionally, if the <code>ARB_imaging</code> extension is supported, the following symbolic names are accepted: `GL_POST_COLOR_MATRIX_RED_SCALE`, `GL_POST_COLOR_MATRIX_GREEN_SCALE`, `GL_POST_COLOR_MATRIX_BLUE_SCALE`, `GL_POST_COLOR_MATRIX_ALPHA_SCALE`, `GL_POST_COLOR_MATRIX_RED_BIAS`, `GL_POST_COLOR_MATRIX_GREEN_BIAS`, `GL_POST_COLOR_MATRIX_BLUE_BIAS`, `GL_POST_COLOR_MATRIX_ALPHA_BIAS`, `GL_POST_CONVOLUTION_RED_SCALE`, `GL_POST_CONVOLUTION_GREEN_SCALE`, `GL_POST_CONVOLUTION_BLUE_SCALE`, `GL_POST_CONVOLUTION_ALPHA_SCALE`, `GL_POST_CONVOLUTION_RED_BIAS`, `GL_POST_CONVOLUTION_GREEN_BIAS`, `GL_POST_CONVOLUTION_BLUE_BIAS`, and `GL_POST_CONVOLUTION_ALPHA_BIAS`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPixelZoom": {
      "signature": "void glPixelZoom(GLfloat xfactor, GLfloat yfactor)",
      "purpose": "specify the pixel zoom factors",
      "parameters": {
        "xfactor": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation> and <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation> zoom factors for pixel write operations. </para> </listitem>"
      }
    },
    "glPointParameterf": {
      "signature": "void glPointParameterf(GLenum pname, GLfloat param)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glPointParameteri": {
      "signature": "void glPointParameteri(GLenum pname, GLint param)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glPointParameterfv": {
      "signature": "void glPointParameterfv(GLenum pname, const GLfloat * params)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glPointParameteriv": {
      "signature": "void glPointParameteriv(GLenum pname, const GLint * params)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_SIZE_MIN`, `GL_POINT_SIZE_MAX`, `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>"
      }
    },
    "glPointSize": {
      "signature": "void glPointSize(GLfloat size)",
      "purpose": "specify the diameter of rasterized points",
      "parameters": {
        "size": "<listitem> <para> Specifies the diameter of rasterized points. The initial value is 1. </para> </listitem>"
      }
    },
    "glPolygonMode": {
      "signature": "void glPolygonMode(GLenum face, GLenum mode)",
      "purpose": "select a polygon rasterization mode",
      "parameters": {
        "face": "<listitem> <para> Specifies the polygons that <parameter>mode</parameter> applies to. Must be `GL_FRONT` for front-facing polygons, `GL_BACK` for back-facing polygons, or `GL_FRONT_AND_BACK` for front- and back-facing polygons. </para> </listitem>",
        "mode": "<listitem> <para> Specifies how polygons will be rasterized. Accepted values are `GL_POINT`, `GL_LINE`, and `GL_FILL`. The initial value is `GL_FILL` for both front- and back-facing polygons. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth values",
      "parameters": {
        "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
        "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
      }
    },
    "glPolygonStipple": {
      "signature": "void glPolygonStipple(const GLubyte * pattern)",
      "purpose": "set the polygon stippling pattern",
      "parameters": {
        "pattern": "<listitem> <para> Specifies a pointer to a <inlineequation><math> <mrow> <mn>32</mn> <mo /> <mn>32</mn> </mrow> </math></inlineequation> stipple pattern that will be unpacked from memory in the same way that <citerefentry><refentrytitle>glDrawPixels</refentrytitle></citerefentry> unpacks pixels. </para> </listitem>"
      }
    },
    "glPrioritizeTextures": {
      "signature": "void glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities)",
      "purpose": "set texture residence priority",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be prioritized. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array containing the names of the textures to be prioritized. </para> </listitem>",
        "priorities": "<listitem> <para> Specifies an array containing the texture priorities. A priority given in an element of <parameter>priorities</parameter> applies to the texture named by the corresponding element of <parameter>textures</parameter>. </para> </listitem>"
      }
    },
    "glPushAttrib": {
      "signature": "void glPushAttrib(GLbitfield mask)",
      "purpose": "push and pop the server attribute stack",
      "parameters": {
        "mask": "<listitem> <para> Specifies a mask that indicates which attributes to save. Values for <parameter>mask</parameter> are listed below. </para> </listitem>"
      }
    },
    "glPopAttrib": {
      "signature": "void glPopAttrib( void)",
      "purpose": "push and pop the server attribute stack",
      "parameters": {
        "mask": "<listitem> <para> Specifies a mask that indicates which attributes to save. Values for <parameter>mask</parameter> are listed below. </para> </listitem>"
      }
    },
    "glPushClientAttrib": {
      "signature": "void glPushClientAttrib(GLbitfield mask)",
      "purpose": "push and pop the client attribute stack",
      "parameters": {
        "mask": "<listitem> <para> Specifies a mask that indicates which attributes to save. Values for <parameter>mask</parameter> are listed below. </para> </listitem>"
      }
    },
    "glPopClientAttrib": {
      "signature": "void glPopClientAttrib( void)",
      "purpose": "push and pop the client attribute stack",
      "parameters": {
        "mask": "<listitem> <para> Specifies a mask that indicates which attributes to save. Values for <parameter>mask</parameter> are listed below. </para> </listitem>"
      }
    },
    "glPushMatrix": {
      "signature": "void glPushMatrix( void)",
      "purpose": "push and pop the current matrix stack",
      "parameters": {}
    },
    "glPopMatrix": {
      "signature": "void glPopMatrix( void)",
      "purpose": "push and pop the current matrix stack",
      "parameters": {}
    },
    "glPushName": {
      "signature": "void glPushName(GLuint name)",
      "purpose": "push and pop the name stack",
      "parameters": {
        "name": "<listitem> <para> Specifies a name that will be pushed onto the name stack. </para> </listitem>"
      }
    },
    "glPopName": {
      "signature": "void glPopName( void)",
      "purpose": "push and pop the name stack",
      "parameters": {
        "name": "<listitem> <para> Specifies a name that will be pushed onto the name stack. </para> </listitem>"
      }
    },
    "glRasterPos2s": {
      "signature": "void glRasterPos2s(GLshort x, GLshort y)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2i": {
      "signature": "void glRasterPos2i(GLint x, GLint y)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2f": {
      "signature": "void glRasterPos2f(GLfloat x, GLfloat y)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2d": {
      "signature": "void glRasterPos2d(GLdouble x, GLdouble y)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3s": {
      "signature": "void glRasterPos3s(GLshort x, GLshort y, GLshort z)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3i": {
      "signature": "void glRasterPos3i(GLint x, GLint y, GLint z)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3f": {
      "signature": "void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3d": {
      "signature": "void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4s": {
      "signature": "void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4i": {
      "signature": "void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4f": {
      "signature": "void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4d": {
      "signature": "void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2sv": {
      "signature": "void glRasterPos2sv(const GLshort * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2iv": {
      "signature": "void glRasterPos2iv(const GLint * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2fv": {
      "signature": "void glRasterPos2fv(const GLfloat * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos2dv": {
      "signature": "void glRasterPos2dv(const GLdouble * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3sv": {
      "signature": "void glRasterPos3sv(const GLshort * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3iv": {
      "signature": "void glRasterPos3iv(const GLint * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3fv": {
      "signature": "void glRasterPos3fv(const GLfloat * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos3dv": {
      "signature": "void glRasterPos3dv(const GLdouble * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4sv": {
      "signature": "void glRasterPos4sv(const GLshort * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4iv": {
      "signature": "void glRasterPos4iv(const GLint * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4fv": {
      "signature": "void glRasterPos4fv(const GLfloat * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glRasterPos4dv": {
      "signature": "void glRasterPos4dv(const GLdouble * v)",
      "purpose": "specify the raster position for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation>, and <inlineequation><math><mi mathvariant=\"italic\">w</mi></math></inlineequation> object coordinates (if present) for the raster position. </para> </listitem>"
      }
    },
    "glReadBuffer": {
      "signature": "void glReadBuffer(GLenum mode)",
      "purpose": "select a color buffer source for pixels",
      "parameters": {
        "mode": "<listitem> <para> Specifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_AUX`<emphasis>i</emphasis>, where <emphasis>i</emphasis> is between 0 and the value of `GL_AUX_BUFFERS` minus 1. </para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para> Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Returns the pixel data. </para> </listitem>"
      }
    },
    "glRectd": {
      "signature": "void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRectf": {
      "signature": "void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRecti": {
      "signature": "void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRects": {
      "signature": "void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRectdv": {
      "signature": "void glRectdv(const GLdouble * v1, const GLdouble * v2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRectfv": {
      "signature": "void glRectfv(const GLfloat * v1, const GLfloat * v2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRectiv": {
      "signature": "void glRectiv(const GLint * v1, const GLint * v2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRectsv": {
      "signature": "void glRectsv(const GLshort * v1, const GLshort * v2)",
      "purpose": "draw a rectangle",
      "parameters": {
        "x1": "<listitem> <para> Specify one vertex of a rectangle. </para> </listitem>",
        "x2": "<listitem> <para> Specify the opposite vertex of the rectangle. </para> </listitem>"
      }
    },
    "glRenderMode": {
      "signature": "GLint glRenderMode(GLenum mode)",
      "purpose": "set rasterization mode",
      "parameters": {
        "mode": "<listitem> <para> Specifies the rasterization mode. Three values are accepted: `GL_RENDER`, `GL_SELECT`, and `GL_FEEDBACK`. The initial value is `GL_RENDER`. </para> </listitem>"
      }
    },
    "glResetHistogram": {
      "signature": "void glResetHistogram(GLenum target)",
      "purpose": "reset histogram table entries to zero",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_HISTOGRAM`. </para> </listitem>"
      }
    },
    "glResetMinmax": {
      "signature": "void glResetMinmax(GLenum target)",
      "purpose": "reset minmax table entries to initial values",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_MINMAX`. </para> </listitem>"
      }
    },
    "glRotated": {
      "signature": "void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)",
      "purpose": "multiply the current matrix by a rotation matrix",
      "parameters": {
        "angle": "<listitem> <para> Specifies the angle of rotation, in degrees. </para> </listitem>",
        "x": "<listitem> <para> Specify the <emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>z</emphasis> coordinates of a vector, respectively. </para> </listitem>"
      }
    },
    "glRotatef": {
      "signature": "void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "multiply the current matrix by a rotation matrix",
      "parameters": {
        "angle": "<listitem> <para> Specifies the angle of rotation, in degrees. </para> </listitem>",
        "x": "<listitem> <para> Specify the <emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>z</emphasis> coordinates of a vector, respectively. </para> </listitem>"
      }
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLclampf value, GLboolean invert)",
      "purpose": "specify multisample coverage parameters",
      "parameters": {
        "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
        "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glScaled": {
      "signature": "void glScaled(GLdouble x, GLdouble y, GLdouble z)",
      "purpose": "multiply the current matrix by a general scaling matrix",
      "parameters": {
        "x": "<listitem> <para> Specify scale factors along the <emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>z</emphasis> axes, respectively. </para> </listitem>"
      }
    },
    "glScalef": {
      "signature": "void glScalef(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "multiply the current matrix by a general scaling matrix",
      "parameters": {
        "x": "<listitem> <para> Specify scale factors along the <emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>z</emphasis> axes, respectively. </para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glSecondaryColor3b": {
      "signature": "void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3s": {
      "signature": "void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3i": {
      "signature": "void glSecondaryColor3i(GLint red, GLint green, GLint blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3f": {
      "signature": "void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3d": {
      "signature": "void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3ub": {
      "signature": "void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3us": {
      "signature": "void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3ui": {
      "signature": "void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3bv": {
      "signature": "void glSecondaryColor3bv(const GLbyte * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3sv": {
      "signature": "void glSecondaryColor3sv(const GLshort * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3iv": {
      "signature": "void glSecondaryColor3iv(const GLint * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3fv": {
      "signature": "void glSecondaryColor3fv(const GLfloat * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3dv": {
      "signature": "void glSecondaryColor3dv(const GLdouble * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3ubv": {
      "signature": "void glSecondaryColor3ubv(const GLubyte * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3usv": {
      "signature": "void glSecondaryColor3usv(const GLushort * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColor3uiv": {
      "signature": "void glSecondaryColor3uiv(const GLuint * v)",
      "purpose": "set the current secondary color",
      "parameters": {
        "red": "<listitem> <para> Specify new red, green, and blue values for the current secondary color. </para> </listitem>"
      }
    },
    "glSecondaryColorPointer": {
      "signature": "void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of secondary colors",
      "parameters": {
        "size": "<listitem> <para> Specifies the number of components per color. Must be 3. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of each color component in the array. Symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_FLOAT`, or `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive colors. If <parameter>stride</parameter> is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glSelectBuffer": {
      "signature": "void glSelectBuffer(GLsizei size, GLuint * buffer)",
      "purpose": "establish a buffer for selection mode values",
      "parameters": {
        "size": "<listitem> <para> Specifies the size of <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Returns the selection data. </para> </listitem>"
      }
    },
    "glSeparableFilter2D": {
      "signature": "void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column)",
      "purpose": "define a separable two-dimensional convolution filter",
      "parameters": {
        "target": "<listitem> <para> Must be `GL_SEPARABLE_2D`. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format of the convolution filter kernel. The allowable values are `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, or `GL_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> The number of elements in the pixel array referenced by <parameter>row</parameter>. (This is the width of the separable filter kernel.) </para> </listitem>",
        "height": "<listitem> <para> The number of elements in the pixel array referenced by <parameter>column</parameter>. (This is the height of the separable filter kernel.) </para> </listitem>",
        "format": "<listitem> <para> The format of the pixel data in <parameter>row</parameter> and <parameter>column</parameter>. The allowable values are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_INTENSITY`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> The type of the pixel data in <parameter>row</parameter> and <parameter>column</parameter>. Symbolic constants `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV` are accepted. </para> </listitem>",
        "row": "<listitem> <para> Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel. </para> </listitem>",
        "column": "<listitem> <para> Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel. </para> </listitem>"
      }
    },
    "glShadeModel": {
      "signature": "void glShadeModel(GLenum mode)",
      "purpose": "select flat or smooth shading",
      "parameters": {
        "mode": "<listitem> <para> Specifies a symbolic value representing a shading technique. Accepted values are `GL_FLAT` and `GL_SMOOTH`. The initial value is `GL_SMOOTH`. </para> </listitem>"
      }
    },
    "glShaderSource": {
      "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)",
      "purpose": "Replaces the source code in a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
        "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
        "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and back function and reference value for stencil testing",
      "parameters": {
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilFuncSeparate": {
      "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and/or back function and reference value for stencil testing",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the front and back writing of individual bits in the stencil planes",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilMaskSeparate": {
      "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
      "purpose": "control the front and/or back writing of individual bits in the stencil planes",
      "parameters": {
        "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and back stencil test actions",
      "parameters": {
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glStencilOpSeparate": {
      "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and/or back stencil test actions",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glTexCoord1s": {
      "signature": "void glTexCoord1s(GLshort s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1i": {
      "signature": "void glTexCoord1i(GLint s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1f": {
      "signature": "void glTexCoord1f(GLfloat s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1d": {
      "signature": "void glTexCoord1d(GLdouble s)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2s": {
      "signature": "void glTexCoord2s(GLshort s, GLshort t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2i": {
      "signature": "void glTexCoord2i(GLint s, GLint t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2f": {
      "signature": "void glTexCoord2f(GLfloat s, GLfloat t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2d": {
      "signature": "void glTexCoord2d(GLdouble s, GLdouble t)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3s": {
      "signature": "void glTexCoord3s(GLshort s, GLshort t, GLshort r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3i": {
      "signature": "void glTexCoord3i(GLint s, GLint t, GLint r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3f": {
      "signature": "void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3d": {
      "signature": "void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4s": {
      "signature": "void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4i": {
      "signature": "void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4f": {
      "signature": "void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4d": {
      "signature": "void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1sv": {
      "signature": "void glTexCoord1sv(const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1iv": {
      "signature": "void glTexCoord1iv(const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1fv": {
      "signature": "void glTexCoord1fv(const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord1dv": {
      "signature": "void glTexCoord1dv(const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2sv": {
      "signature": "void glTexCoord2sv(const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2iv": {
      "signature": "void glTexCoord2iv(const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2fv": {
      "signature": "void glTexCoord2fv(const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord2dv": {
      "signature": "void glTexCoord2dv(const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3sv": {
      "signature": "void glTexCoord3sv(const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3iv": {
      "signature": "void glTexCoord3iv(const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3fv": {
      "signature": "void glTexCoord3fv(const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord3dv": {
      "signature": "void glTexCoord3dv(const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4sv": {
      "signature": "void glTexCoord4sv(const GLshort * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4iv": {
      "signature": "void glTexCoord4iv(const GLint * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4fv": {
      "signature": "void glTexCoord4fv(const GLfloat * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoord4dv": {
      "signature": "void glTexCoord4dv(const GLdouble * v)",
      "purpose": "set the current texture coordinates",
      "parameters": {
        "s": "<listitem> <para> Specify <emphasis>s</emphasis>, <emphasis>t</emphasis>, <emphasis>r</emphasis>, and <emphasis>q</emphasis> texture coordinates. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glTexCoordPointer": {
      "signature": "void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of texture coordinates",
      "parameters": {
        "size": "<listitem> <para> Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of each texture coordinate. Symbolic constants `GL_SHORT`, `GL_INT`, `GL_FLOAT`, or `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive texture coordinate sets. If <parameter>stride</parameter> is 0, the array elements are understood to be tightly packed. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glTexEnvf": {
      "signature": "void glTexEnvf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV`, `GL_TEXTURE_FILTER_CONTROL` or `GL_POINT_SPRITE`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnvi": {
      "signature": "void glTexEnvi(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV`, `GL_TEXTURE_FILTER_CONTROL` or `GL_POINT_SPRITE`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnvfv": {
      "signature": "void glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV`, `GL_TEXTURE_FILTER_CONTROL` or `GL_POINT_SPRITE`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexEnviv": {
      "signature": "void glTexEnviv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture environment parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies a texture environment. May be `GL_TEXTURE_ENV`, `GL_TEXTURE_FILTER_CONTROL` or `GL_POINT_SPRITE`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture environment parameter. May be either `GL_TEXTURE_ENV_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_COMBINE_RGB`, `GL_COMBINE_ALPHA`, `GL_SRC0_RGB`, `GL_SRC1_RGB`, `GL_SRC2_RGB`, `GL_SRC0_ALPHA`, `GL_SRC1_ALPHA`, `GL_SRC2_ALPHA`, `GL_OPERAND0_RGB`, `GL_OPERAND1_RGB`, `GL_OPERAND2_RGB`, `GL_OPERAND0_ALPHA`, `GL_OPERAND1_ALPHA`, `GL_OPERAND2_ALPHA`, `GL_RGB_SCALE`, `GL_ALPHA_SCALE`, or `GL_COORD_REPLACE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single symbolic constant, one of `GL_ADD`, `GL_ADD_SIGNED`, `GL_INTERPOLATE`, `GL_MODULATE`, `GL_DECAL`, `GL_BLEND`, `GL_REPLACE`, `GL_SUBTRACT`, `GL_COMBINE`, `GL_TEXTURE`, `GL_CONSTANT`, `GL_PRIMARY_COLOR`, `GL_PREVIOUS`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the `GL_RGB_SCALE` or `GL_ALPHA_SCALE`. </para> </listitem>"
      }
    },
    "glTexGeni": {
      "signature": "void glTexGeni(GLenum coord, GLenum pname, GLint param)",
      "purpose": "control the generation of texture coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be one of `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the texture-coordinate generation function. Must be `GL_TEXTURE_GEN_MODE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single-valued texture generation parameter, one of `GL_OBJECT_LINEAR`, `GL_EYE_LINEAR`, `GL_SPHERE_MAP`, `GL_NORMAL_MAP`, or `GL_REFLECTION_MAP`. </para> </listitem>"
      }
    },
    "glTexGenf": {
      "signature": "void glTexGenf(GLenum coord, GLenum pname, GLfloat param)",
      "purpose": "control the generation of texture coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be one of `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the texture-coordinate generation function. Must be `GL_TEXTURE_GEN_MODE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single-valued texture generation parameter, one of `GL_OBJECT_LINEAR`, `GL_EYE_LINEAR`, `GL_SPHERE_MAP`, `GL_NORMAL_MAP`, or `GL_REFLECTION_MAP`. </para> </listitem>"
      }
    },
    "glTexGend": {
      "signature": "void glTexGend(GLenum coord, GLenum pname, GLdouble param)",
      "purpose": "control the generation of texture coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be one of `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the texture-coordinate generation function. Must be `GL_TEXTURE_GEN_MODE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single-valued texture generation parameter, one of `GL_OBJECT_LINEAR`, `GL_EYE_LINEAR`, `GL_SPHERE_MAP`, `GL_NORMAL_MAP`, or `GL_REFLECTION_MAP`. </para> </listitem>"
      }
    },
    "glTexGeniv": {
      "signature": "void glTexGeniv(GLenum coord, GLenum pname, const GLint * params)",
      "purpose": "control the generation of texture coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be one of `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the texture-coordinate generation function. Must be `GL_TEXTURE_GEN_MODE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single-valued texture generation parameter, one of `GL_OBJECT_LINEAR`, `GL_EYE_LINEAR`, `GL_SPHERE_MAP`, `GL_NORMAL_MAP`, or `GL_REFLECTION_MAP`. </para> </listitem>"
      }
    },
    "glTexGenfv": {
      "signature": "void glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params)",
      "purpose": "control the generation of texture coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be one of `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the texture-coordinate generation function. Must be `GL_TEXTURE_GEN_MODE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single-valued texture generation parameter, one of `GL_OBJECT_LINEAR`, `GL_EYE_LINEAR`, `GL_SPHERE_MAP`, `GL_NORMAL_MAP`, or `GL_REFLECTION_MAP`. </para> </listitem>"
      }
    },
    "glTexGendv": {
      "signature": "void glTexGendv(GLenum coord, GLenum pname, const GLdouble * params)",
      "purpose": "control the generation of texture coordinates",
      "parameters": {
        "coord": "<listitem> <para> Specifies a texture coordinate. Must be one of `GL_S`, `GL_T`, `GL_R`, or `GL_Q`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of the texture-coordinate generation function. Must be `GL_TEXTURE_GEN_MODE`. </para> </listitem>",
        "param": "<listitem> <para> Specifies a single-valued texture generation parameter, one of `GL_OBJECT_LINEAR`, `GL_EYE_LINEAR`, `GL_SPHERE_MAP`, `GL_NORMAL_MAP`, or `GL_REFLECTION_MAP`. </para> </listitem>"
      }
    },
    "glTexImage1D": {
      "signature": "void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a one-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_COMPRESSED_ALPHA`, `GL_COMPRESSED_LUMINANCE`, `GL_COMPRESSED_LUMINANCE_ALPHA`, `GL_COMPRESSED_INTENSITY`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SLUMINANCE`, `GL_SLUMINANCE8`, `GL_SLUMINANCE_ALPHA`, `GL_SLUMINANCE8_ALPHA8`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_COMPRESSED_ALPHA`, `GL_COMPRESSED_LUMINANCE`, `GL_COMPRESSED_LUMINANCE_ALPHA`, `GL_COMPRESSED_INTENSITY`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SLUMINANCE`, `GL_SLUMINANCE8`, `GL_SLUMINANCE_ALPHA`, `GL_SLUMINANCE8_ALPHA8`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support texture images that are at least 64 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">m</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">m</mi></math></inlineequation>. All implementations support texture images that are at least 64 texels high. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage3D": {
      "signature": "void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math> <msup><mi mathvariant=\"italic\">n</mi> <mi mathvariant=\"italic\">th</mi> </msup> </math></inlineequation> mipmap reduction image. </para> </listitem>",
        "internalFormat": "<listitem> <para> Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: `GL_ALPHA`, `GL_ALPHA4`, `GL_ALPHA8`, `GL_ALPHA12`, `GL_ALPHA16`, `GL_COMPRESSED_ALPHA`, `GL_COMPRESSED_LUMINANCE`, `GL_COMPRESSED_LUMINANCE_ALPHA`, `GL_COMPRESSED_INTENSITY`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`, `GL_LUMINANCE`, `GL_LUMINANCE4`, `GL_LUMINANCE8`, `GL_LUMINANCE12`, `GL_LUMINANCE16`, `GL_LUMINANCE_ALPHA`, `GL_LUMINANCE4_ALPHA4`, `GL_LUMINANCE6_ALPHA2`, `GL_LUMINANCE8_ALPHA8`, `GL_LUMINANCE12_ALPHA4`, `GL_LUMINANCE12_ALPHA12`, `GL_LUMINANCE16_ALPHA16`, `GL_INTENSITY`, `GL_INTENSITY4`, `GL_INTENSITY8`, `GL_INTENSITY12`, `GL_INTENSITY16`, `GL_R3_G3_B2`, `GL_RGB`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SLUMINANCE`, `GL_SLUMINANCE8`, `GL_SLUMINANCE_ALPHA`, `GL_SLUMINANCE8_ALPHA8`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">n</mi></math></inlineequation>. All implementations support 3D texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">m</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">m</mi></math></inlineequation>. All implementations support 3D texture images that are at least 16 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be <inlineequation><math> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">k</mi> </msup> <mo>+</mo> <mrow> <mn>2</mn> <mo /> <mfenced open=\"(\" close=\")\"> <mi mathvariant=\"italic\">border</mi> </mfenced> </mrow> </mrow> </math></inlineequation> for some integer <inlineequation><math><mi mathvariant=\"italic\">k</mi></math></inlineequation>. All implementations support 3D texture images that are at least 16 texels deep. </para> </listitem>",
        "border": "<listitem> <para> Specifies the width of the border. Must be either 0 or 1. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_PRIORITY`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_DEPTH_TEXTURE_MODE`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_PRIORITY`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_DEPTH_TEXTURE_MODE`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_PRIORITY`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_DEPTH_TEXTURE_MODE`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture, which must be either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_PRIORITY`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_DEPTH_TEXTURE_MODE`, or `GL_GENERATE_MIPMAP`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value of <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glTexSubImage1D": {
      "signature": "void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a one-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage3D": {
      "signature": "void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_COLOR_INDEX`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_LUMINANCE`, and `GL_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_BITMAP`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTranslated": {
      "signature": "void glTranslated(GLdouble x, GLdouble y, GLdouble z)",
      "purpose": "multiply the current matrix by a translation matrix",
      "parameters": {
        "x": "<listitem> <para> Specify the <emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>z</emphasis> coordinates of a translation vector. </para> </listitem>"
      }
    },
    "glTranslatef": {
      "signature": "void glTranslatef(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "multiply the current matrix by a translation matrix",
      "parameters": {
        "x": "<listitem> <para> Specify the <emphasis>x</emphasis>, <emphasis>y</emphasis>, and <emphasis>z</emphasis> coordinates of a translation vector. </para> </listitem>"
      }
    },
    "gluBeginCurve": {
      "signature": "void gluBeginCurve(GLUnurbs* nurb)",
      "purpose": "delimit a NURBS curve definition",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluEndCurve": {
      "signature": "void gluEndCurve(GLUnurbs* nurb)",
      "purpose": "delimit a NURBS curve definition",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluBeginPolygon": {
      "signature": "void gluBeginPolygon(GLUtesselator* tess)",
      "purpose": "delimit a polygon description",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluEndPolygon": {
      "signature": "void gluEndPolygon(GLUtesselator* tess)",
      "purpose": "delimit a polygon description",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluBeginSurface": {
      "signature": "void gluBeginSurface(GLUnurbs* nurb)",
      "purpose": "delimit a NURBS surface definition",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluEndSurface": {
      "signature": "void gluEndSurface(GLUnurbs* nurb)",
      "purpose": "delimit a NURBS surface definition",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluBeginTrim": {
      "signature": "void gluBeginTrim(GLUnurbs* nurb)",
      "purpose": "delimit a NURBS trimming loop definition",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluEndTrim": {
      "signature": "void gluEndTrim(GLUnurbs* nurb)",
      "purpose": "delimit a NURBS trimming loop definition",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluBuild1DMipmapLevels": {
      "signature": "GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void * data)",
      "purpose": "builds a subset of one-dimensional mipmap levels",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GLU_TEXTURE_1D`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Requests the internal storage format of the texture image. The most current version of the SGI implementation of GLU does not check this value for validity before passing it on to the underlying OpenGL implementation. A value that is not accepted by the OpenGL implementation will lead to an OpenGL error. The benefit of not checking this value at the GLU level is that OpenGL extensions can add new internal texture formats without requiring a revision of the GLU implementation. Older implementations of GLU check this value and raise a GLU error if it is not 1, 2, 3, or 4 or one of the following symbolic constants: `GLU_ALPHA`, `GLU_ALPHA4`, `GLU_ALPHA8`, `GLU_ALPHA12`, `GLU_ALPHA16`, `GLU_LUMINANCE`, `GLU_LUMINANCE4`, `GLU_LUMINANCE8`, `GLU_LUMINANCE12`, `GLU_LUMINANCE16`, `GLU_LUMINANCE_ALPHA`, `GLU_LUMINANCE4_ALPHA4`, `GLU_LUMINANCE6_ALPHA2`, `GLU_LUMINANCE8_ALPHA8`, `GLU_LUMINANCE12_ALPHA4`, `GLU_LUMINANCE12_ALPHA12`, `GLU_LUMINANCE16_ALPHA16`, `GLU_INTENSITY`, `GLU_INTENSITY4`, `GLU_INTENSITY8`, `GLU_INTENSITY12`, `GLU_INTENSITY16`, `GLU_RGB`, `GLU_R3_G3_B2`, `GLU_RGB4`, `GLU_RGB5`, `GLU_RGB8`, `GLU_RGB10`, `GLU_RGB12`, `GLU_RGB16`, `GLU_RGBA`, `GLU_RGBA2`, `GLU_RGBA4`, `GLU_RGB5_A1`, `GLU_RGBA8`, `GLU_RGB10_A2`, `GLU_RGBA12`, or `GLU_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width in pixels of the texture image. This should be a power of 2. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Must be one of: `GLU_COLOR_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, or `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Must be one of: `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the image data. </para> </listitem>",
        "base": "<listitem> <para> Specifies the minimum mipmap level to pass to <citerefentry><refentrytitle>glTexImage1D</refentrytitle></citerefentry>. </para> </listitem>",
        "max": "<listitem> <para> Specifies the maximum mipmap level to pass to <citerefentry><refentrytitle>glTexImage1D</refentrytitle></citerefentry>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "gluBuild1DMipmaps": {
      "signature": "GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void * data)",
      "purpose": "builds a one-dimensional mipmap",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GLU_TEXTURE_1D`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Requests the internal storage format of the texture image. The most current version of the SGI implementation of GLU does not check this value for validity before passing it on to the underlying OpenGL implementation. A value that is not accepted by the OpenGL implementation will lead to an OpenGL error. The benefit of not checking this value at the GLU level is that OpenGL extensions can add new internal texture formats without requiring a revision of the GLU implementation. Older implementations of GLU check this value and raise a GLU error if it is not 1, 2, 3, or 4 or one of the following symbolic constants: `GLU_ALPHA`, `GLU_ALPHA4`, `GLU_ALPHA8`, `GLU_ALPHA12`, `GLU_ALPHA16`, `GLU_LUMINANCE`, `GLU_LUMINANCE4`, `GLU_LUMINANCE8`, `GLU_LUMINANCE12`, `GLU_LUMINANCE16`, `GLU_LUMINANCE_ALPHA`, `GLU_LUMINANCE4_ALPHA4`, `GLU_LUMINANCE6_ALPHA2`, `GLU_LUMINANCE8_ALPHA8`, `GLU_LUMINANCE12_ALPHA4`, `GLU_LUMINANCE12_ALPHA12`, `GLU_LUMINANCE16_ALPHA16`, `GLU_INTENSITY`, `GLU_INTENSITY4`, `GLU_INTENSITY8`, `GLU_INTENSITY12`, `GLU_INTENSITY16`, `GLU_RGB`, `GLU_R3_G3_B2`, `GLU_RGB4`, `GLU_RGB5`, `GLU_RGB8`, `GLU_RGB10`, `GLU_RGB12`, `GLU_RGB16`, `GLU_RGBA`, `GLU_RGBA2`, `GLU_RGBA4`, `GLU_RGB5_A1`, `GLU_RGBA8`, `GLU_RGB10_A2`, `GLU_RGBA12`, or `GLU_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width, in pixels, of the texture image. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Must be one of `GLU_COLOR_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, or `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Must be one of `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "gluBuild2DMipmapLevels": {
      "signature": "GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void * data)",
      "purpose": "builds a subset of two-dimensional mipmap levels",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GLU_TEXTURE_2D`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Requests the internal storage format of the texture image. The most current version of the SGI implementation of GLU does not check this value for validity before passing it on to the underlying OpenGL implementation. A value that is not accepted by the OpenGL implementation will lead to an OpenGL error. The benefit of not checking this value at the GLU level is that OpenGL extensions can add new internal texture formats without requiring a revision of the GLU implementation. Older implementations of GLU check this value and raise a GLU error if it is not 1, 2, 3, or 4 or one of the following symbolic constants: `GLU_ALPHA`, `GLU_ALPHA4`, `GLU_ALPHA8`, `GLU_ALPHA12`, `GLU_ALPHA16`, `GLU_LUMINANCE`, `GLU_LUMINANCE4`, `GLU_LUMINANCE8`, `GLU_LUMINANCE12`, `GLU_LUMINANCE16`, `GLU_LUMINANCE_ALPHA`, `GLU_LUMINANCE4_ALPHA4`, `GLU_LUMINANCE6_ALPHA2`, `GLU_LUMINANCE8_ALPHA8`, `GLU_LUMINANCE12_ALPHA4`, `GLU_LUMINANCE12_ALPHA12`, `GLU_LUMINANCE16_ALPHA16`, `GLU_INTENSITY`, `GLU_INTENSITY4`, `GLU_INTENSITY8`, `GLU_INTENSITY12`, `GLU_INTENSITY16`, `GLU_RGB`, `GLU_R3_G3_B2`, `GLU_RGB4`, `GLU_RGB5`, `GLU_RGB8`, `GLU_RGB10`, `GLU_RGB12`, `GLU_RGB16`, `GLU_RGBA`, `GLU_RGBA2`, `GLU_RGBA4`, `GLU_RGB5_A1`, `GLU_RGBA8`, `GLU_RGB10_A2`, `GLU_RGBA12`, or `GLU_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width and height, respectively, in pixels of the texture image. These should be a power of 2. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Must be one of `GLU_COLOR_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, or `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Must be one of `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the image data. </para> </listitem>",
        "base": "<listitem> <para> Specifies the minimum mipmap level to pass to <citerefentry><refentrytitle>glTexImage2D</refentrytitle></citerefentry>. </para> </listitem>",
        "max": "<listitem> <para> Specifies the maximum mipmap level to pass to <citerefentry><refentrytitle>glTexImage2D</refentrytitle></citerefentry>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "gluBuild2DMipmaps": {
      "signature": "GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data)",
      "purpose": "builds a two-dimensional mipmap",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GLU_TEXTURE_2D`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Requests the internal storage format of the texture image. The most current version of the SGI implementation of GLU does not check this value for validity before passing it on to the underlying OpenGL implementation. A value that is not accepted by the OpenGL implementation will lead to an OpenGL error. The benefit of not checking this value at the GLU level is that OpenGL extensions can add new internal texture formats without requiring a revision of the GLU implementation. Older implementations of GLU check this value and raise a GLU error if it is not 1, 2, 3, or 4 or one of the following symbolic constants: `GLU_ALPHA`, `GLU_ALPHA4`, `GLU_ALPHA8`, `GLU_ALPHA12`, `GLU_ALPHA16`, `GLU_LUMINANCE`, `GLU_LUMINANCE4`, `GLU_LUMINANCE8`, `GLU_LUMINANCE12`, `GLU_LUMINANCE16`, `GLU_LUMINANCE_ALPHA`, `GLU_LUMINANCE4_ALPHA4`, `GLU_LUMINANCE6_ALPHA2`, `GLU_LUMINANCE8_ALPHA8`, `GLU_LUMINANCE12_ALPHA4`, `GLU_LUMINANCE12_ALPHA12`, `GLU_LUMINANCE16_ALPHA16`, `GLU_INTENSITY`, `GLU_INTENSITY4`, `GLU_INTENSITY8`, `GLU_INTENSITY12`, `GLU_INTENSITY16`, `GLU_RGB`, `GLU_R3_G3_B2`, `GLU_RGB4`, `GLU_RGB5`, `GLU_RGB8`, `GLU_RGB10`, `GLU_RGB12`, `GLU_RGB16`, `GLU_RGBA`, `GLU_RGBA2`, `GLU_RGBA4`, `GLU_RGB5_A1`, `GLU_RGBA8`, `GLU_RGB10_A2`, `GLU_RGBA12`, or `GLU_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> Specifies in pixels the width and height, respectively, of the texture image. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Must be one of `GLU_COLOR_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, or `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Must be one of `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "gluBuild3DMipmapLevels": {
      "signature": "GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void * data)",
      "purpose": "builds a subset of three-dimensional mipmap levels",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GLU_TEXTURE_3D`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Requests the internal storage format of the texture image. The most current version of the SGI implementation of GLU does not check this value for validity before passing it on to the underlying OpenGL implementation. A value that is not accepted by the OpenGL implementation will lead to an OpenGL error. The benefit of not checking this value at the GLU level is that OpenGL extensions can add new internal texture formats without requiring a revision of the GLU implementation. Older implementations of GLU check this value and raise a GLU error if it is not 1, 2, 3, or 4 or one of the following symbolic constants: `GLU_ALPHA`, `GLU_ALPHA4`, `GLU_ALPHA8`, `GLU_ALPHA12`, `GLU_ALPHA16`, `GLU_LUMINANCE`, `GLU_LUMINANCE4`, `GLU_LUMINANCE8`, `GLU_LUMINANCE12`, `GLU_LUMINANCE16`, `GLU_LUMINANCE_ALPHA`, `GLU_LUMINANCE4_ALPHA4`, `GLU_LUMINANCE6_ALPHA2`, `GLU_LUMINANCE8_ALPHA8`, `GLU_LUMINANCE12_ALPHA4`, `GLU_LUMINANCE12_ALPHA12`, `GLU_LUMINANCE16_ALPHA16`, `GLU_INTENSITY`, `GLU_INTENSITY4`, `GLU_INTENSITY8`, `GLU_INTENSITY12`, `GLU_INTENSITY16`, `GLU_RGB`, `GLU_R3_G3_B2`, `GLU_RGB4`, `GLU_RGB5`, `GLU_RGB8`, `GLU_RGB10`, `GLU_RGB12`, `GLU_RGB16`, `GLU_RGBA`, `GLU_RGBA2`, `GLU_RGBA4`, `GLU_RGB5_A1`, `GLU_RGBA8`, `GLU_RGB10_A2`, `GLU_RGBA12`, or `GLU_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> Specifies in pixels the width, height and depth respectively, of the texture image. These should be a power of 2. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Must be one of `GLU_COLOR_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, or `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Must be one of `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the image data. </para> </listitem>",
        "base": "<listitem> <para> Specifies the minimum mipmap level to pass to <citerefentry><refentrytitle>glTexImage3D</refentrytitle></citerefentry>. </para> </listitem>",
        "max": "<listitem> <para> Specifies the maximum mipmap level to pass to <citerefentry><refentrytitle>glTexImage3D</refentrytitle></citerefentry>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "gluBuild3DMipmaps": {
      "signature": "GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
      "purpose": "builds a three-dimensional mipmap",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GLU_TEXTURE_3D`. </para> </listitem>",
        "internalFormat": "<listitem> <para> Requests the internal storage format of the texture image. The most current version of the SGI implementation of GLU does not check this value for validity before passing it on to the underlying OpenGL implementation. A value that is not accepted by the OpenGL implementation will lead to an OpenGL error. The benefit of not checking this value at the GLU level is that OpenGL extensions can add new internal texture formats without requiring a revision of the GLU implementation. Older implementations of GLU check this value and raise a GLU error if it is not 1, 2, 3, or 4 or one of the following symbolic constants: `GLU_ALPHA`, `GLU_ALPHA4`, `GLU_ALPHA8`, `GLU_ALPHA12`, `GLU_ALPHA16`, `GLU_LUMINANCE`, `GLU_LUMINANCE4`, `GLU_LUMINANCE8`, `GLU_LUMINANCE12`, `GLU_LUMINANCE16`, `GLU_LUMINANCE_ALPHA`, `GLU_LUMINANCE4_ALPHA4`, `GLU_LUMINANCE6_ALPHA2`, `GLU_LUMINANCE8_ALPHA8`, `GLU_LUMINANCE12_ALPHA4`, `GLU_LUMINANCE12_ALPHA12`, `GLU_LUMINANCE16_ALPHA16`, `GLU_INTENSITY`, `GLU_INTENSITY4`, `GLU_INTENSITY8`, `GLU_INTENSITY12`, `GLU_INTENSITY16`, `GLU_RGB`, `GLU_R3_G3_B2`, `GLU_RGB4`, `GLU_RGB5`, `GLU_RGB8`, `GLU_RGB10`, `GLU_RGB12`, `GLU_RGB16`, `GLU_RGBA`, `GLU_RGBA2`, `GLU_RGBA4`, `GLU_RGB5_A1`, `GLU_RGBA8`, `GLU_RGB10_A2`, `GLU_RGBA12`, or `GLU_RGBA16`. </para> </listitem>",
        "width": "<listitem> <para> Specifies in pixels the width, height and depth respectively, in pixels of the texture image. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. Must be one of `GLU_COLOR_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, or `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type for <parameter>data</parameter>. Must be one of: `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "gluCheckExtension": {
      "signature": "GLboolean gluCheckExtension(const GLubyte * extName, const GLubyte * extString)",
      "purpose": "determines if an extension name is supported",
      "parameters": {
        "extName": "<listitem> <para> Specifies an extension name. </para> </listitem>",
        "extString": "<listitem> <para> Specifies a space-separated list of extension names supported. </para> </listitem>"
      }
    },
    "gluCylinder": {
      "signature": "void gluCylinder(GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)",
      "purpose": "draw a cylinder",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "base": "<listitem> <para> Specifies the radius of the cylinder at <emphasis>z</emphasis> = 0. </para> </listitem>",
        "top": "<listitem> <para> Specifies the radius of the cylinder at <emphasis>z</emphasis> = <parameter>height</parameter>. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the cylinder. </para> </listitem>",
        "slices": "<listitem> <para> Specifies the number of subdivisions around the <emphasis>z</emphasis> axis. </para> </listitem>",
        "stacks": "<listitem> <para> Specifies the number of subdivisions along the <emphasis>z</emphasis> axis. </para> </listitem>"
      }
    },
    "gluDeleteNurbsRenderer": {
      "signature": "void gluDeleteNurbsRenderer(GLUnurbs* nurb)",
      "purpose": "destroy a NURBS object",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object to be destroyed. </para> </listitem>"
      }
    },
    "gluDeleteQuadric": {
      "signature": "void gluDeleteQuadric(GLUquadric* quad)",
      "purpose": "destroy a quadrics object",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object to be destroyed. </para> </listitem>"
      }
    },
    "gluDeleteTess": {
      "signature": "void gluDeleteTess(GLUtesselator* tess)",
      "purpose": "destroy a tessellation object",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object to destroy. </para> </listitem>"
      }
    },
    "gluDisk": {
      "signature": "void gluDisk(GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)",
      "purpose": "draw a disk",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "inner": "<listitem> <para> Specifies the inner radius of the disk (may be 0). </para> </listitem>",
        "outer": "<listitem> <para> Specifies the outer radius of the disk. </para> </listitem>",
        "slices": "<listitem> <para> Specifies the number of subdivisions around the <emphasis>z</emphasis> axis. </para> </listitem>",
        "loops": "<listitem> <para> Specifies the number of concentric rings about the origin into which the disk is subdivided. </para> </listitem>"
      }
    },
    "gluErrorString": {
      "signature": "const GLubyte * gluErrorString(GLenum error)",
      "purpose": "produce an error string from a GL or GLU error code",
      "parameters": {
        "error": "<listitem> <para> Specifies a GL or GLU error code. </para> </listitem>"
      }
    },
    "gluGetNurbsProperty": {
      "signature": "void gluGetNurbsProperty(GLUnurbs* nurb, GLenum property, GLfloat* data)",
      "purpose": "get a NURBS property",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "property": "<listitem> <para> Specifies the property whose value is to be fetched. Valid values are `GLU_CULLING`, `GLU_SAMPLING_TOLERANCE`, `GLU_DISPLAY_MODE`, `GLU_AUTO_LOAD_MATRIX`, `GLU_PARAMETRIC_TOLERANCE`, `GLU_SAMPLING_METHOD`, `GLU_U_STEP`, `GLU_V_STEP`, and `GLU_NURBS_MODE`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the location into which the value of the named property is written. </para> </listitem>"
      }
    },
    "gluGetString": {
      "signature": "const GLubyte * gluGetString(GLenum name)",
      "purpose": "return a string describing the GLU version or GLU extensions ",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GLU_VERSION`, or `GLU_EXTENSIONS`. </para> </listitem>"
      }
    },
    "gluGetTessProperty": {
      "signature": "void gluGetTessProperty(GLUtesselator* tess, GLenum which, GLdouble* data)",
      "purpose": "get a tessellation object property",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "which": "<listitem> <para> Specifies the property whose value is to be fetched. Valid values are `GLU_TESS_WINDING_RULE`, `GLU_TESS_BOUNDARY_ONLY`, and `GLU_TESS_TOLERANCE`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the location into which the value of the named property is written. </para> </listitem>"
      }
    },
    "gluLoadSamplingMatrices": {
      "signature": "void gluLoadSamplingMatrices(GLUnurbs* nurb, const GLfloat * model, const GLfloat * perspective, const GLint * view)",
      "purpose": "load NURBS sampling and culling matrices",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "model": "<listitem> <para> Specifies a modelview matrix (as from a <citerefentry><refentrytitle>glGetFloatv</refentrytitle></citerefentry> call). </para> </listitem>",
        "perspective": "<listitem> <para> Specifies a projection matrix (as from a <citerefentry><refentrytitle>glGetFloatv</refentrytitle></citerefentry> call). </para> </listitem>",
        "view": "<listitem> <para> Specifies a viewport (as from a <citerefentry><refentrytitle>glGetIntegerv</refentrytitle></citerefentry> call). </para> </listitem>"
      }
    },
    "gluLookAt": {
      "signature": "void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)",
      "purpose": "define a viewing transformation",
      "parameters": {
        "eyeX": "<listitem> <para> Specifies the position of the eye point. </para> </listitem>",
        "centerX": "<listitem> <para> Specifies the position of the reference point. </para> </listitem>",
        "upX": "<listitem> <para> Specifies the direction of the <emphasis>up</emphasis> vector. </para> </listitem>"
      }
    },
    "gluNewNurbsRenderer": {
      "signature": "GLUnurbs* gluNewNurbsRenderer()",
      "purpose": "create a NURBS object",
      "parameters": {}
    },
    "gluNewQuadric": {
      "signature": "GLUquadric* gluNewQuadric()",
      "purpose": "create a quadrics object",
      "parameters": {}
    },
    "gluNewTess": {
      "signature": "GLUtesselator* gluNewTess()",
      "purpose": "create a tessellation object",
      "parameters": {}
    },
    "gluNextContour": {
      "signature": "void gluNextContour(GLUtesselator* tess, GLenum type)",
      "purpose": "mark the beginning of another contour",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the contour being defined. Valid values are `GLU_EXTERIOR`, `GLU_INTERIOR`, `GLU_UNKNOWN`, `GLU_CCW`, and `GLU_CW`. </para> </listitem>"
      }
    },
    "glUniform1f": {
      "signature": "void glUniform1f(GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2f": {
      "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3f": {
      "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4f": {
      "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform1i": {
      "signature": "void glUniform1i(GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2i": {
      "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3i": {
      "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4i": {
      "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform1fv": {
      "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2fv": {
      "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3fv": {
      "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4fv": {
      "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform1iv": {
      "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform2iv": {
      "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform3iv": {
      "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniform4iv": {
      "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix2fv": {
      "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix3fv": {
      "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix4fv": {
      "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix2x3fv": {
      "signature": "void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix3x2fv": {
      "signature": "void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix2x4fv": {
      "signature": "void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix4x2fv": {
      "signature": "void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix3x4fv": {
      "signature": "void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "glUniformMatrix4x3fv": {
      "signature": "void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified uniform variable.</para> </listitem>"
      }
    },
    "gluNurbsCallback": {
      "signature": "void gluNurbsCallback(GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc)",
      "purpose": "define a callback for a NURBS object",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "which": "<listitem> <para> Specifies the callback being defined. Valid values are `GLU_NURBS_BEGIN`, `GLU_NURBS_VERTEX`, `GLU_NURBS_NORMAL`, `GLU_NURBS_COLOR`, `GLU_NURBS_TEXTURE_COORD`, `GLU_NURBS_END`, `GLU_NURBS_BEGIN_DATA`, `GLU_NURBS_VERTEX_DATA`, `GLU_NURBS_NORMAL_DATA`, `GLU_NURBS_COLOR_DATA`, `GLU_NURBS_TEXTURE_COORD_DATA`, `GLU_NURBS_END_DATA`, and `GLU_NURBS_ERROR`. </para> </listitem>",
        "CallBackFunc": "<listitem> <para> Specifies the function that the callback calls. </para> </listitem>"
      }
    },
    "gluNurbsCallbackData": {
      "signature": "void gluNurbsCallbackData(GLUnurbs* nurb, void* userData)",
      "purpose": "set a user data pointer",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "userData": "<listitem> <para> Specifies a pointer to the user's data. </para> </listitem>"
      }
    },
    "gluNurbsCallbackDataEXT": {
      "signature": "void gluNurbsCallbackDataEXT(GLUnurbs* nurb, void* userData)",
      "purpose": "set a user data pointer",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "userData": "<listitem> <para> Specifies a pointer to the user's data. </para> </listitem>"
      }
    },
    "gluNurbsCurve": {
      "signature": "void gluNurbsCurve(GLUnurbs* nurb, GLint knotCount, GLfloat * knots, GLint stride, GLfloat * control, GLint order, GLenum type)",
      "purpose": "define the shape of a NURBS curve",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "knotCount": "<listitem> <para> Specifies the number of knots in <parameter>knots</parameter>. <parameter>knotCount</parameter> equals the number of control points plus the order. </para> </listitem>",
        "knots": "<listitem> <para> Specifies an array of <parameter>knotCount</parameter> nondecreasing knot values. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the offset (as a number of single-precision floating-point values) between successive curve control points. </para> </listitem>",
        "control": "<listitem> <para> Specifies a pointer to an array of control points. The coordinates must agree with <parameter>type</parameter>, specified below. </para> </listitem>",
        "order": "<listitem> <para> Specifies the order of the NURBS curve. <parameter>order</parameter> equals degree + 1, hence a cubic curve has an order of 4. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the curve. If this curve is defined within a <citerefentry><refentrytitle>gluBeginCurve</refentrytitle></citerefentry>/<citerefentry><refentrytitle>gluEndCurve</refentrytitle></citerefentry> pair, then the type can be any of the valid one-dimensional evaluator types (such as `GLU_MAP1_VERTEX_3` or `GLU_MAP1_COLOR_4`). Between a <citerefentry><refentrytitle>gluBeginTrim</refentrytitle></citerefentry>/<citerefentry><refentrytitle>gluEndTrim</refentrytitle></citerefentry> pair, the only valid types are `GLU_MAP1_TRIM_2` and `GLU_MAP1_TRIM_3`. </para> </listitem>"
      }
    },
    "gluNurbsProperty": {
      "signature": "void gluNurbsProperty(GLUnurbs* nurb, GLenum property, GLfloat value)",
      "purpose": "set a NURBS property",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "property": "<listitem> <para> Specifies the property to be set. Valid values are `GLU_SAMPLING_TOLERANCE`, `GLU_DISPLAY_MODE`, `GLU_CULLING`, `GLU_AUTO_LOAD_MATRIX`, `GLU_PARAMETRIC_TOLERANCE`, `GLU_SAMPLING_METHOD`, `GLU_U_STEP`, `GLU_V_STEP`, or `GLU_NURBS_MODE`. </para> </listitem>",
        "value": "<listitem> <para> Specifies the value of the indicated property. It may be a numeric value or one of `GLU_OUTLINE_POLYGON`, `GLU_FILL`, `GLU_OUTLINE_PATCH`, `GLU_TRUE`, `GLU_FALSE`, `GLU_PATH_LENGTH`, `GLU_PARAMETRIC_ERROR`, `GLU_DOMAIN_DISTANCE`, `GLU_NURBS_RENDERER`, or `GLU_NURBS_TESSELLATOR`. </para> </listitem>"
      }
    },
    "gluNurbsSurface": {
      "signature": "void gluNurbsSurface(GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type)",
      "purpose": "define the shape of a NURBS surface",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "sKnotCount": "<listitem> <para> Specifies the number of knots in the parametric <emphasis>u</emphasis> direction. </para> </listitem>",
        "sKnots": "<listitem> <para> Specifies an array of <parameter>sKnotCount</parameter> nondecreasing knot values in the parametric <emphasis>u</emphasis> direction. </para> </listitem>",
        "tKnotCount": "<listitem> <para> Specifies the number of knots in the parametric <emphasis>v</emphasis> direction. </para> </listitem>",
        "tKnots": "<listitem> <para> Specifies an array of <parameter>tKnotCount</parameter> nondecreasing knot values in the parametric <emphasis>v</emphasis> direction. </para> </listitem>",
        "sStride": "<listitem> <para> Specifies the offset (as a number of single-precision floating-point values) between successive control points in the parametric <emphasis>u</emphasis> direction in <parameter>control</parameter>. </para> </listitem>",
        "tStride": "<listitem> <para> Specifies the offset (in single-precision floating-point values) between successive control points in the parametric <emphasis>v</emphasis> direction in <parameter>control</parameter>. </para> </listitem>",
        "control": "<listitem> <para> Specifies an array containing control points for the NURBS surface. The offsets between successive control points in the parametric <emphasis>u</emphasis> and <emphasis>v</emphasis> directions are given by <parameter>sStride</parameter> and <parameter>tStride</parameter>. </para> </listitem>",
        "sOrder": "<listitem> <para> Specifies the order of the NURBS surface in the parametric <emphasis>u</emphasis> direction. The order is one more than the degree, hence a surface that is cubic in <emphasis>u</emphasis> has a <emphasis>u</emphasis> order of 4. </para> </listitem>",
        "tOrder": "<listitem> <para> Specifies the order of the NURBS surface in the parametric <emphasis>v</emphasis> direction. The order is one more than the degree, hence a surface that is cubic in <emphasis>v</emphasis> has a <emphasis>v</emphasis> order of 4. </para> </listitem>",
        "type": "<listitem> <para> Specifies type of the surface. <parameter>type</parameter> can be any of the valid two-dimensional evaluator types (such as `GLU_MAP2_VERTEX_3` or `GLU_MAP2_COLOR_4`). </para> </listitem>"
      }
    },
    "gluOrtho2D": {
      "signature": "void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)",
      "purpose": "define a 2D orthographic projection matrix",
      "parameters": {
        "left": "<listitem> <para> Specify the coordinates for the left and right vertical clipping planes. </para> </listitem>",
        "bottom": "<listitem> <para> Specify the coordinates for the bottom and top horizontal clipping planes. </para> </listitem>"
      }
    },
    "gluPartialDisk": {
      "signature": "void gluPartialDisk(GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)",
      "purpose": "draw an arc of a disk",
      "parameters": {
        "quad": "<listitem> <para> Specifies a quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "inner": "<listitem> <para> Specifies the inner radius of the partial disk (can be 0). </para> </listitem>",
        "outer": "<listitem> <para> Specifies the outer radius of the partial disk. </para> </listitem>",
        "slices": "<listitem> <para> Specifies the number of subdivisions around the <emphasis>z</emphasis> axis. </para> </listitem>",
        "loops": "<listitem> <para> Specifies the number of concentric rings about the origin into which the partial disk is subdivided. </para> </listitem>",
        "start": "<listitem> <para> Specifies the starting angle, in degrees, of the disk portion. </para> </listitem>",
        "sweep": "<listitem> <para> Specifies the sweep angle, in degrees, of the disk portion. </para> </listitem>"
      }
    },
    "gluPerspective": {
      "signature": "void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)",
      "purpose": "set up a perspective projection matrix",
      "parameters": {
        "fovy": "<listitem> <para> Specifies the field of view angle, in degrees, in the <emphasis>y</emphasis> direction. </para> </listitem>",
        "aspect": "<listitem> <para> Specifies the aspect ratio that determines the field of view in the <emphasis>x</emphasis> direction. The aspect ratio is the ratio of <emphasis>x</emphasis> (width) to <emphasis>y</emphasis> (height). </para> </listitem>",
        "zNear": "<listitem> <para> Specifies the distance from the viewer to the near clipping plane (always positive). </para> </listitem>",
        "zFar": "<listitem> <para> Specifies the distance from the viewer to the far clipping plane (always positive). </para> </listitem>"
      }
    },
    "gluPickMatrix": {
      "signature": "void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint * viewport)",
      "purpose": "define a picking region",
      "parameters": {
        "x": "<listitem> <para> Specify the center of a picking region in window coordinates. </para> </listitem>",
        "delX": "<listitem> <para> Specify the width and height, respectively, of the picking region in window coordinates. </para> </listitem>",
        "viewport": "<listitem> <para> Specifies the current viewport (as from a <citerefentry><refentrytitle>glGetIntegerv</refentrytitle></citerefentry> call). </para> </listitem>"
      }
    },
    "gluProject": {
      "signature": "GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble* winX, GLdouble* winY, GLdouble* winZ)",
      "purpose": "map object coordinates to window coordinates",
      "parameters": {
        "objX": "<listitem> <para> Specify the object coordinates. </para> </listitem>",
        "model": "<listitem> <para> Specifies the current modelview matrix (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "proj": "<listitem> <para> Specifies the current projection matrix (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "view": "<listitem> <para> Specifies the current viewport (as from a <citerefentry><refentrytitle>glGetIntegerv</refentrytitle></citerefentry> call). </para> </listitem>",
        "winX": "<listitem> <para> Return the computed window coordinates. </para> </listitem>"
      }
    },
    "gluPwlCurve": {
      "signature": "void gluPwlCurve(GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type)",
      "purpose": "describe a piecewise linear NURBS trimming curve",
      "parameters": {
        "nurb": "<listitem> <para> Specifies the NURBS object (created with <citerefentry><refentrytitle>gluNewNurbsRenderer</refentrytitle></citerefentry>). </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of points on the curve. </para> </listitem>",
        "data": "<listitem> <para> Specifies an array containing the curve points. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the offset (a number of single-precision floating-point values) between points on the curve. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of curve. Must be either `GLU_MAP1_TRIM_2` or `GLU_MAP1_TRIM_3`. </para> </listitem>"
      }
    },
    "gluQuadricCallback": {
      "signature": "void gluQuadricCallback(GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc)",
      "purpose": "define a callback for a quadrics object",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "which": "<listitem> <para> Specifies the callback being defined. The only valid value is `GLU_ERROR`. </para> </listitem>",
        "CallBackFunc": "<listitem> <para> Specifies the function to be called. </para> </listitem>"
      }
    },
    "gluQuadricDrawStyle": {
      "signature": "void gluQuadricDrawStyle(GLUquadric* quad, GLenum draw)",
      "purpose": "specify the draw style desired for quadrics",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "draw": "<listitem> <para> Specifies the desired draw style. Valid values are `GLU_FILL`, `GLU_LINE`, `GLU_SILHOUETTE`, and `GLU_POINT`. </para> </listitem>"
      }
    },
    "gluQuadricNormals": {
      "signature": "void gluQuadricNormals(GLUquadric* quad, GLenum normal)",
      "purpose": "specify what kind of normals are desired for quadrics",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "normal": "<listitem> <para> Specifies the desired type of normals. Valid values are `GLU_NONE`, `GLU_FLAT`, and `GLU_SMOOTH`. </para> </listitem>"
      }
    },
    "gluQuadricOrientation": {
      "signature": "void gluQuadricOrientation(GLUquadric* quad, GLenum orientation)",
      "purpose": "specify inside/outside orientation for quadrics",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "orientation": "<listitem> <para> Specifies the desired orientation. Valid values are `GLU_OUTSIDE` and `GLU_INSIDE`. </para> </listitem>"
      }
    },
    "gluQuadricTexture": {
      "signature": "void gluQuadricTexture(GLUquadric* quad, GLboolean texture)",
      "purpose": "specify if texturing is desired for quadrics",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "texture": "<listitem> <para> Specifies a flag indicating if texture coordinates should be generated. </para> </listitem>"
      }
    },
    "gluScaleImage": {
      "signature": "GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void * dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, void* dataOut)",
      "purpose": "scale an image to an arbitrary size",
      "parameters": {
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are valid: `GLU_COLOR_INDEX`, `GLU_STENCIL_INDEX`, `GLU_DEPTH_COMPONENT`, `GLU_RED`, `GLU_GREEN`, `GLU_BLUE`, `GLU_ALPHA`, `GLU_RGB`, `GLU_RGBA`, `GLU_BGR`, `GLU_BGRA`, `GLU_LUMINANCE`, and `GLU_LUMINANCE_ALPHA`. </para> </listitem>",
        "wIn": "<listitem> <para> Specify in pixels the width and height, respectively, of the source image. </para> </listitem>",
        "typeIn": "<listitem> <para> Specifies the data type for <parameter>dataIn</parameter>. Must be one of `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "dataIn": "<listitem> <para> Specifies a pointer to the source image. </para> </listitem>",
        "wOut": "<listitem> <para> Specify the width and height, respectively, in pixels of the destination image. </para> </listitem>",
        "typeOut": "<listitem> <para> Specifies the data type for <parameter>dataOut</parameter>. Must be one of `GLU_UNSIGNED_BYTE`, `GLU_BYTE`, `GLU_BITMAP`, `GLU_UNSIGNED_SHORT`, `GLU_SHORT`, `GLU_UNSIGNED_INT`, `GLU_INT`, `GLU_FLOAT`, `GLU_UNSIGNED_BYTE_3_3_2`, `GLU_UNSIGNED_BYTE_2_3_3_REV`, `GLU_UNSIGNED_SHORT_5_6_5`, `GLU_UNSIGNED_SHORT_5_6_5_REV`, `GLU_UNSIGNED_SHORT_4_4_4_4`, `GLU_UNSIGNED_SHORT_4_4_4_4_REV`, `GLU_UNSIGNED_SHORT_5_5_5_1`, `GLU_UNSIGNED_SHORT_1_5_5_5_REV`, `GLU_UNSIGNED_INT_8_8_8_8`, `GLU_UNSIGNED_INT_8_8_8_8_REV`, `GLU_UNSIGNED_INT_10_10_10_2`, or `GLU_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "dataOut": "<listitem> <para> Specifies a pointer to the destination image. </para> </listitem>"
      }
    },
    "glUseProgram": {
      "signature": "void glUseProgram(GLuint program)",
      "purpose": "Installs a program object as part of current rendering state",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
      }
    },
    "gluSphere": {
      "signature": "void gluSphere(GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks)",
      "purpose": "draw a sphere",
      "parameters": {
        "quad": "<listitem> <para> Specifies the quadrics object (created with <citerefentry><refentrytitle>gluNewQuadric</refentrytitle></citerefentry>). </para> </listitem>",
        "radius": "<listitem> <para> Specifies the radius of the sphere. </para> </listitem>",
        "slices": "<listitem> <para> Specifies the number of subdivisions around the <emphasis>z</emphasis> axis (similar to lines of longitude). </para> </listitem>",
        "stacks": "<listitem> <para> Specifies the number of subdivisions along the <emphasis>z</emphasis> axis (similar to lines of latitude). </para> </listitem>"
      }
    },
    "gluTessBeginContour": {
      "signature": "void gluTessBeginContour(GLUtesselator* tess)",
      "purpose": "delimit a contour description",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluTessEndContour": {
      "signature": "void gluTessEndContour(GLUtesselator* tess)",
      "purpose": "delimit a contour description",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluTessBeginPolygon": {
      "signature": "void gluTessBeginPolygon(GLUtesselator* tess, void* data)",
      "purpose": "delimit a polygon description",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to user polygon data. </para> </listitem>"
      }
    },
    "gluTessCallback": {
      "signature": "void gluTessCallback(GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc)",
      "purpose": "define a callback for a tessellation object",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "which": "<listitem> <para> Specifies the callback being defined. The following values are valid: `GLU_TESS_BEGIN`, `GLU_TESS_BEGIN_DATA`, `GLU_TESS_EDGE_FLAG`, `GLU_TESS_EDGE_FLAG_DATA`, `GLU_TESS_VERTEX`, `GLU_TESS_VERTEX_DATA`, `GLU_TESS_END`, `GLU_TESS_END_DATA`, `GLU_TESS_COMBINE`, `GLU_TESS_COMBINE_DATA`, `GLU_TESS_ERROR`, and `GLU_TESS_ERROR_DATA`. </para> </listitem>",
        "CallBackFunc": "<listitem> <para> Specifies the function to be called. </para> </listitem>"
      }
    },
    "gluTessEndPolygon": {
      "signature": "void gluTessEndPolygon(GLUtesselator* tess)",
      "purpose": "delimit a polygon description",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluTessNormal": {
      "signature": "void gluTessNormal(GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)",
      "purpose": "specify a normal for a polygon",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "valueX": "<listitem> <para> Specifies the first component of the normal. </para> </listitem>",
        "valueY": "<listitem> <para> Specifies the second component of the normal. </para> </listitem>",
        "valueZ": "<listitem> <para> Specifies the third component of the normal. </para> </listitem>"
      }
    },
    "gluTessProperty": {
      "signature": "void gluTessProperty(GLUtesselator* tess, GLenum which, GLdouble data)",
      "purpose": "set a tessellation object property",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "which": "<listitem> <para> Specifies the property to be set. Valid values are `GLU_TESS_WINDING_RULE`, `GLU_TESS_BOUNDARY_ONLY`, and `GLU_TESS_TOLERANCE`. </para> </listitem>",
        "data": "<listitem> <para> Specifies the value of the indicated property. </para> </listitem>"
      }
    },
    "gluTessVertex": {
      "signature": "void gluTessVertex(GLUtesselator* tess, GLdouble * location, void* data)",
      "purpose": "specify a vertex on a polygon",
      "parameters": {
        "tess": "<listitem> <para> Specifies the tessellation object (created with <citerefentry><refentrytitle>gluNewTess</refentrytitle></citerefentry>). </para> </listitem>",
        "location": "<listitem> <para> Specifies the location of the vertex. </para> </listitem>",
        "data": "<listitem> <para> Specifies an opaque pointer passed back to the program with the vertex callback (as specified by <citerefentry><refentrytitle>gluTessCallback</refentrytitle></citerefentry>). </para> </listitem>"
      }
    },
    "gluUnProject": {
      "signature": "GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble* objX, GLdouble* objY, GLdouble* objZ)",
      "purpose": "map window coordinates to object coordinates",
      "parameters": {
        "winX": "<listitem> <para> Specify the window coordinates to be mapped. </para> </listitem>",
        "model": "<listitem> <para> Specifies the modelview matrix (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "proj": "<listitem> <para> Specifies the projection matrix (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "view": "<listitem> <para> Specifies the viewport (as from a <citerefentry><refentrytitle>glGetIntegerv</refentrytitle></citerefentry> call). </para> </listitem>",
        "objX": "<listitem> <para> Returns the computed object coordinates. </para> </listitem>"
      }
    },
    "gluUnProject4": {
      "signature": "GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW)",
      "purpose": "map window and clip coordinates to object coordinates",
      "parameters": {
        "winX": "<listitem> <para> Specify the window coordinates to be mapped. </para> </listitem>",
        "clipW": "<listitem> <para> Specify the clip w coordinate to be mapped. </para> </listitem>",
        "model": "<listitem> <para> Specifies the modelview matrix (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "proj": "<listitem> <para> Specifies the projection matrix (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "view": "<listitem> <para> Specifies the viewport (as from a <citerefentry><refentrytitle>glGetIntegerv</refentrytitle></citerefentry> call). </para> </listitem>",
        "nearVal": "<listitem> <para> Specifies the near and far planes (as from a <citerefentry><refentrytitle>glGetDoublev</refentrytitle></citerefentry> call). </para> </listitem>",
        "objX": "<listitem> <para> Returns the computed object coordinates. </para> </listitem>"
      }
    },
    "glValidateProgram": {
      "signature": "void glValidateProgram(GLuint program)",
      "purpose": "Validates a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
      }
    },
    "glVertex2s": {
      "signature": "void glVertex2s(GLshort x, GLshort y)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2i": {
      "signature": "void glVertex2i(GLint x, GLint y)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2f": {
      "signature": "void glVertex2f(GLfloat x, GLfloat y)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2d": {
      "signature": "void glVertex2d(GLdouble x, GLdouble y)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3s": {
      "signature": "void glVertex3s(GLshort x, GLshort y, GLshort z)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3i": {
      "signature": "void glVertex3i(GLint x, GLint y, GLint z)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3f": {
      "signature": "void glVertex3f(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3d": {
      "signature": "void glVertex3d(GLdouble x, GLdouble y, GLdouble z)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4s": {
      "signature": "void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4i": {
      "signature": "void glVertex4i(GLint x, GLint y, GLint z, GLint w)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4f": {
      "signature": "void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4d": {
      "signature": "void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2sv": {
      "signature": "void glVertex2sv(const GLshort * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2iv": {
      "signature": "void glVertex2iv(const GLint * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2fv": {
      "signature": "void glVertex2fv(const GLfloat * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex2dv": {
      "signature": "void glVertex2dv(const GLdouble * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3sv": {
      "signature": "void glVertex3sv(const GLshort * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3iv": {
      "signature": "void glVertex3iv(const GLint * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3fv": {
      "signature": "void glVertex3fv(const GLfloat * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex3dv": {
      "signature": "void glVertex3dv(const GLdouble * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4sv": {
      "signature": "void glVertex4sv(const GLshort * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4iv": {
      "signature": "void glVertex4iv(const GLint * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4fv": {
      "signature": "void glVertex4fv(const GLfloat * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertex4dv": {
      "signature": "void glVertex4dv(const GLdouble * v)",
      "purpose": "specify a vertex",
      "parameters": {
        "x": "<listitem> <para> Specify <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>z</emphasis>, and <emphasis>w</emphasis> coordinates of a vertex. Not all parameters are present in all forms of the command. </para> </listitem>"
      }
    },
    "glVertexAttrib1f": {
      "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib1s": {
      "signature": "void glVertexAttrib1s(GLuint index, GLshort v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib1d": {
      "signature": "void glVertexAttrib1d(GLuint index, GLdouble v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2f": {
      "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2s": {
      "signature": "void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2d": {
      "signature": "void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3f": {
      "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3s": {
      "signature": "void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3d": {
      "signature": "void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4f": {
      "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4s": {
      "signature": "void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4d": {
      "signature": "void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Nub": {
      "signature": "void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib1fv": {
      "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib1sv": {
      "signature": "void glVertexAttrib1sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib1dv": {
      "signature": "void glVertexAttrib1dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2fv": {
      "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2sv": {
      "signature": "void glVertexAttrib2sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib2dv": {
      "signature": "void glVertexAttrib2dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3fv": {
      "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3sv": {
      "signature": "void glVertexAttrib3sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib3dv": {
      "signature": "void glVertexAttrib3dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4fv": {
      "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4sv": {
      "signature": "void glVertexAttrib4sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4dv": {
      "signature": "void glVertexAttrib4dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4iv": {
      "signature": "void glVertexAttrib4iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4bv": {
      "signature": "void glVertexAttrib4bv(GLuint index, const GLbyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4ubv": {
      "signature": "void glVertexAttrib4ubv(GLuint index, const GLubyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4usv": {
      "signature": "void glVertexAttrib4usv(GLuint index, const GLushort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4uiv": {
      "signature": "void glVertexAttrib4uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Nbv": {
      "signature": "void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Nsv": {
      "signature": "void glVertexAttrib4Nsv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Niv": {
      "signature": "void glVertexAttrib4Niv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Nubv": {
      "signature": "void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Nusv": {
      "signature": "void glVertexAttrib4Nusv(GLuint index, const GLushort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttrib4Nuiv": {
      "signature": "void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para>Specifies the new values to be used for the specified vertex attribute.</para> </listitem>"
      }
    },
    "glVertexAttribPointer": {
      "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. Symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_FLOAT`, or `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.</para> </listitem>"
      }
    },
    "glVertexPointer": {
      "signature": "void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of vertex data",
      "parameters": {
        "size": "<listitem> <para> Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of each coordinate in the array. Symbolic constants `GL_SHORT`, `GL_INT`, `GL_FLOAT`, or `GL_DOUBLE` are accepted. The initial value is `GL_FLOAT`. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the byte offset between consecutive vertices. If <parameter>stride</parameter> is 0, the vertices are understood to be tightly packed in the array. The initial value is 0. </para> </listitem>",
        "pointer": "<listitem> <para> Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0. </para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glWindowPos2s": {
      "signature": "void glWindowPos2s(GLshort x, GLshort y)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2i": {
      "signature": "void glWindowPos2i(GLint x, GLint y)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2f": {
      "signature": "void glWindowPos2f(GLfloat x, GLfloat y)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2d": {
      "signature": "void glWindowPos2d(GLdouble x, GLdouble y)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3s": {
      "signature": "void glWindowPos3s(GLshort x, GLshort y, GLshort z)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3i": {
      "signature": "void glWindowPos3i(GLint x, GLint y, GLint z)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3f": {
      "signature": "void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3d": {
      "signature": "void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2sv": {
      "signature": "void glWindowPos2sv(const GLshort * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2iv": {
      "signature": "void glWindowPos2iv(const GLint * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2fv": {
      "signature": "void glWindowPos2fv(const GLfloat * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos2dv": {
      "signature": "void glWindowPos2dv(const GLdouble * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3sv": {
      "signature": "void glWindowPos3sv(const GLshort * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3iv": {
      "signature": "void glWindowPos3iv(const GLint * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3fv": {
      "signature": "void glWindowPos3fv(const GLfloat * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glWindowPos3dv": {
      "signature": "void glWindowPos3dv(const GLdouble * v)",
      "purpose": "specify the raster position in window coordinates for pixel operations",
      "parameters": {
        "x": "<listitem> <para> Specify the <inlineequation><math><mi mathvariant=\"italic\">x</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">y</mi></math></inlineequation>, <inlineequation><math><mi mathvariant=\"italic\">z</mi></math></inlineequation> coordinates for the raster position. </para> </listitem>"
      }
    },
    "glXChooseFBConfig": {
      "signature": "GLXFBConfig * glXChooseFBConfig(Display * dpy, int screen, const int * attrib_list, int * nelements)",
      "purpose": "return a list of GLX frame buffer configurations that match the specified attributes",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "screen": "<listitem> <para> Specifies the screen number. </para> </listitem>",
        "attrib_list": "<listitem> <para> Specifies a list of attribute/value pairs. The last attribute must be `None`. </para> </listitem>",
        "nelements": "<listitem> <para> Returns the number of elements in the list returned by <function>glXChooseFBConfig</function>. </para> </listitem>"
      }
    },
    "glXChooseVisual": {
      "signature": "XVisualInfo* glXChooseVisual(Display * dpy, int screen, int * attribList)",
      "purpose": "return a visual that matches specified attributes",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "screen": "<listitem> <para> Specifies the screen number. </para> </listitem>",
        "attribList": "<listitem> <para> Specifies a list of boolean attributes and integer attribute/value pairs. The last attribute must be `None`. </para> </listitem>"
      }
    },
    "glXCopyContext": {
      "signature": "void glXCopyContext(Display * dpy, GLXContext src, GLXContext dst, unsigned long mask)",
      "purpose": "copy state from one rendering context to another",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "src": "<listitem> <para> Specifies the source context. </para> </listitem>",
        "dst": "<listitem> <para> Specifies the destination context. </para> </listitem>",
        "mask": "<listitem> <para> Specifies which portions of <parameter>src</parameter> state are to be copied to <parameter>dst</parameter>. </para> </listitem>"
      }
    },
    "glXCreateContext": {
      "signature": "GLXContext glXCreateContext(Display * dpy, XVisualInfo * vis, GLXContext shareList, Bool direct)",
      "purpose": "create a new GLX rendering context",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "vis": "<listitem> <para> Specifies the visual that defines the frame buffer resources available to the rendering context. It is a pointer to an `XVisualInfo` structure, not a visual ID or a pointer to a `Visual`. </para> </listitem>",
        "shareList": "<listitem> <para> Specifies the context with which to share display lists. `NULL` indicates that no sharing is to take place. </para> </listitem>",
        "direct": "<listitem> <para> Specifies whether rendering is to be done with a direct connection to the graphics system if possible (`True`) or through the X server (`False`). </para> </listitem>"
      }
    },
    "glXCreateGLXPixmap": {
      "signature": "GLXPixmap glXCreateGLXPixmap(Display * dpy, XVisualInfo * vis, Pixmap pixmap)",
      "purpose": "create an off-screen GLX rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "vis": "<listitem> <para> Specifies the visual that defines the structure of the rendering area. It is a pointer to an `XVisualInfo` structure, not a visual ID or a pointer to a `Visual`. </para> </listitem>",
        "pixmap": "<listitem> <para> Specifies the X pixmap that will be used as the front left color buffer of the off-screen rendering area. </para> </listitem>"
      }
    },
    "glXCreateNewContext": {
      "signature": "GLXContext glXCreateNewContext(Display * dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)",
      "purpose": "create a new GLX rendering context",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "config": "<listitem> <para> Specifies the GLXFBConfig structure with the desired attributes for the context. </para> </listitem>",
        "render_type": "<listitem> <para> Specifies the type of the context to be created. Must be one of `GLX_RGBA_TYPE` or `GLX_COLOR_INDEX_TYPE`. </para> </listitem>",
        "share_list": "<listitem> <para> Specifies whether rendering is to be done with a direct connection to the graphics system if possible (`True`) or through the X server (`False`). </para> </listitem>"
      }
    },
    "glXCreatePbuffer": {
      "signature": "GLXPbuffer glXCreatePbuffer(Display * dpy, GLXFBConfig config, const int * attrib_list)",
      "purpose": "create an off-screen rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "config": "<listitem> <para> Specifies a GLXFBConfig structure with the desired attributes for the window. </para> </listitem>",
        "attrib_list": "<listitem> <para> Specifies a list of attribute value pairs, which must be terminated with `None` or `NULL`. Accepted attributes are `GLX_PBUFFER_WIDTH`, `GLX_PBUFFER_HEIGHT`, `GLX_PRESERVED_CONTENTS`, and `GLX_LARGEST_PBUFFER`. </para> </listitem>"
      }
    },
    "glXCreatePixmap": {
      "signature": "GLXPixmap glXCreatePixmap(Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attrib_list)",
      "purpose": "create an off-screen rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "config": "<listitem> <para> Specifies a GLXFBConfig structure with the desired attributes for the window. </para> </listitem>",
        "pixmap": "<listitem> <para> Specifies the X pixmap to be used as the rendering area. </para> </listitem>",
        "attrib_list": "<listitem> <para> Currently unused. This must be set to `NULL` or be an empty list (i.e., one in which the first element is `None`). </para> </listitem>"
      }
    },
    "glXCreateWindow": {
      "signature": "GLXWindow glXCreateWindow(Display * dpy, GLXFBConfig config, Window win, const int * attrib_list)",
      "purpose": "create an on-screen rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "config": "<listitem> <para> Specifies a GLXFBConfig structure with the desired attributes for the window. </para> </listitem>",
        "win": "<listitem> <para> Specifies the X window to be used as the rendering area. </para> </listitem>",
        "attrib_list": "<listitem> <para> Currently unused. This must be set to `NULL` or be an empty list (i.e., one in which the first element is `None`). </para> </listitem>"
      }
    },
    "glXDestroyContext": {
      "signature": "void glXDestroyContext(Display * dpy, GLXContext ctx)",
      "purpose": "destroy a GLX context",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies the GLX context to be destroyed. </para> </listitem>"
      }
    },
    "glXDestroyGLXPixmap": {
      "signature": "void glXDestroyGLXPixmap(Display * dpy, GLXPixmap pix)",
      "purpose": "destroy a GLX pixmap",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "pix": "<listitem> <para> Specifies the GLX pixmap to be destroyed. </para> </listitem>"
      }
    },
    "glXDestroyPbuffer": {
      "signature": "void glXDestroyPbuffer(Display * dpy, GLXPbuffer pbuf)",
      "purpose": "destroy an off-screen rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "pbuf": "<listitem> <para> Specifies the GLXPbuffer to be destroyed. </para> </listitem>"
      }
    },
    "glXDestroyPixmap": {
      "signature": "void glXDestroyPixmap(Display * dpy, GLXPixmap pixmap)",
      "purpose": "destroy an off-screen rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "pixmap": "<listitem> <para> Specifies the GLXPixmap to be destroyed. </para> </listitem>"
      }
    },
    "glXDestroyWindow": {
      "signature": "void glXDestroyWindow(Display * dpy, GLXWindow win)",
      "purpose": "destroy an on-screen rendering area",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "win": "<listitem> <para> Specifies the GLXWindow to be destroyed. </para> </listitem>"
      }
    },
    "glXFreeContextEXT": {
      "signature": "void glXFreeContextEXT(Display * dpy, GLXContext ctx)",
      "purpose": "free client-side memory for imported context",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies a GLX rendering context. </para> </listitem>"
      }
    },
    "glXGetClientString": {
      "signature": "const char * glXGetClientString(Display * dpy, int name)",
      "purpose": "return a string describing the client",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "name": "<listitem> <para> Specifies which string is returned. The symbolic constants `GLX_VENDOR`, `GLX_VERSION`, and `GLX_EXTENSIONS` are accepted. </para> </listitem>"
      }
    },
    "glXGetConfig": {
      "signature": "int glXGetConfig(Display * dpy, XVisualInfo * vis, int attrib, int * value)",
      "purpose": "return information about GLX visuals",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "vis": "<listitem> <para> Specifies the visual to be queried. It is a pointer to an `XVisualInfo` structure, not a visual ID or a pointer to a `Visual`. </para> </listitem>",
        "attrib": "<listitem> <para> Specifies the visual attribute to be returned. </para> </listitem>",
        "value": "<listitem> <para> Returns the requested value. </para> </listitem>"
      }
    },
    "glXGetContextIDEXT": {
      "signature": "GLXContextID glXGetContextIDEXT(const GLXContext ctx)",
      "purpose": "get the XID for a context.",
      "parameters": {
        "ctx": "<listitem> <para> Specifies a GLX rendering context. </para> </listitem>"
      }
    },
    "glXGetCurrentContext": {
      "signature": "GLXContext glXGetCurrentContext()",
      "purpose": "return the current context",
      "parameters": {}
    },
    "glXGetCurrentDisplay": {
      "signature": "Display * glXGetCurrentDisplay()",
      "purpose": "get display for current context",
      "parameters": {}
    },
    "glXGetCurrentDrawable": {
      "signature": "GLXDrawable glXGetCurrentDrawable()",
      "purpose": "return the current drawable",
      "parameters": {}
    },
    "glXGetCurrentReadDrawable": {
      "signature": "GLXDrawable glXGetCurrentReadDrawable()",
      "purpose": "return the current drawable",
      "parameters": {}
    },
    "glXGetFBConfigAttrib": {
      "signature": "int glXGetFBConfigAttrib(Display * dpy, GLXFBConfig config, int attribute, int * value)",
      "purpose": "return information about a GLX frame buffer configuration",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "config": "<listitem> <para> Specifies the GLX frame buffer configuration to be queried. </para> </listitem>",
        "attribute": "<listitem> <para> Specifies the attribute to be returned. </para> </listitem>",
        "value": "<listitem> <para> Returns the requested value. </para> </listitem>"
      }
    },
    "glXGetFBConfigs": {
      "signature": "GLXFBConfig * glXGetFBConfigs(Display * dpy, int screen, int * nelements)",
      "purpose": "list all GLX frame buffer configurations for a given screen",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "screen": "<listitem> <para> Specifies the screen number. </para> </listitem>",
        "nelements": "<listitem> <para> Returns the number of GLXFBConfigs returned. </para> </listitem>"
      }
    },
    "glXGetProcAddress": {
      "signature": "void(*)() glXGetProcAddress(const GLubyte * procName)",
      "purpose": "obtain a pointer to an OpenGL or GLX function",
      "parameters": {
        "procName": "<listitem> <para> Specifies the name of the OpenGL or GLX function whose address is to be returned. </para> </listitem>"
      }
    },
    "glXGetSelectedEvent": {
      "signature": "void glXGetSelectedEvent(Display * dpy, GLXDrawable draw, unsigned long * event_mask)",
      "purpose": "returns GLX events that are selected for a window or a GLX pixel buffer",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "draw": "<listitem> <para> Specifies a GLX drawable. Must be a GLX pixel buffer or a window. </para> </listitem>",
        "event_mask": "<listitem> <para> Returns the events that are selected for <parameter>draw</parameter>. </para> </listitem>"
      }
    },
    "glXGetVisualFromFBConfig": {
      "signature": "XVisualInfo * glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig config)",
      "purpose": "return visual that is associated with the frame buffer configuration",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "config": "<listitem> <para> Specifies the GLX frame buffer configuration. </para> </listitem>"
      }
    },
    "glXImportContextEXT": {
      "signature": "GLXContext glXImportContextEXT(Display * dpy, GLXContextID contextID)",
      "purpose": "import another process's indirect rendering context.",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "contextID": "<listitem> <para> Specifies a GLX rendering context. </para> </listitem>"
      }
    },
    "glXIsDirect": {
      "signature": "Bool glXIsDirect(Display * dpy, GLXContext ctx)",
      "purpose": "indicate whether direct rendering is enabled",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies the GLX context that is being queried. </para> </listitem>"
      }
    },
    "glXMakeContextCurrent": {
      "signature": "Bool glXMakeContextCurrent(Display * display, GLXDrawable draw, GLXDrawable read, GLXContext ctx)",
      "purpose": "attach a GLX context to a GLX drawable",
      "parameters": {
        "display": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "draw": "<listitem> <para> Specifies a GLX drawable to render into. Must be an XID representing a GLXWindow, GLXPixmap, or GLXPbuffer. </para> </listitem>",
        "read": "<listitem> <para> Specifies a GLX drawable to read from. Must be an XID representing a GLXWindow, GLXPixmap, or GLXPbuffer. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies the GLX context to be bound to <parameter>read</parameter> and <parameter>ctx</parameter>. </para> </listitem>"
      }
    },
    "glXMakeCurrent": {
      "signature": "Bool glXMakeCurrent(Display * dpy, GLXDrawable drawable, GLXContext ctx)",
      "purpose": "attach a GLX context to a window or a GLX pixmap",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "drawable": "<listitem> <para> Specifies a GLX drawable. Must be either an X window ID or a GLX pixmap ID. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies a GLX rendering context that is to be attached to <parameter>drawable</parameter>. </para> </listitem>"
      }
    },
    "glXQueryContext": {
      "signature": "int glXQueryContext(Display * dpy, GLXContext ctx, int attribute, int * value)",
      "purpose": "query context information",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies a GLX rendering context. </para> </listitem>",
        "attribute": "<listitem> <para> Specifies that a context parameter should be retrieved. Must be one of `GLX_FBCONFIG_ID`, `GLX_RENDER_TYPE`, or `GLX_SCREEN`. </para> </listitem>",
        "value": "<listitem> <para> Contains the return value for <parameter>attribute</parameter>. </para> </listitem>"
      }
    },
    "glXQueryContextInfoEXT": {
      "signature": "int glXQueryContextInfoEXT(Display * dpy, GLXContext ctx, int attribute, int * value)",
      "purpose": "query context information",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "ctx": "<listitem> <para> Specifies a GLX rendering context. </para> </listitem>",
        "attribute": "<listitem> <para> Specifies that a context parameter should be retrieved. Must be one of `GLX_SHARED_CONTEXT_EXT`, `GLX_VISUAL_ID_EXT`, or `GLX_SCREEN_EXT`. </para> </listitem>",
        "value": "<listitem> <para> Contains the return value for <parameter>attribute</parameter>. </para> </listitem>"
      }
    },
    "glXQueryDrawable": {
      "signature": "int glXQueryDrawable(Display * dpy, GLXDrawable draw, int attribute, unsigned int * value)",
      "purpose": "returns an attribute associated with a GLX drawable",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "draw": "<listitem> <para> Specifies the GLX drawable to be queried. </para> </listitem>",
        "attribute": "<listitem> <para> Specifies the attribute to be returned. Must be one of `GLX_WIDTH`, `GLX_HEIGHT`, `GLX_PRESERVED_CONTENTS`, `GLX_LARGEST_PBUFFER`, or `GLX_FBCONFIG_ID`. </para> </listitem>",
        "value": "<listitem> <para> Contains the return value for <parameter>attribute</parameter>. </para> </listitem>"
      }
    },
    "glXQueryExtension": {
      "signature": "Bool glXQueryExtension(Display * dpy, int * errorBase, int * eventBase)",
      "purpose": "indicate whether the GLX extension is supported",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "errorBase": "<listitem> <para> Returns the base error code of the GLX server extension. </para> </listitem>",
        "eventBase": "<listitem> <para> Returns the base event code of the GLX server extension. </para> </listitem>"
      }
    },
    "glXQueryExtensionsString": {
      "signature": "const char * glXQueryExtensionsString(Display * dpy, int screen)",
      "purpose": "return list of supported extensions",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "screen": "<listitem> <para> Specifies the screen number. </para> </listitem>"
      }
    },
    "glXQueryServerString": {
      "signature": "const char * glXQueryServerString(Display * dpy, int screen, int name)",
      "purpose": "return string describing the server",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "screen": "<listitem> <para> Specifies the screen number. </para> </listitem>",
        "name": "<listitem> <para> Specifies which string is returned: one of `GLX_VENDOR`, `GLX_VERSION`, or `GLX_EXTENSIONS`. </para> </listitem>"
      }
    },
    "glXQueryVersion": {
      "signature": "Bool glXQueryVersion(Display * dpy, int * major, int * minor)",
      "purpose": "return the version numbers of the GLX extension",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "major": "<listitem> <para> Returns the major version number of the GLX server extension. </para> </listitem>",
        "minor": "<listitem> <para> Returns the minor version number of the GLX server extension. </para> </listitem>"
      }
    },
    "glXSelectEvent": {
      "signature": "void glXSelectEvent(Display * dpy, GLXDrawable draw, unsigned long event_mask)",
      "purpose": "select GLX events for a window or a GLX pixel buffer",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "draw": "<listitem> <para> Specifies a GLX drawable. Must be a GLX pixel buffer or a window. </para> </listitem>",
        "event_mask": "<listitem> <para> Specifies the events to be returned for <parameter>draw</parameter>. </para> </listitem>"
      }
    },
    "glXSwapBuffers": {
      "signature": "void glXSwapBuffers(Display * dpy, GLXDrawable drawable)",
      "purpose": "exchange front and back buffers",
      "parameters": {
        "dpy": "<listitem> <para> Specifies the connection to the X server. </para> </listitem>",
        "drawable": "<listitem> <para> Specifies the drawable whose buffers are to be swapped. </para> </listitem>"
      }
    },
    "glXUseXFont": {
      "signature": "void glXUseXFont(Font font, int first, int count, int listBase)",
      "purpose": "create bitmap display lists from an X font",
      "parameters": {
        "font": "<listitem> <para> Specifies the font from which character glyphs are to be taken. </para> </listitem>",
        "first": "<listitem> <para> Specifies the index of the first glyph to be taken. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of glyphs to be taken. </para> </listitem>",
        "listBase": "<listitem> <para> Specifies the index of the first display list to be generated. </para> </listitem>"
      }
    },
    "glXWaitGL": {
      "signature": "void glXWaitGL(void)",
      "purpose": "complete GL execution prior to subsequent X calls",
      "parameters": {}
    },
    "glXWaitX": {
      "signature": "void glXWaitX(void)",
      "purpose": "complete X execution prior to subsequent GL calls",
      "parameters": {}
    }
  },
  "gl4": {
    "abs": {
      "signature": "genDType abs(genDType x)",
      "purpose": "return the absolute value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to return the absolute. </para> </listitem>"
      }
    },
    "acos": {
      "signature": "genType acos(genType x)",
      "purpose": "return the arccosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arccosine to return. </para> </listitem>"
      }
    },
    "acosh": {
      "signature": "genType acosh(genType x)",
      "purpose": "return the arc hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "all": {
      "signature": "bool all(bvec x)",
      "purpose": "check whether all elements of a boolean vector are true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "any": {
      "signature": "bool any(bvec x)",
      "purpose": "check whether any element of a boolean vector is true",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be tested for truth. </para> </listitem>"
      }
    },
    "asin": {
      "signature": "genType asin(genType x)",
      "purpose": "return the arcsine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arcsine to return. </para> </listitem>"
      }
    },
    "asinh": {
      "signature": "genType asinh(genType x)",
      "purpose": "return the arc hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic sine to return. </para> </listitem>"
      }
    },
    "atan": {
      "signature": "genType atan(genType y_over_x)",
      "purpose": "return the arc-tangent of the parameters",
      "parameters": {
        "y": "<listitem> <para> Specify the numerator of the fraction whose arctangent to return. </para> </listitem>",
        "x": "<listitem> <para> Specify the denominator of the fraction whose arctangent to return. </para> </listitem>",
        "y_over_x": "<listitem> <para> Specify the fraction whose arctangent to return. </para> </listitem>"
      }
    },
    "atanh": {
      "signature": "genType atanh(genType x)",
      "purpose": "return the arc hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose arc hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "atomicAdd": {
      "signature": "uint atomicAdd(inout uint mem, uint data)",
      "purpose": "perform an atomic addition to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be added to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicAnd": {
      "signature": "uint atomicAnd(inout uint mem, uint data)",
      "purpose": "perform an atomic logical AND operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically ANDed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicCompSwap": {
      "signature": "uint atomicCompSwap(inout uint mem, uint compare, uint data)",
      "purpose": "perform an atomic compare-exchange operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared and potentially exchanged with <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicCounter": {
      "signature": "uint atomicCounter(atomic_uint c)",
      "purpose": "return the current value of an atomic counter",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter whose value to return. </para> </listitem>"
      }
    },
    "atomicCounterDecrement": {
      "signature": "uint atomicCounterDecrement(atomic_uint c)",
      "purpose": "atomically decrement a counter and return the prior value",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter to decrement. </para> </listitem>"
      }
    },
    "atomicCounterIncrement": {
      "signature": "uint atomicCounterIncrement(atomic_uint c)",
      "purpose": "atomically increment a counter and return the prior value",
      "parameters": {
        "c": "<listitem> <para> Specify the handle to the atomic counter to increment. </para> </listitem>"
      }
    },
    "atomicExchange": {
      "signature": "uint atomicExchange(inout uint mem, uint data)",
      "purpose": "perform an atomic exchange operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be exchanged with <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicMax": {
      "signature": "uint atomicMax(inout uint mem, uint data)",
      "purpose": "perform an atomic max operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicMin": {
      "signature": "uint atomicMin(inout uint mem, uint data)",
      "purpose": "perform an atomic min operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be compared to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicOr": {
      "signature": "uint atomicOr(inout uint mem, uint data)",
      "purpose": "perform an atomic logical OR operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically ORed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "atomicXor": {
      "signature": "uint atomicXor(inout uint mem, uint data)",
      "purpose": "perform an atomic logical exclusive OR operation to a variable",
      "parameters": {
        "mem": "<listitem> <para> The variable to use as the target of the operation. </para> </listitem>",
        "data": "<listitem> <para> The data to be logically exclusive ORed with to <parameter>mem</parameter>. </para> </listitem>"
      }
    },
    "barrier": {
      "signature": "void barrier(void)",
      "purpose": "synchronize execution of multiple shader invocations",
      "parameters": {}
    },
    "bitCount": {
      "signature": "genIType bitCount(genUType value)",
      "purpose": "counts the number of 1 bits in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to count. </para> </listitem>"
      }
    },
    "bitfieldExtract": {
      "signature": "genUType bitfieldExtract(genUType value, int offset, int bits)",
      "purpose": "extract a range of bits from an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the integer from which to extract bits. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the index of the first bit to extract. </para> </listitem>",
        "bits": "<listitem> <para> Specifies the number of bits to extract. </para> </listitem>"
      }
    },
    "bitfieldInsert": {
      "signature": "genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)",
      "purpose": "insert a range of bits into an integer",
      "parameters": {
        "base": "<listitem> <para> Specifies the integer into which to insert <parameter>insert</parameter>. </para> </listitem>",
        "insert": "<listitem> <para> Specifies the value of the bits to insert. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the index of the first bit to insert. </para> </listitem>",
        "bits": "<listitem> <para> Specifies the number of bits to insert. </para> </listitem>"
      }
    },
    "bitfieldReverse": {
      "signature": "genUType bitfieldReverse(genUType value)",
      "purpose": "reverse the order of bits in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to reverse. </para> </listitem>"
      }
    },
    "ceil": {
      "signature": "genDType ceil(genDType x)",
      "purpose": "find the nearest integer that is greater than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "clamp": {
      "signature": "genUType clamp(genUType x, uint minVal, uint maxVal)",
      "purpose": "constrain a value to lie between two further values",
      "parameters": {
        "x": "<listitem> <para> Specify the value to constrain. </para> </listitem>",
        "minVal": "<listitem> <para> Specify the lower end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>",
        "maxVal": "<listitem> <para> Specify the upper end of the range into which to constrain <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "cos": {
      "signature": "genType cos(genType angle)",
      "purpose": "return the cosine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the cosine. </para> </listitem>"
      }
    },
    "cosh": {
      "signature": "genType cosh(genType x)",
      "purpose": "return the hyperbolic cosine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic cosine to return. </para> </listitem>"
      }
    },
    "cross": {
      "signature": "dvec3 cross(dvec3 x, dvec3 y)",
      "purpose": "calculate the cross product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "degrees": {
      "signature": "genType degrees(genType radians)",
      "purpose": "convert a quantity in radians to degrees",
      "parameters": {
        "radians": "<listitem> <para> Specify the quantity, in radians, to be converted to degrees. </para> </listitem>"
      }
    },
    "determinant": {
      "signature": "double determinant(dmat4 m)",
      "purpose": "calculate the determinant of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the determinant. </para> </listitem>"
      }
    },
    "dFdx": {
      "signature": "genType dFdx(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdy": {
      "signature": "genType dFdy(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdxCoarse": {
      "signature": "genType dFdxCoarse(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdyCoarse": {
      "signature": "genType dFdyCoarse(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdxFine": {
      "signature": "genType dFdxFine(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "dFdyFine": {
      "signature": "genType dFdyFine(genType p)",
      "purpose": "return the partial derivative of an argument with respect to x or y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "distance": {
      "signature": "double distance(genDType p0, genDType p1)",
      "purpose": "calculate the distance between two points",
      "parameters": {
        "p0": "<listitem> <para> Specifies the first of two points </para> </listitem>",
        "p1": "<listitem> <para> Specifies the second of two points </para> </listitem>"
      }
    },
    "dot": {
      "signature": "double dot(genDType x, genDType y)",
      "purpose": "calculate the dot product of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first of two vectors </para> </listitem>",
        "y": "<listitem> <para> Specifies the second of two vectors </para> </listitem>"
      }
    },
    "EmitStreamVertex": {
      "signature": "void EmitStreamVertex(int stream)",
      "purpose": "emit a vertex to a specified stream",
      "parameters": {
        "stream": "<listitem> <para> Specifies the stream upon which the vertex will be emitted. </para> </listitem>"
      }
    },
    "EmitVertex": {
      "signature": "void EmitVertex(void)",
      "purpose": "emit a vertex to the first vertex stream",
      "parameters": {}
    },
    "EndPrimitive": {
      "signature": "void EndPrimitive(void)",
      "purpose": "complete the current output primitive on the first vertex stream",
      "parameters": {}
    },
    "EndStreamPrimitive": {
      "signature": "void EndStreamPrimitive(int stream)",
      "purpose": "complete the current output primitive on a specified stream",
      "parameters": {
        "stream": "<listitem> <para> Specifies the stream upon which the current primitive will be ended. </para> </listitem>"
      }
    },
    "equal": {
      "signature": "bvec equal(uvec x, uvec y)",
      "purpose": "perform a component-wise equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "exp": {
      "signature": "genType exp(genType x)",
      "purpose": "return the natural exponentiation of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to exponentiate. </para> </listitem>"
      }
    },
    "exp2": {
      "signature": "genType exp2(genType x)",
      "purpose": "return 2 raised to the power of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of the power to which 2 will be raised. </para> </listitem>"
      }
    },
    "faceforward": {
      "signature": "genDType faceforward(genDType N, genDType I, genDType Nref)",
      "purpose": "return a vector pointing in the same direction as another",
      "parameters": {
        "N": "<listitem> <para> Specifies the vector to orient. </para> </listitem>",
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "Nref": "<listitem> <para> Specifies the reference vector. </para> </listitem>"
      }
    },
    "findLSB": {
      "signature": "genIType findLSB(genUType value)",
      "purpose": "find the index of the least significant bit set to 1 in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to scan. </para> </listitem>"
      }
    },
    "findMSB": {
      "signature": "genIType findMSB(genUType value)",
      "purpose": "find the index of the most significant bit set to 1 in an integer",
      "parameters": {
        "value": "<listitem> <para> Specifies the value whose bits to scan. </para> </listitem>"
      }
    },
    "floatBitsToInt": {
      "signature": "genIType floatBitsToInt(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floatBitsToUint": {
      "signature": "genUType floatBitsToUint(genType x)",
      "purpose": "produce the encoding of a floating point value as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the value whose floating point encoding to return. </para> </listitem>"
      }
    },
    "floor": {
      "signature": "genDType floor(genDType x)",
      "purpose": "find the nearest integer less than or equal to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "fma": {
      "signature": "genDType fma(genDType a, genDType b, genDType c)",
      "purpose": "perform a fused multiply-add operation",
      "parameters": {
        "a": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "b": "<listitem> <para> Specifies the second multiplicand. </para> </listitem>",
        "c": "<listitem> <para> Specifies the value to be added to the result. </para> </listitem>"
      }
    },
    "fract": {
      "signature": "genDType fract(genDType x)",
      "purpose": "compute the fractional part of the argument",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "frexp": {
      "signature": "genDType frexp(genDType x, out genIType exp)",
      "purpose": "split a floating point number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value from which significand and exponent are to be extracted. </para> </listitem>",
        "out exp": "<listitem> <para> Specifies the variable into which to place the exponent </para> </listitem>"
      }
    },
    "fwidth": {
      "signature": "genType fwidth(genType p)",
      "purpose": "return the sum of the absolute value of derivatives in x and y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "fwidthCoarse": {
      "signature": "genType fwidthCoarse(genType p)",
      "purpose": "return the sum of the absolute value of derivatives in x and y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "fwidthFine": {
      "signature": "genType fwidthFine(genType p)",
      "purpose": "return the sum of the absolute value of derivatives in x and y",
      "parameters": {
        "p": "<listitem> <para> Specifies the expression of which to take the partial derivative. </para> </listitem>"
      }
    },
    "glActiveShaderProgram": {
      "signature": "void glActiveShaderProgram(GLuint pipeline, GLuint program)",
      "purpose": "set the active program object for a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the program pipeline object to set the active program object for. </para> </listitem>",
        "program": "<listitem> <para> Specifies the program object to set as the active program pipeline object <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glActiveTexture": {
      "signature": "void glActiveTexture(GLenum texture)",
      "purpose": "select active texture unit",
      "parameters": {
        "texture": "<listitem> <para> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. <parameter>texture</parameter> must be one of `GL_TEXTURE`<emphasis>i</emphasis>, where <emphasis>i</emphasis> ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`. </para> </listitem>"
      }
    },
    "glAttachShader": {
      "signature": "void glAttachShader(GLuint program, GLuint shader)",
      "purpose": "Attaches a shader object to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to which a shader object will be attached.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object that is to be attached.</para> </listitem>"
      }
    },
    "glBeginConditionalRender": {
      "signature": "void glBeginConditionalRender(GLuint id, GLenum mode)",
      "purpose": "start conditional rendering",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </para> </listitem>",
        "mode": "<listitem> <para> Specifies how <function>glBeginConditionalRender</function> interprets the results of the occlusion query. </para> </listitem>"
      }
    },
    "glEndConditionalRender": {
      "signature": "void glEndConditionalRender(void)",
      "purpose": "start conditional rendering",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </para> </listitem>",
        "mode": "<listitem> <para> Specifies how <function>glBeginConditionalRender</function> interprets the results of the occlusion query. </para> </listitem>"
      }
    },
    "glBeginQuery": {
      "signature": "void glBeginQuery(GLenum target, GLuint id)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glEndQuery": {
      "signature": "void glEndQuery(GLenum target)",
      "purpose": "delimit the boundaries of a query object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQuery</function> and the subsequent <function>glEndQuery</function>. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glBeginQueryIndexed": {
      "signature": "void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)",
      "purpose": "delimit the boundaries of a query object on an indexed target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQueryIndexed</function> and the subsequent <function>glEndQueryIndexed</function>. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the query target upon which to begin the query. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glEndQueryIndexed": {
      "signature": "void glEndQueryIndexed(GLenum target, GLuint index)",
      "purpose": "delimit the boundaries of a query object on an indexed target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target type of query object established between <function>glBeginQueryIndexed</function> and the subsequent <function>glEndQueryIndexed</function>. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the query target upon which to begin the query. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>"
      }
    },
    "glBeginTransformFeedback": {
      "signature": "void glBeginTransformFeedback(GLenum primitiveMode)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glEndTransformFeedback": {
      "signature": "void glEndTransformFeedback(void)",
      "purpose": "start transform feedback operation",
      "parameters": {
        "primitiveMode": "<listitem> <para> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </para> </listitem>"
      }
    },
    "glBindAttribLocation": {
      "signature": "void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)",
      "purpose": "Associates a generic vertex attribute index with a named attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object in which the association is to be made.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be bound.</para> </listitem>",
        "name": "<listitem> <para>Specifies a null terminated string containing the name of the vertex shader attribute variable to which <parameter>index</parameter> is to be bound.</para> </listitem>"
      }
    },
    "glBindBuffer": {
      "signature": "void glBindBuffer(GLenum target, GLuint buffer)",
      "purpose": "bind a named buffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>"
      }
    },
    "glBindBufferBase": {
      "signature": "void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)",
      "purpose": "bind a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>"
      }
    },
    "glBindBufferRange": {
      "signature": "void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)",
      "purpose": "bind a range within a buffer object to an indexed buffer target",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER`, or `GL_SHADER_STORAGE_BUFFER`. </para> </listitem>",
        "index": "<listitem> <para> Specify the index of the binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> The name of a buffer object to bind to the specified binding point. </para> </listitem>",
        "offset": "<listitem> <para> The starting offset in basic machine units into the buffer object <parameter>buffer</parameter>. </para> </listitem>",
        "size": "<listitem> <para> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </para> </listitem>"
      }
    },
    "glBindBuffersBase": {
      "signature": "void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers)",
      "purpose": "bind one or more buffer objects to a sequence of indexed buffer targets",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`. </para> </listitem>",
        "first": "<listitem> <para> Specify the index of the first binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specify the number of contiguous binding points to which to bind buffers. </para> </listitem>",
        "buffers": "<listitem> <para> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or `NULL`. </para> </listitem>"
      }
    },
    "glBindBuffersRange": {
      "signature": "void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLintptr *sizes)",
      "purpose": "bind ranges of one or more buffer objects to a sequence of indexed buffer targets",
      "parameters": {
        "target": "<listitem> <para> Specify the target of the bind operation. <parameter>target</parameter> must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`. </para> </listitem>",
        "first": "<listitem> <para> Specify the index of the first binding point within the array specified by <parameter>target</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specify the number of contiguous binding points to which to bind buffers. </para> </listitem>",
        "buffers": "<listitem> <para> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or `NULL`. </para> </listitem>",
        "offsets": "<listitem> <para> A pointer to an array of offsets into the corresponding buffer in <parameter>buffers</parameter> to bind, or `NULL` if <parameter>buffers</parameter> is `NULL`. </para> </listitem>",
        "sizes": "<listitem> <para> A pointer to an array of sizes of the corresponding buffer in <parameter>buffers</parameter> to bind, or `NULL` if <parameter>buffers</parameter> is `NULL`. </para> </listitem>"
      }
    },
    "glBindFragDataLocation": {
      "signature": "void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name)",
      "purpose": "bind a user-defined varying out variable to a fragment shader color number",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to modify </para> </listitem>",
        "colorNumber": "<listitem> <para> The color number to bind the user-defined varying out variable to </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to modify </para> </listitem>"
      }
    },
    "glBindFragDataLocationIndexed": {
      "signature": "void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char *name)",
      "purpose": "bind a user-defined varying out variable to a fragment shader color number and index",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to modify </para> </listitem>",
        "colorNumber": "<listitem> <para> The color number to bind the user-defined varying out variable to </para> </listitem>",
        "index": "<listitem> <para> The index of the color input to bind the user-defined varying out variable to </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to modify </para> </listitem>"
      }
    },
    "glBindFramebuffer": {
      "signature": "void glBindFramebuffer(GLenum target, GLuint framebuffer)",
      "purpose": "bind a framebuffer to a framebuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the framebuffer target of the binding operation. </para> </listitem>",
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object to bind. </para> </listitem>"
      }
    },
    "glBindImageTexture": {
      "signature": "void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)",
      "purpose": "bind a level of a texture to an image unit",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the image unit to which to bind the texture </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of the texture to bind to the image unit. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level of the texture that is to be bound. </para> </listitem>",
        "layered": "<listitem> <para> Specifies whether a layered texture binding is to be established. </para> </listitem>",
        "layer": "<listitem> <para> If <parameter>layered</parameter> is `GL_FALSE`, specifies the layer of <parameter>texture</parameter> to be bound to the image unit. Ignored otherwise. </para> </listitem>",
        "access": "<listitem> <para> Specifies a token indicating the type of access that will be performed on the image. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </para> </listitem>"
      }
    },
    "glBindImageTextures": {
      "signature": "void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures)",
      "purpose": "bind one or more named texture images to a sequence of consecutive image units",
      "parameters": {
        "first": "<listitem> <para> Specifies the first image unit to which a texture is to be bound. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of textures to bind. </para> </listitem>",
        "textures": "<listitem> <para> Specifies the address of an array of names of existing texture objects. </para> </listitem>"
      }
    },
    "glBindProgramPipeline": {
      "signature": "void glBindProgramPipeline(GLuint pipeline)",
      "purpose": "bind a program pipeline to the current context",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of the pipeline object to bind to the context. </para> </listitem>"
      }
    },
    "glBindRenderbuffer": {
      "signature": "void glBindRenderbuffer(GLenum target, GLuint renderbuffer)",
      "purpose": "bind a renderbuffer to a renderbuffer target",
      "parameters": {
        "target": "<listitem> <para> Specifies the renderbuffer target of the binding operation. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of the renderbuffer object to bind. </para> </listitem>"
      }
    },
    "glBindSampler": {
      "signature": "void glBindSampler(GLuint unit, GLuint sampler)",
      "purpose": "bind a named sampler to a texturing target",
      "parameters": {
        "unit": "<listitem> <para> Specifies the index of the texture unit to which the sampler is bound. </para> </listitem>",
        "sampler": "<listitem> <para> Specifies the name of a sampler. </para> </listitem>"
      }
    },
    "glBindSamplers": {
      "signature": "void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers)",
      "purpose": "bind one or more named sampler objects to a sequence of consecutive sampler units",
      "parameters": {
        "first": "<listitem> <para> Specifies the first sampler unit to which a sampler object is to be bound. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of samplers to bind. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies the address of an array of names of existing sampler objects. </para> </listitem>"
      }
    },
    "glBindTexture": {
      "signature": "void glBindTexture(GLenum target, GLuint texture)",
      "purpose": "bind a named texture to a texturing target",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBindTextures": {
      "signature": "void glBindTextures(GLuint first, GLsizei count, const GLuint *textures)",
      "purpose": "bind one or more named textures to a sequence of consecutive texture units",
      "parameters": {
        "first": "<listitem> <para> Specifies the first texture unit to which a texture is to be bound. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of textures to bind. </para> </listitem>",
        "textures": "<listitem> <para> Specifies the address of an array of names of existing texture objects. </para> </listitem>"
      }
    },
    "glBindTextureUnit": {
      "signature": "void glBindTextureUnit(GLuint unit, GLuint texture)",
      "purpose": "bind an existing texture object to the specified texture unit ",
      "parameters": {
        "unit": "<listitem> <para> Specifies the texture unit, to which the texture object should be bound to. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of a texture. </para> </listitem>"
      }
    },
    "glBindTransformFeedback": {
      "signature": "void glBindTransformFeedback(GLenum target, GLuint id)",
      "purpose": "bind a transform feedback object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which to bind the transform feedback object <parameter>id</parameter>. <parameter>target</parameter> must be `GL_TRANSFORM_FEEDBACK`. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object reserved by <citerefentry><refentrytitle>glGenTransformFeedbacks</refentrytitle></citerefentry>. </para> </listitem>"
      }
    },
    "glBindVertexArray": {
      "signature": "void glBindVertexArray(GLuint array)",
      "purpose": "bind a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies the name of the vertex array to bind. </para> </listitem>"
      }
    },
    "glBindVertexBuffer": {
      "signature": "void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)",
      "purpose": "bind a buffer to a vertex buffer bind point",
      "parameters": {
        "vaobj": "<listitem> <para>Specifies the name of the vertex array object to be used by <function>glVertexArrayVertexBuffer</function> function.</para> </listitem>",
        "bindingindex": "<listitem> <para>The index of the vertex buffer binding point to which to bind the buffer.</para> </listitem>",
        "buffer": "<listitem> <para>The name of a buffer to bind to the vertex buffer binding point.</para> </listitem>",
        "offset": "<listitem> <para>The offset of the first element of the buffer.</para> </listitem>",
        "stride": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexArrayVertexBuffer": {
      "signature": "void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)",
      "purpose": "bind a buffer to a vertex buffer bind point",
      "parameters": {
        "vaobj": "<listitem> <para>Specifies the name of the vertex array object to be used by <function>glVertexArrayVertexBuffer</function> function.</para> </listitem>",
        "bindingindex": "<listitem> <para>The index of the vertex buffer binding point to which to bind the buffer.</para> </listitem>",
        "buffer": "<listitem> <para>The name of a buffer to bind to the vertex buffer binding point.</para> </listitem>",
        "offset": "<listitem> <para>The offset of the first element of the buffer.</para> </listitem>",
        "stride": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glBindVertexBuffers": {
      "signature": "void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)",
      "purpose": "attach multiple buffer objects to a vertex array object",
      "parameters": {
        "first": "<listitem> <para> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of buffers to bind. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies the address of an array of names of existing buffer objects. </para> </listitem>",
        "offsets": "<listitem> <para> Specifies the address of an array of offsets to associate with the binding points. </para> </listitem>",
        "strides": "<listitem> <para> Specifies the address of an array of strides to associate with the binding points. </para> </listitem>"
      }
    },
    "glVertexArrayVertexBuffers": {
      "signature": "void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)",
      "purpose": "attach multiple buffer objects to a vertex array object",
      "parameters": {
        "vaobj": "<listitem> <para> Specifies the name of the vertex array object for <function>glVertexArrayVertexBuffers</function>. </para> </listitem>",
        "first": "<listitem> <para> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of buffers to bind. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies the address of an array of names of existing buffer objects. </para> </listitem>",
        "offsets": "<listitem> <para> Specifies the address of an array of offsets to associate with the binding points. </para> </listitem>",
        "strides": "<listitem> <para> Specifies the address of an array of strides to associate with the binding points. </para> </listitem>"
      }
    },
    "glBlendColor": {
      "signature": "void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "set the blend color",
      "parameters": {
        "red": "<listitem> <para> specify the components of `GL_BLEND_COLOR` </para> </listitem>"
      }
    },
    "glBlendEquation": {
      "signature": "void glBlendEquation(GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationi": {
      "signature": "void glBlendEquationi(GLuint buf, GLenum mode)",
      "purpose": "specify the equation used for both the RGB blend equation and the Alpha blend equation",
      "parameters": {
        "buf": "<listitem> <para> for <function>glBlendEquationi</function>, specifies the index of the draw buffer for which to set the blend equation. </para> </listitem>",
        "mode": "<listitem> <para> specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparate": {
      "signature": "void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendEquationSeparatei": {
      "signature": "void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)",
      "purpose": "set the RGB blend equation and the alpha blend equation separately",
      "parameters": {
        "buf": "<listitem> <para> for <function>glBlendEquationSeparatei</function>, specifies the index of the draw buffer for which to set the blend equations. </para> </listitem>",
        "modeRGB": "<listitem> <para> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>",
        "modeAlpha": "<listitem> <para> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`. </para> </listitem>"
      }
    },
    "glBlendFunc": {
      "signature": "void glBlendFunc(GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFunci</function>, specifies the index of the draw buffer for which to set the blend function. </para> </listitem>",
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFunci": {
      "signature": "void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)",
      "purpose": "specify pixel arithmetic",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFunci</function>, specifies the index of the draw buffer for which to set the blend function. </para> </listitem>",
        "sfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dfactor": "<listitem> <para> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparate": {
      "signature": "void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFuncSeparatei</function>, specifies the index of the draw buffer for which to set the blend functions. </para> </listitem>",
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlendFuncSeparatei": {
      "signature": "void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)",
      "purpose": "specify pixel arithmetic for RGB and alpha components separately",
      "parameters": {
        "buf": "<listitem> <para> For <function>glBlendFuncSeparatei</function>, specifies the index of the draw buffer for which to set the blend functions. </para> </listitem>",
        "srcRGB": "<listitem> <para> Specifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstRGB": "<listitem> <para> Specifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`. </para> </listitem>",
        "srcAlpha": "<listitem> <para> Specified how the alpha source blending factor is computed. The initial value is `GL_ONE`. </para> </listitem>",
        "dstAlpha": "<listitem> <para> Specified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`. </para> </listitem>"
      }
    },
    "glBlitFramebuffer": {
      "signature": "void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)",
      "purpose": "copy a block of pixels from one framebuffer object to another",
      "parameters": {
        "srcX0": "<listitem> <para> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </para> </listitem>",
        "dstX0": "<listitem> <para> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </para> </listitem>",
        "mask": "<listitem> <para> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>",
        "filter": "<listitem> <para> Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`. </para> </listitem>"
      }
    },
    "glBlitNamedFramebuffer": {
      "signature": "void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)",
      "purpose": "copy a block of pixels from one framebuffer object to another",
      "parameters": {
        "readFramebuffer": "<listitem> <para> Specifies the name of the source framebuffer object for <function>glBlitNamedFramebuffer</function>. </para> </listitem>",
        "drawFramebuffer": "<listitem> <para> Specifies the name of the destination framebuffer object for <function>glBlitNamedFramebuffer</function>. </para> </listitem>",
        "srcX0": "<listitem> <para> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </para> </listitem>",
        "dstX0": "<listitem> <para> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </para> </listitem>",
        "mask": "<listitem> <para> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>",
        "filter": "<listitem> <para> Specifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`. </para> </listitem>"
      }
    },
    "glBufferData": {
      "signature": "void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data    store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glBufferData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "size": "<listitem> <para>Specifies the size in bytes of the buffer object's new data store.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.</para> </listitem>",
        "usage": "<listitem> <para>Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.</para> </listitem>"
      }
    },
    "glNamedBufferData": {
      "signature": "void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage)",
      "purpose": "creates and initializes a buffer object's data    store",
      "parameters": {
        "buffer": "<listitem> <para>Specifies the name of the buffer object for <function>glNamedBufferData</function> function.</para> </listitem>",
        "size": "<listitem> <para>Specifies the size in bytes of the buffer object's new data store.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.</para> </listitem>",
        "usage": "<listitem> <para>Specifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.</para> </listitem>"
      }
    },
    "glBufferStorage": {
      "signature": "void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags)",
      "purpose": "creates and initializes a buffer object's immutable data    store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glBufferStorage</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "size": "<listitem> <para>Specifies the size in bytes of the buffer object's new data store.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.</para> </listitem>",
        "flags": "<listitem> <para>Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. `GL_DYNAMIC_STORAGE_BIT`, `GL_MAP_READ_BIT` `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, `GL_MAP_COHERENT_BIT`, and `GL_CLIENT_STORAGE_BIT`.</para> </listitem>"
      }
    },
    "glNamedBufferStorage": {
      "signature": "void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags)",
      "purpose": "creates and initializes a buffer object's immutable data    store",
      "parameters": {
        "buffer": "<listitem> <para>Specifies the name of the buffer object for <function>glNamedBufferStorage</function> function.</para> </listitem>",
        "size": "<listitem> <para>Specifies the size in bytes of the buffer object's new data store.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.</para> </listitem>",
        "flags": "<listitem> <para>Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. `GL_DYNAMIC_STORAGE_BIT`, `GL_MAP_READ_BIT` `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, `GL_MAP_COHERENT_BIT`, and `GL_CLIENT_STORAGE_BIT`.</para> </listitem>"
      }
    },
    "glBufferSubData": {
      "signature": "void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)",
      "purpose": "updates a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glBufferSubData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glNamedBufferSubData": {
      "signature": "void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data)",
      "purpose": "updates a subset of a buffer object's data store",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glNamedBufferSubData</function>. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being replaced. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the new data that will be copied into the data store. </para> </listitem>"
      }
    },
    "glCheckFramebufferStatus": {
      "signature": "GLenum glCheckFramebufferStatus(GLenum target)",
      "purpose": "check the completeness status of a framebuffer",
      "parameters": {}
    },
    "glCheckNamedFramebufferStatus": {
      "signature": "GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target)",
      "purpose": "check the completeness status of a framebuffer",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glCheckNamedFramebufferStatus</function> </para> </listitem>"
      }
    },
    "glClampColor": {
      "signature": "void glClampColor(GLenum target, GLenum clamp)",
      "purpose": "specify whether data read via ",
      "parameters": {
        "target": "<listitem> <para> Target for color clamping. <parameter>target</parameter> must be `GL_CLAMP_READ_COLOR`. </para> </listitem>",
        "clamp": "<listitem> <para> Specifies whether to apply color clamping. <parameter>clamp</parameter> must be `GL_TRUE` or `GL_FALSE`. </para> </listitem>"
      }
    },
    "glClear": {
      "signature": "void glClear(GLbitfield mask)",
      "purpose": "clear buffers to preset values",
      "parameters": {
        "mask": "<listitem> <para> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. </para> </listitem>"
      }
    },
    "glClearBufferiv": {
      "signature": "void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearBufferuiv": {
      "signature": "void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfv": {
      "signature": "void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearBufferfi": {
      "signature": "void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearNamedFramebufferiv": {
      "signature": "void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearNamedFramebufferuiv": {
      "signature": "void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearNamedFramebufferfv": {
      "signature": "void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearNamedFramebufferfi": {
      "signature": "void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)",
      "purpose": "clear individual buffers of a framebuffer",
      "parameters": {
        "buffer": "<listitem> <para> Specify the buffer to clear. </para> </listitem>",
        "drawbuffer": "<listitem> <para> Specify a particular draw buffer to clear. </para> </listitem>",
        "value": "<listitem> <para> A pointer to the value or values to clear the buffer to. </para> </listitem>",
        "depth": "<listitem> <para> The value to clear the depth buffer to. </para> </listitem>",
        "stencil": "<listitem> <para> The value to clear the stencil buffer to. </para> </listitem>"
      }
    },
    "glClearBufferData": {
      "signature": "void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data)",
      "purpose": "fill a buffer object's data store with a fixed value",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glClearBufferData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "internalformat": "<listitem> <para> The internal format with which the data will be stored in the buffer object. </para> </listitem>",
        "format": "<listitem> <para> The format of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "type": "<listitem> <para> The type of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> The address of a memory location storing the data to be replicated into the buffer's data store. </para> </listitem>"
      }
    },
    "glClearNamedBufferData": {
      "signature": "void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data)",
      "purpose": "fill a buffer object's data store with a fixed value",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glClearNamedBufferData</function>. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format with which the data will be stored in the buffer object. </para> </listitem>",
        "format": "<listitem> <para> The format of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "type": "<listitem> <para> The type of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> The address of a memory location storing the data to be replicated into the buffer's data store. </para> </listitem>"
      }
    },
    "glClearBufferSubData": {
      "signature": "void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data)",
      "purpose": "fill all or part of buffer object's data store with a fixed value",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glClearBufferSubData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "internalformat": "<listitem> <para> The internal format with which the data will be stored in the buffer object. </para> </listitem>",
        "offset": "<listitem> <para> The offset in basic machine units into the buffer object's data store at which to start filling. </para> </listitem>",
        "size": "<listitem> <para> The size in basic machine units of the range of the data store to fill. </para> </listitem>",
        "format": "<listitem> <para> The format of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "type": "<listitem> <para> The type of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> The address of a memory location storing the data to be replicated into the buffer's data store. </para> </listitem>"
      }
    },
    "glClearNamedBufferSubData": {
      "signature": "void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data)",
      "purpose": "fill all or part of buffer object's data store with a fixed value",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glClearNamedBufferSubData</function>. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format with which the data will be stored in the buffer object. </para> </listitem>",
        "offset": "<listitem> <para> The offset in basic machine units into the buffer object's data store at which to start filling. </para> </listitem>",
        "size": "<listitem> <para> The size in basic machine units of the range of the data store to fill. </para> </listitem>",
        "format": "<listitem> <para> The format of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "type": "<listitem> <para> The type of the data in memory addressed by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> The address of a memory location storing the data to be replicated into the buffer's data store. </para> </listitem>"
      }
    },
    "glClearColor": {
      "signature": "void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)",
      "purpose": "specify clear values for the color buffers",
      "parameters": {
        "red": "<listitem> <para> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </para> </listitem>"
      }
    },
    "glClearDepth": {
      "signature": "void glClearDepth(GLdouble depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearDepthf": {
      "signature": "void glClearDepthf(GLfloat depth)",
      "purpose": "specify the clear value for the depth buffer",
      "parameters": {
        "depth": "<listitem> <para> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </para> </listitem>"
      }
    },
    "glClearStencil": {
      "signature": "void glClearStencil(GLint s)",
      "purpose": "specify the clear value for the stencil buffer",
      "parameters": {
        "s": "<listitem> <para> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </para> </listitem>"
      }
    },
    "glClearTexImage": {
      "signature": "void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data)",
      "purpose": "fills all a texture image with a constant value",
      "parameters": {
        "texture": "<listitem> <para> The name of an existing texture object containing the image to be cleared. </para> </listitem>",
        "level": "<listitem> <para> The level of <parameter>texture</parameter> containing the region to be cleared. </para> </listitem>",
        "format": "<listitem> <para> The format of the data whose address in memory is given by <parameter>data</parameter>. </para> </listitem>",
        "type": "<listitem> <para> The type of the data whose address in memory is given by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> The address in memory of the data to be used to clear the specified region. </para> </listitem>"
      }
    },
    "glClearTexSubImage": {
      "signature": "void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)",
      "purpose": "fills all or part of a texture image with a constant value",
      "parameters": {
        "texture": "<listitem> <para> The name of an existing texture object containing the image to be cleared. </para> </listitem>",
        "level": "<listitem> <para> The level of <parameter>texture</parameter> containing the region to be cleared. </para> </listitem>",
        "xoffset": "<listitem> <para> The coordinate of the left edge of the region to be cleared. </para> </listitem>",
        "yoffset": "<listitem> <para> The coordinate of the lower edge of the region to be cleared. </para> </listitem>",
        "zoffset": "<listitem> <para> The coordinate of the front of the region to be cleared. </para> </listitem>",
        "width": "<listitem> <para> The width of the region to be cleared. </para> </listitem>",
        "height": "<listitem> <para> The height of the region to be cleared. </para> </listitem>",
        "depth": "<listitem> <para> The depth of the region to be cleared. </para> </listitem>",
        "format": "<listitem> <para> The format of the data whose address in memory is given by <parameter>data</parameter>. </para> </listitem>",
        "type": "<listitem> <para> The type of the data whose address in memory is given by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> The address in memory of the data to be used to clear the specified region. </para> </listitem>"
      }
    },
    "glClientWaitSync": {
      "signature": "GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "block and wait for a sync object to become signaled",
      "parameters": {
        "sync": "<listitem> <para> The sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> may be `GL_SYNC_FLUSH_COMMANDS_BIT`. </para> </listitem>",
        "timeout": "<listitem> <para> The timeout, specified in nanoseconds, for which the implementation should wait for <parameter>sync</parameter> to become signaled. </para> </listitem>"
      }
    },
    "glClipControl": {
      "signature": "void glClipControl(GLenum origin, GLenum depth)",
      "purpose": "control clip coordinate to window coordinate behavior",
      "parameters": {
        "origin": "<listitem> <para> Specifies the clip control origin. Must be one of `GL_LOWER_LEFT` or `GL_UPPER_LEFT`. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the clip control depth mode. Must be one of `GL_NEGATIVE_ONE_TO_ONE` or `GL_ZERO_TO_ONE`. </para> </listitem>"
      }
    },
    "glColorMask": {
      "signature": "void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "buf": "<listitem> <para> For <function>glColorMaski</function>, specifies the index of the draw buffer whose color mask to set. </para> </listitem>",
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
      }
    },
    "glColorMaski": {
      "signature": "void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)",
      "purpose": "enable and disable writing of frame buffer color components",
      "parameters": {
        "buf": "<listitem> <para> For <function>glColorMaski</function>, specifies the index of the draw buffer whose color mask to set. </para> </listitem>",
        "red": "<listitem> <para> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written. </para> </listitem>"
      }
    },
    "glCompileShader": {
      "signature": "void glCompileShader(GLuint shader)",
      "purpose": "Compiles a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be compiled.</para> </listitem>"
      }
    },
    "glCompressedTexImage1D": {
      "signature": "void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a one-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage2D": {
      "signature": "void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexImage3D": {
      "signature": "void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture image in a compressed format",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the format of the compressed image data stored at address <parameter>data</parameter>. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "imageSize": "<listitem> <para> Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the compressed image data in memory. </para> </listitem>"
      }
    },
    "glCompressedTexSubImage1D": {
      "signature": "void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a one-dimensional texture subimage in a compressed    format",
      "parameters": {
        "target": "<listitem> <para>Specifies the target, to which the texture is bound, for <function>glCompressedTexSubImage1D</function> function. Must be `GL_TEXTURE_1D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the compressed image data stored at address <parameter>data</parameter>.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCompressedTextureSubImage1D": {
      "signature": "void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data)",
      "purpose": "specify a one-dimensional texture subimage in a compressed    format",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glCompressedTextureSubImage1D</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the compressed image data stored at address <parameter>data</parameter>.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCompressedTexSubImage2D": {
      "signature": "void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para>Specifies the target to which the texture is bound for <function>glCompressedTexSubImage2D</function> function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the compressed image data stored at address <parameter>data</parameter>.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCompressedTextureSubImage2D": {
      "signature": "void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data)",
      "purpose": "specify a two-dimensional texture subimage in a compressed format",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glCompressedTextureSubImage2D</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the compressed image data stored at address <parameter>data</parameter>.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCompressedTexSubImage3D": {
      "signature": "void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)",
      "purpose": "specify a three-dimensional texture subimage in a compressed format",
      "parameters": {
        "target": "<listitem> <para>Specifies the target to which the texture is bound for <function>glCompressedTexSubImage3D</function> function. Must be `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "zoffset": "<listitem> <para>Specifies a texel offset in the z direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "depth": "<listitem> <para>Specifies the depth of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the compressed image data stored at address <parameter>data</parameter>.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCompressedTextureSubImage3D": {
      "signature": "void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data)",
      "purpose": "specify a three-dimensional texture subimage in a compressed format",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glCompressedTextureSubImage3D</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "zoffset": "<listitem> <para>Specifies a texel offset in the z direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "depth": "<listitem> <para>Specifies the depth of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the compressed image data stored at address <parameter>data</parameter>.</para> </listitem>",
        "imageSize": "<listitem> <para>Specifies the number of unsigned bytes of image data starting at the address specified by <parameter>data</parameter>.</para> </listitem>",
        "data": "<listitem> <para>Specifies a pointer to the compressed image data in memory.</para> </listitem>"
      }
    },
    "glCopyBufferSubData": {
      "signature": "void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)",
      "purpose": "copy all or part of the data store of a buffer object to the data store of another buffer object",
      "parameters": {
        "readTarget": "<listitem> <para> Specifies the target to which the source buffer object is bound for <function>glCopyBufferSubData</function> </para> </listitem>",
        "writeTarget": "<listitem> <para> Specifies the target to which the destination buffer object is bound for <function>glCopyBufferSubData</function>. </para> </listitem>",
        "readOffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </para> </listitem>",
        "writeOffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </para> </listitem>"
      }
    },
    "glCopyNamedBufferSubData": {
      "signature": "void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)",
      "purpose": "copy all or part of the data store of a buffer object to the data store of another buffer object",
      "parameters": {
        "readBuffer": "<listitem> <para> Specifies the name of the source buffer object for <function>glCopyNamedBufferSubData</function>. </para> </listitem>",
        "writeBuffer": "<listitem> <para> Specifies the name of the destination buffer object for <function>glCopyNamedBufferSubData</function>. </para> </listitem>",
        "readOffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </para> </listitem>",
        "writeOffset": "<listitem> <para> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </para> </listitem>"
      }
    },
    "glCopyImageSubData": {
      "signature": "void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)",
      "purpose": "perform a raw data copy between two images",
      "parameters": {
        "srcName": "<listitem> <para> The name of a texture or renderbuffer object from which to copy. </para> </listitem>",
        "srcTarget": "<listitem> <para> The target representing the namespace of the source name <parameter>srcName</parameter>. </para> </listitem>",
        "srcLevel": "<listitem> <para> The mipmap level to read from the source. </para> </listitem>",
        "srcX": "<listitem> <para> The X coordinate of the left edge of the souce region to copy. </para> </listitem>",
        "srcY": "<listitem> <para> The Y coordinate of the top edge of the souce region to copy. </para> </listitem>",
        "srcZ": "<listitem> <para> The Z coordinate of the near edge of the souce region to copy. </para> </listitem>",
        "dstName": "<listitem> <para> The name of a texture or renderbuffer object to which to copy. </para> </listitem>",
        "dstTarget": "<listitem> <para> The target representing the namespace of the destination name <parameter>dstName</parameter>. </para> </listitem>",
        "dstX": "<listitem> <para> The X coordinate of the left edge of the destination region. </para> </listitem>",
        "dstY": "<listitem> <para> The Y coordinate of the top edge of the destination region. </para> </listitem>",
        "dstZ": "<listitem> <para> The Z coordinate of the near edge of the destination region. </para> </listitem>",
        "srcWidth": "<listitem> <para> The width of the region to be copied. </para> </listitem>",
        "srcHeight": "<listitem> <para> The height of the region to be copied. </para> </listitem>",
        "srcDepth": "<listitem> <para> The depth of the region to be copied. </para> </listitem>"
      }
    },
    "glCopyTexImage1D": {
      "signature": "void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)",
      "purpose": "copy pixels into a 1D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`, `GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the left corner of the row of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. The height of the texture image is 1. </para> </listitem>",
        "border": "<listitem> <para> Must be 0. </para> </listitem>"
      }
    },
    "glCopyTexImage2D": {
      "signature": "void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)",
      "purpose": "copy pixels into a 2D texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the texture. Must be one of the following symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`, `GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`. </para> </listitem>",
        "x": "<listitem> <para> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. </para> </listitem>",
        "border": "<listitem> <para> Must be 0. </para> </listitem>"
      }
    },
    "glCopyTexSubImage1D": {
      "signature": "void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)",
      "purpose": "copy a one-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para>Specifies the target to which the texture object is bound for <function>glCopyTexSubImage1D</function> function. Must be `GL_TEXTURE_1D`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies the texel offset within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the left corner of the row of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>"
      }
    },
    "glCopyTextureSubImage1D": {
      "signature": "void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)",
      "purpose": "copy a one-dimensional texture subimage",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glCopyTextureSubImage1D</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies the texel offset within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the left corner of the row of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>"
      }
    },
    "glCopyTexSubImage2D": {
      "signature": "void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para>Specifies the target to which the texture object is bound for <function>glCopyTexSubImage2D</function> function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_RECTANGLE`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>"
      }
    },
    "glCopyTextureSubImage2D": {
      "signature": "void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a two-dimensional texture subimage",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glCopyTextureSubImage2D</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>"
      }
    },
    "glCopyTexSubImage3D": {
      "signature": "void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para>Specifies the target to which the texture object is bound for <function>glCopyTexSubImage3D</function> function. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "zoffset": "<listitem> <para>Specifies a texel offset in the z direction within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>"
      }
    },
    "glCopyTextureSubImage3D": {
      "signature": "void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "copy a three-dimensional texture subimage",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glCopyTextureSubImage3D</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "zoffset": "<listitem> <para>Specifies a texel offset in the z direction within the texture array.</para> </listitem>",
        "x": "<listitem> <para>Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>"
      }
    },
    "glCreateBuffers": {
      "signature": "void glCreateBuffers(GLsizei n, GLuint *buffers)",
      "purpose": "create buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to create. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which names of the new buffer objects are stored. </para> </listitem>"
      }
    },
    "glCreateFramebuffers": {
      "signature": "void glCreateFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "create framebuffer objects",
      "parameters": {
        "n": "<listitem> <para> Number of framebuffer objects to create. </para> </listitem>",
        "framebuffers": "<listitem> <para> Specifies an array in which names of the new framebuffer objects are stored. </para> </listitem>"
      }
    },
    "glCreateProgram": {
      "signature": "GLuint glCreateProgram(void)",
      "purpose": "Creates a program object",
      "parameters": {}
    },
    "glCreateProgramPipelines": {
      "signature": "void glCreateProgramPipelines(GLsizei n, GLuint *pipelines)",
      "purpose": "create program pipeline objects",
      "parameters": {
        "n": "<listitem> <para> Number of program pipeline objects to create. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array in which names of the new program pipeline objects are stored. </para> </listitem>"
      }
    },
    "glCreateQueries": {
      "signature": "void glCreateQueries(GLenum target, GLsizei n, GLuint *ids)",
      "purpose": "create query objects",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of each created query object. </para> </listitem>",
        "n": "<listitem> <para> Number of query objects to create. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which names of the new query objects are stored. </para> </listitem>"
      }
    },
    "glCreateRenderbuffers": {
      "signature": "void glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "create renderbuffer objects",
      "parameters": {
        "n": "<listitem> <para> Number of renderbuffer objects to create. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array in which names of the new renderbuffer objects are stored. </para> </listitem>"
      }
    },
    "glCreateSamplers": {
      "signature": "void glCreateSamplers(GLsizei n, GLuint *samplers)",
      "purpose": "create sampler objects",
      "parameters": {
        "n": "<listitem> <para> Number of sampler objects to create. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array in which names of the new sampler objects are stored. </para> </listitem>"
      }
    },
    "glCreateShader": {
      "signature": "GLuint glCreateShader(GLenum shaderType)",
      "purpose": "Creates a shader object",
      "parameters": {
        "shaderType": "<listitem> <para>Specifies the type of shader to be created. Must be one of `GL_COMPUTE_SHADER`, `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER`, or `GL_FRAGMENT_SHADER`.</para> </listitem>"
      }
    },
    "glCreateShaderProgramv": {
      "signature": "GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char **strings)",
      "purpose": "create a stand-alone program from an array of null-terminated source code strings",
      "parameters": {
        "type": "<listitem> <para> Specifies the type of shader to create. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of source code strings in the array <parameter>strings</parameter>. </para> </listitem>",
        "strings": "<listitem> <para> Specifies the address of an array of pointers to source code strings from which to create the program object. </para> </listitem>"
      }
    },
    "glCreateTextures": {
      "signature": "void glCreateTextures(GLenum target, GLsizei n, GLuint *textures)",
      "purpose": "create texture objects",
      "parameters": {
        "target": "<listitem> <para> Specifies the effective texture target of each created texture. </para> </listitem>",
        "n": "<listitem> <para> Number of texture objects to create. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which names of the new texture objects are stored. </para> </listitem>"
      }
    },
    "glCreateTransformFeedbacks": {
      "signature": "void glCreateTransformFeedbacks(GLsizei n, GLuint *ids)",
      "purpose": "create transform feedback objects",
      "parameters": {
        "n": "<listitem> <para> Number of transform feedback objects to create. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which names of the new transform feedback objects are stored. </para> </listitem>"
      }
    },
    "glCreateVertexArrays": {
      "signature": "void glCreateVertexArrays(GLsizei n, GLuint *arrays)",
      "purpose": "create vertex array objects",
      "parameters": {
        "n": "<listitem> <para> Number of vertex array objects to create. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies an array in which names of the new vertex array objects are stored. </para> </listitem>"
      }
    },
    "glCullFace": {
      "signature": "void glCullFace(GLenum mode)",
      "purpose": "specify whether front- or back-facing facets can be culled",
      "parameters": {
        "mode": "<listitem> <para> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`. </para> </listitem>"
      }
    },
    "glDebugMessageCallback": {
      "signature": "void glDebugMessageCallback(DEBUGPROC callback, const void * userParam)",
      "purpose": "specify a callback to receive debugging messages from the GL",
      "parameters": {
        "callback": "<listitem> <para> The address of a callback function that will be called when a debug message is generated. </para> </listitem>",
        "userParam": "<listitem> <para> A user supplied pointer that will be passed on each invocation of <parameter>callback</parameter>. </para> </listitem>"
      }
    },
    "glDebugMessageControl": {
      "signature": "void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)",
      "purpose": "control the reporting of debug messages in a debug context",
      "parameters": {
        "source": "<listitem> <para> The source of debug messages to enable or disable. </para> </listitem>",
        "type": "<listitem> <para> The type of debug messages to enable or disable. </para> </listitem>",
        "severity": "<listitem> <para> The severity of debug messages to enable or disable. </para> </listitem>",
        "count": "<listitem> <para> The length of the array <parameter>ids</parameter>. </para> </listitem>",
        "ids": "<listitem> <para> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </para> </listitem>",
        "enabled": "<listitem> <para> A Boolean flag determining whether the selected messages should be enabled or disabled. </para> </listitem>"
      }
    },
    "glDebugMessageInsert": {
      "signature": "void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message)",
      "purpose": "inject an application-supplied message into the debug message queue",
      "parameters": {
        "source": "<listitem> <para> The source of the debug message to insert. </para> </listitem>",
        "type": "<listitem> <para> The type of the debug message insert. </para> </listitem>",
        "id": "<listitem> <para> The user-supplied identifier of the message to insert. </para> </listitem>",
        "severity": "<listitem> <para> The severity of the debug messages to insert. </para> </listitem>",
        "length": "<listitem> <para> The length string contained in the character array whose address is given by <parameter>message</parameter>. </para> </listitem>",
        "message": "<listitem> <para> The address of a character array containing the message to insert. </para> </listitem>"
      }
    },
    "glDeleteBuffers": {
      "signature": "void glDeleteBuffers(GLsizei n, const GLuint * buffers)",
      "purpose": "delete named buffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer objects to be deleted. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array of buffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteFramebuffers": {
      "signature": "void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)",
      "purpose": "delete framebuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer objects to be deleted. </para> </listitem>",
        "framebuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> framebuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteProgram": {
      "signature": "void glDeleteProgram(GLuint program)",
      "purpose": "Deletes a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteProgramPipelines": {
      "signature": "void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)",
      "purpose": "delete program pipeline objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of program pipeline objects to delete. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array of names of program pipeline objects to delete. </para> </listitem>"
      }
    },
    "glDeleteQueries": {
      "signature": "void glDeleteQueries(GLsizei n, const GLuint * ids)",
      "purpose": "delete named query objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query objects to be deleted. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of query objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteRenderbuffers": {
      "signature": "void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "delete renderbuffer objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer objects to be deleted. </para> </listitem>",
        "renderbuffers": "<listitem> <para> A pointer to an array containing <parameter>n</parameter> renderbuffer objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteSamplers": {
      "signature": "void glDeleteSamplers(GLsizei n, const GLuint * samplers)",
      "purpose": "delete named sampler objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler objects to be deleted. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array of sampler objects to be deleted. </para> </listitem>"
      }
    },
    "glDeleteShader": {
      "signature": "void glDeleteShader(GLuint shader)",
      "purpose": "Deletes a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be deleted.</para> </listitem>"
      }
    },
    "glDeleteSync": {
      "signature": "void glDeleteSync(GLsync sync)",
      "purpose": "delete a sync object",
      "parameters": {
        "sync": "<listitem> <para> The sync object to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTextures": {
      "signature": "void glDeleteTextures(GLsizei n, const GLuint * textures)",
      "purpose": "delete named textures",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of textures to be deleted. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array of textures to be deleted. </para> </listitem>"
      }
    },
    "glDeleteTransformFeedbacks": {
      "signature": "void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)",
      "purpose": "delete transform feedback objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback objects to delete. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of names of transform feedback objects to delete. </para> </listitem>"
      }
    },
    "glDeleteVertexArrays": {
      "signature": "void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)",
      "purpose": "delete vertex array objects",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array objects to be deleted. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies the address of an array containing the <parameter>n</parameter> names of the objects to be deleted. </para> </listitem>"
      }
    },
    "glDepthFunc": {
      "signature": "void glDepthFunc(GLenum func)",
      "purpose": "specify the value used for depth buffer comparisons",
      "parameters": {
        "func": "<listitem> <para> Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`. </para> </listitem>"
      }
    },
    "glDepthMask": {
      "signature": "void glDepthMask(GLboolean flag)",
      "purpose": "enable or disable writing into the depth buffer",
      "parameters": {
        "flag": "<listitem> <para> Specifies whether the depth buffer is enabled for writing. If <parameter>flag</parameter> is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </para> </listitem>"
      }
    },
    "glDepthRange": {
      "signature": "void glDepthRange(GLdouble nearVal, GLdouble farVal)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "nearVal": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "farVal": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDepthRangef": {
      "signature": "void glDepthRangef(GLfloat nearVal, GLfloat farVal)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates",
      "parameters": {
        "nearVal": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "farVal": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDepthRangeArrayv": {
      "signature": "void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble *v)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports",
      "parameters": {
        "first": "<listitem> <para> Specifies the index of the first viewport whose depth range to update. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of viewports whose depth range to update. </para> </listitem>",
        "v": "<listitem> <para> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </para> </listitem>"
      }
    },
    "glDepthRangeIndexed": {
      "signature": "void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal)",
      "purpose": "specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport",
      "parameters": {
        "index": "<listitem> <para> Specifies the index of the viewport whose depth range to update. </para> </listitem>",
        "nearVal": "<listitem> <para> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </para> </listitem>",
        "farVal": "<listitem> <para> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </para> </listitem>"
      }
    },
    "glDetachShader": {
      "signature": "void glDetachShader(GLuint program, GLuint shader)",
      "purpose": "Detaches a shader object from a program object to which it is attached",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object from which to detach the shader object.</para> </listitem>",
        "shader": "<listitem> <para>Specifies the shader object to be detached.</para> </listitem>"
      }
    },
    "glDispatchCompute": {
      "signature": "void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)",
      "purpose": "launch one or more compute work groups",
      "parameters": {
        "num_groups_x": "<listitem> <para> The number of work groups to be launched in the X dimension. </para> </listitem>",
        "num_groups_y": "<listitem> <para> The number of work groups to be launched in the Y dimension. </para> </listitem>",
        "num_groups_z": "<listitem> <para> The number of work groups to be launched in the Z dimension. </para> </listitem>"
      }
    },
    "glDispatchComputeIndirect": {
      "signature": "void glDispatchComputeIndirect(GLintptr indirect)",
      "purpose": "launch one or more compute work groups using parameters stored in a buffer",
      "parameters": {
        "indirect": "<listitem> <para> The offset into the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` buffer target at which the dispatch parameters are stored. </para> </listitem>"
      }
    },
    "glDrawArrays": {
      "signature": "void glDrawArrays(GLenum mode, GLint first, GLsizei count)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawArraysIndirect": {
      "signature": "void glDrawArraysIndirect(GLenum mode, const void *indirect)",
      "purpose": "render primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing the draw parameters. </para> </listitem>"
      }
    },
    "glDrawArraysInstanced": {
      "signature": "void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)",
      "purpose": "draw multiple instances of a range of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawArraysInstancedBaseInstance": {
      "signature": "void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance)",
      "purpose": "draw multiple instances of a range of elements with offset applied to instanced attributes",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Specifies the starting index in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of indices to be rendered. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>",
        "baseinstance": "<listitem> <para> Specifies the base instance for use in fetching instanced vertex attributes. </para> </listitem>"
      }
    },
    "glDrawBuffer": {
      "signature": "void glDrawBuffer(GLenum buf)",
      "purpose": "specify which color buffers are to be drawn into",
      "parameters": {
        "buf": "<listitem> <para>For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for double-buffered contexts. For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.</para> </listitem>"
      }
    },
    "glNamedFramebufferDrawBuffer": {
      "signature": "void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf)",
      "purpose": "specify which color buffers are to be drawn into",
      "parameters": {
        "framebuffer": "<listitem> <para>Specifies the name of the framebuffer object for <function>glNamedFramebufferDrawBuffer</function> function. Must be zero or the name of a framebuffer object.</para> </listitem>",
        "buf": "<listitem> <para>For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for double-buffered contexts. For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.</para> </listitem>"
      }
    },
    "glDrawBuffers": {
      "signature": "void glDrawBuffers(GLsizei n, const GLenum *bufs)",
      "purpose": "Specifies a list of color buffers to be drawn    into",
      "parameters": {
        "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
        "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
      }
    },
    "glNamedFramebufferDrawBuffers": {
      "signature": "void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs)",
      "purpose": "Specifies a list of color buffers to be drawn    into",
      "parameters": {
        "framebuffer": "<listitem> <para>Specifies the name of the framebuffer object for <function>glNamedFramebufferDrawBuffers</function>.</para> </listitem>",
        "n": "<listitem> <para>Specifies the number of buffers in <parameter>bufs</parameter>.</para> </listitem>",
        "bufs": "<listitem> <para>Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</para> </listitem>"
      }
    },
    "glDrawElements": {
      "signature": "void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawElementsBaseVertex": {
      "signature": "void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex)",
      "purpose": "render primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>"
      }
    },
    "glDrawElementsIndirect": {
      "signature": "void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect)",
      "purpose": "render indexed primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing the draw parameters. </para> </listitem>"
      }
    },
    "glDrawElementsInstanced": {
      "signature": "void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)",
      "purpose": "draw multiple instances of a set of elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>"
      }
    },
    "glDrawElementsInstancedBaseInstance": {
      "signature": "void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance)",
      "purpose": "draw multiple instances of a set of elements with offset applied to instanced attributes",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the specified range of indices to be rendered. </para> </listitem>",
        "baseinstance": "<listitem> <para> Specifies the base instance for use in fetching instanced vertex attributes. </para> </listitem>"
      }
    },
    "glDrawElementsInstancedBaseVertex": {
      "signature": "void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex)",
      "purpose": "render multiple instances of a set of primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the indexed geometry that should be drawn. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>"
      }
    },
    "glDrawElementsInstancedBaseVertexBaseInstance": {
      "signature": "void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance)",
      "purpose": "render multiple instances of a set of primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the indexed geometry that should be drawn. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>",
        "baseinstance": "<listitem> <para> Specifies the base instance for use in fetching instanced vertex attributes. </para> </listitem>"
      }
    },
    "glDrawRangeElements": {
      "signature": "void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)",
      "purpose": "render primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>"
      }
    },
    "glDrawRangeElementsBaseVertex": {
      "signature": "void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex)",
      "purpose": "render primitives from array data with a per-element offset",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "start": "<listitem> <para> Specifies the minimum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "end": "<listitem> <para> Specifies the maximum array index contained in <parameter>indices</parameter>. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of elements to be rendered. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a constant that should be added to each element of <parameter>indices</parameter> when chosing elements from the enabled vertex arrays. </para> </listitem>"
      }
    },
    "glDrawTransformFeedback": {
      "signature": "void glDrawTransformFeedback(GLenum mode, GLuint id)",
      "purpose": "render primitives using a count derived from a transform feedback object",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object from which to retrieve a primitive count. </para> </listitem>"
      }
    },
    "glDrawTransformFeedbackInstanced": {
      "signature": "void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount)",
      "purpose": "render multiple instances of primitives using a count derived from a transform feedback object",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object from which to retrieve a primitive count. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the geometry to render. </para> </listitem>"
      }
    },
    "glDrawTransformFeedbackStream": {
      "signature": "void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)",
      "purpose": "render primitives using a count derived from a specifed stream of a transform feedback object",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object from which to retrieve a primitive count. </para> </listitem>",
        "stream": "<listitem> <para> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </para> </listitem>"
      }
    },
    "glDrawTransformFeedbackStreamInstanced": {
      "signature": "void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount)",
      "purpose": "render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "id": "<listitem> <para> Specifies the name of a transform feedback object from which to retrieve a primitive count. </para> </listitem>",
        "stream": "<listitem> <para> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </para> </listitem>",
        "instancecount": "<listitem> <para> Specifies the number of instances of the geometry to render. </para> </listitem>"
      }
    },
    "glEnable": {
      "signature": "void glEnable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisable": {
      "signature": "void glDisable(GLenum cap)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnablei": {
      "signature": "void glEnablei(GLenum cap, GLuint index)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glDisablei": {
      "signature": "void glDisablei(GLenum cap, GLuint index)",
      "purpose": "enable or disable server-side GL capabilities",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>"
      }
    },
    "glEnableVertexAttribArray": {
      "signature": "void glEnableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute    array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexAttribArray": {
      "signature": "void glDisableVertexAttribArray(GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute    array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glEnableVertexArrayAttrib": {
      "signature": "void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute    array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glDisableVertexArrayAttrib": {
      "signature": "void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index)",
      "purpose": "Enable or disable a generic vertex attribute    array",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be enabled or disabled.</para> </listitem>"
      }
    },
    "glFenceSync": {
      "signature": "GLsync glFenceSync(GLenum condition, GLbitfield flags)",
      "purpose": "create a new sync object and insert it into the GL command stream",
      "parameters": {
        "condition": "<listitem> <para> Specifies the condition that must be met to set the sync object's state to signaled. <parameter>condition</parameter> must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. </para> </listitem>",
        "flags": "<listitem> <para> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and <parameter>flags</parameter> must be zero.<footnote><para> <parameter>flags</parameter> is a placeholder for anticipated future extensions of fence sync object capabilities. </para> </footnote> </para> </listitem>"
      }
    },
    "glFinish": {
      "signature": "void glFinish( void)",
      "purpose": "block until all GL execution is complete",
      "parameters": {}
    },
    "glFlush": {
      "signature": "void glFlush( void)",
      "purpose": "force execution of GL commands in finite time",
      "parameters": {}
    },
    "glFlushMappedBufferRange": {
      "signature": "void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)",
      "purpose": "indicate modifications to a range of a mapped buffer",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glFlushMappedBufferRange</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the start of the buffer subrange, in basic machine units. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the buffer subrange, in basic machine units. </para> </listitem>"
      }
    },
    "glFlushMappedNamedBufferRange": {
      "signature": "void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length)",
      "purpose": "indicate modifications to a range of a mapped buffer",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glFlushMappedNamedBufferRange</function>. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the start of the buffer subrange, in basic machine units. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the buffer subrange, in basic machine units. </para> </listitem>"
      }
    },
    "glFramebufferParameteri": {
      "signature": "void glFramebufferParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set a named parameter of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for <function>glFramebufferParameteri</function>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the framebuffer parameter to be modified. </para> </listitem>",
        "param": "<listitem> <para> The new value for the parameter named <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glNamedFramebufferParameteri": {
      "signature": "void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param)",
      "purpose": "set a named parameter of a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glNamedFramebufferParameteri</function>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the framebuffer parameter to be modified. </para> </listitem>",
        "param": "<listitem> <para> The new value for the parameter named <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glFramebufferRenderbuffer": {
      "signature": "void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
      "purpose": "attach a renderbuffer as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for <function>glFramebufferRenderbuffer</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "renderbuffertarget": "<listitem> <para> Specifies the renderbuffer target. Must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of an existing renderbuffer object of type <parameter>renderbuffertarget</parameter> to attach. </para> </listitem>"
      }
    },
    "glNamedFramebufferRenderbuffer": {
      "signature": "void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)",
      "purpose": "attach a renderbuffer as a logical buffer of a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glNamedFramebufferRenderbuffer</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "renderbuffertarget": "<listitem> <para> Specifies the renderbuffer target. Must be `GL_RENDERBUFFER`. </para> </listitem>",
        "renderbuffer": "<listitem> <para> Specifies the name of an existing renderbuffer object of type <parameter>renderbuffertarget</parameter> to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture": {
      "signature": "void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for all commands <emphasis>except</emphasis> <function>glNamedFramebufferTexture</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "textarget": "<listitem> <para> For <function>glFramebufferTexture1D</function>, <function>glFramebufferTexture2D</function> and <function>glFramebufferTexture3D</function>, specifies what type of texture is expected in the <parameter>texture</parameter> parameter, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture1D": {
      "signature": "void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for all commands <emphasis>except</emphasis> <function>glNamedFramebufferTexture</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "textarget": "<listitem> <para> For <function>glFramebufferTexture1D</function>, <function>glFramebufferTexture2D</function> and <function>glFramebufferTexture3D</function>, specifies what type of texture is expected in the <parameter>texture</parameter> parameter, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture2D": {
      "signature": "void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for all commands <emphasis>except</emphasis> <function>glNamedFramebufferTexture</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "textarget": "<listitem> <para> For <function>glFramebufferTexture1D</function>, <function>glFramebufferTexture2D</function> and <function>glFramebufferTexture3D</function>, specifies what type of texture is expected in the <parameter>texture</parameter> parameter, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>"
      }
    },
    "glFramebufferTexture3D": {
      "signature": "void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)",
      "purpose": "attach a level of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for all commands <emphasis>except</emphasis> <function>glNamedFramebufferTexture</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "textarget": "<listitem> <para> For <function>glFramebufferTexture1D</function>, <function>glFramebufferTexture2D</function> and <function>glFramebufferTexture3D</function>, specifies what type of texture is expected in the <parameter>texture</parameter> parameter, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>"
      }
    },
    "glNamedFramebufferTexture": {
      "signature": "void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)",
      "purpose": "attach a level of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for all commands <emphasis>except</emphasis> <function>glNamedFramebufferTexture</function>. </para> </listitem>",
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glNamedFramebufferTexture</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "textarget": "<listitem> <para> For <function>glFramebufferTexture1D</function>, <function>glFramebufferTexture2D</function> and <function>glFramebufferTexture3D</function>, specifies what type of texture is expected in the <parameter>texture</parameter> parameter, or for cube map textures, which face is to be attached. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>"
      }
    },
    "glFramebufferTextureLayer": {
      "signature": "void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)",
      "purpose": "attach a single layer of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer is bound for <function>glFramebufferTextureLayer</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>",
        "layer": "<listitem> <para> Specifies the layer of the texture object to attach. </para> </listitem>"
      }
    },
    "glNamedFramebufferTextureLayer": {
      "signature": "void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)",
      "purpose": "attach a single layer of a texture object as a logical buffer of a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glNamedFramebufferTextureLayer</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment point of the framebuffer. </para> </listitem>",
        "texture": "<listitem> <para> Specifies the name of an existing texture object to attach. </para> </listitem>",
        "level": "<listitem> <para> Specifies the mipmap level of the texture object to attach. </para> </listitem>",
        "layer": "<listitem> <para> Specifies the layer of the texture object to attach. </para> </listitem>"
      }
    },
    "glFrontFace": {
      "signature": "void glFrontFace(GLenum mode)",
      "purpose": "define front- and back-facing polygons",
      "parameters": {
        "mode": "<listitem> <para> Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`. </para> </listitem>"
      }
    },
    "glGenBuffers": {
      "signature": "void glGenBuffers(GLsizei n, GLuint * buffers)",
      "purpose": "generate buffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of buffer object names to be generated. </para> </listitem>",
        "buffers": "<listitem> <para> Specifies an array in which the generated buffer object names are stored. </para> </listitem>"
      }
    },
    "glGenerateMipmap": {
      "signature": "void glGenerateMipmap(GLenum target)",
      "purpose": "generate mipmaps for a specified texture object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glGenerateMipmap</function>. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>"
      }
    },
    "glGenerateTextureMipmap": {
      "signature": "void glGenerateTextureMipmap(GLuint texture)",
      "purpose": "generate mipmaps for a specified texture object",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glGenerateTextureMipmap</function>. </para> </listitem>"
      }
    },
    "glGenFramebuffers": {
      "signature": "void glGenFramebuffers(GLsizei n, GLuint *ids)",
      "purpose": "generate framebuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of framebuffer object names to generate. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which the generated framebuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenProgramPipelines": {
      "signature": "void glGenProgramPipelines(GLsizei n, GLuint *pipelines)",
      "purpose": "reserve program pipeline object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of program pipeline object names to reserve. </para> </listitem>",
        "pipelines": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenQueries": {
      "signature": "void glGenQueries(GLsizei n, GLuint * ids)",
      "purpose": "generate query object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of query object names to be generated. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array in which the generated query object names are stored. </para> </listitem>"
      }
    },
    "glGenRenderbuffers": {
      "signature": "void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)",
      "purpose": "generate renderbuffer object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of renderbuffer object names to generate. </para> </listitem>",
        "renderbuffers": "<listitem> <para> Specifies an array in which the generated renderbuffer object names are stored. </para> </listitem>"
      }
    },
    "glGenSamplers": {
      "signature": "void glGenSamplers(GLsizei n, GLuint *samplers)",
      "purpose": "generate sampler object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of sampler object names to generate. </para> </listitem>",
        "samplers": "<listitem> <para> Specifies an array in which the generated sampler object names are stored. </para> </listitem>"
      }
    },
    "glGenTextures": {
      "signature": "void glGenTextures(GLsizei n, GLuint * textures)",
      "purpose": "generate texture names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of texture names to be generated. </para> </listitem>",
        "textures": "<listitem> <para> Specifies an array in which the generated texture names are stored. </para> </listitem>"
      }
    },
    "glGenTransformFeedbacks": {
      "signature": "void glGenTransformFeedbacks(GLsizei n, GLuint *ids)",
      "purpose": "reserve transform feedback object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of transform feedback object names to reserve. </para> </listitem>",
        "ids": "<listitem> <para> Specifies an array of into which the reserved names will be written. </para> </listitem>"
      }
    },
    "glGenVertexArrays": {
      "signature": "void glGenVertexArrays(GLsizei n, GLuint *arrays)",
      "purpose": "generate vertex array object names",
      "parameters": {
        "n": "<listitem> <para> Specifies the number of vertex array object names to generate. </para> </listitem>",
        "arrays": "<listitem> <para> Specifies an array in which the generated vertex array object names are stored. </para> </listitem>"
      }
    },
    "glGetBooleanv": {
      "signature": "void glGetBooleanv(GLenum pname, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetDoublev": {
      "signature": "void glGetDoublev(GLenum pname, GLdouble * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloatv": {
      "signature": "void glGetFloatv(GLenum pname, GLfloat * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegerv": {
      "signature": "void glGetIntegerv(GLenum pname, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64v": {
      "signature": "void glGetInteger64v(GLenum pname, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetBooleani_v": {
      "signature": "void glGetBooleani_v(GLenum target, GLuint index, GLboolean * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetIntegeri_v": {
      "signature": "void glGetIntegeri_v(GLenum target, GLuint index, GLint * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetFloati_v": {
      "signature": "void glGetFloati_v(GLenum target, GLuint index, GLfloat * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetDoublei_v": {
      "signature": "void glGetDoublei_v(GLenum target, GLuint index, GLdouble * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetInteger64i_v": {
      "signature": "void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data)",
      "purpose": "return the value or values of a selected parameter",
      "parameters": {
        "pname": "<listitem> <para> Specifies the parameter value to be returned for non-indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "target": "<listitem> <para> Specifies the parameter value to be returned for indexed versions of <function>glGet</function>. The symbolic constants in the list below are accepted. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the particular element being queried. </para> </listitem>",
        "data": "<listitem> <para> Returns the value or values of the specified parameter. </para> </listitem>"
      }
    },
    "glGetActiveAtomicCounterBufferiv": {
      "signature": "void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)",
      "purpose": "retrieve information about the set of active atomic counter buffers for a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object from which to retrieve information. </para> </listitem>",
        "bufferIndex": "<listitem> <para> Specifies index of an active atomic counter buffer. </para> </listitem>",
        "pname": "<listitem> <para> Specifies which parameter of the atomic counter buffer to retrieve. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
      }
    },
    "glGetActiveAttrib": {
      "signature": "void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active attribute variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the attribute variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the attribute variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the attribute variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the attribute variable.</para> </listitem>"
      }
    },
    "glGetActiveSubroutineName": {
      "signature": "void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)",
      "purpose": "query the name of an active shader subroutine",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of the program containing the subroutine. </para> </listitem>",
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query the subroutine name. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the shader subroutine uniform. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </para> </listitem>",
        "name": "<listitem> <para> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </para> </listitem>"
      }
    },
    "glGetActiveSubroutineUniformiv": {
      "signature": "void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values)",
      "purpose": "query a property of an active shader subroutine uniform",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of the program containing the subroutine. </para> </listitem>",
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for the subroutine parameter. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the shader subroutine uniform. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of the shader subroutine uniform to query. <parameter>pname</parameter> must be `GL_NUM_COMPATIBLE_SUBROUTINES`, `GL_COMPATIBLE_SUBROUTINES`, `GL_UNIFORM_SIZE` or `GL_UNIFORM_NAME_LENGTH`. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of a into which the queried value or values will be placed. </para> </listitem>"
      }
    },
    "glGetActiveSubroutineUniformName": {
      "signature": "void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)",
      "purpose": "query the name of an active shader subroutine uniform",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of the program containing the subroutine. </para> </listitem>",
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for the subroutine parameter. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the shader subroutine uniform. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable into which is written the number of characters copied into <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </para> </listitem>"
      }
    },
    "glGetActiveUniform": {
      "signature": "void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)",
      "purpose": "Returns information about an active uniform variable for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by <parameter>name</parameter>.</para> </listitem>",
        "length": "<listitem> <para>Returns the number of characters actually written by OpenGL in the string indicated by <parameter>name</parameter> (excluding the null terminator) if a value other than `NULL` is passed.</para> </listitem>",
        "size": "<listitem> <para>Returns the size of the uniform variable.</para> </listitem>",
        "type": "<listitem> <para>Returns the data type of the uniform variable.</para> </listitem>",
        "name": "<listitem> <para>Returns a null terminated string containing the name of the uniform variable.</para> </listitem>"
      }
    },
    "glGetActiveUniformBlockiv": {
      "signature": "void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)",
      "purpose": "query information about an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to query. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable to receive the result of the query. </para> </listitem>"
      }
    },
    "glGetActiveUniformBlockName": {
      "signature": "void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)",
      "purpose": "retrieve the name of an active uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> Specifies the index of the uniform block within <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer addressed by <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of characters that were written to <parameter>uniformBlockName</parameter>. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters to receive the name of the uniform block at <parameter>uniformBlockIndex</parameter>. </para> </listitem>"
      }
    },
    "glGetActiveUniformName": {
      "signature": "void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)",
      "purpose": "query the name of an active uniform",
      "parameters": {
        "program": "<listitem> <para> Specifies the program containing the active uniform index <parameter>uniformIndex</parameter>. </para> </listitem>",
        "uniformIndex": "<listitem> <para> Specifies the index of the active uniform whose name to query. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer, in units of <code>GLchar</code>, of the buffer whose address is specified in <parameter>uniformName</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by <parameter>uniformName</parameter>. </para> </listitem>",
        "uniformName": "<listitem> <para> Specifies the address of a buffer into which the GL will place the name of the active uniform at <parameter>uniformIndex</parameter> within <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glGetActiveUniformsiv": {
      "signature": "void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)",
      "purpose": "Returns information about several active uniform variables for the specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "uniformCount": "<listitem> <para>Specifies both the number of elements in the array of indices <parameter>uniformIndices</parameter> and the number of parameters written to <parameter>params</parameter> upon successful return.</para> </listitem>",
        "uniformIndices": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers containing the indices of uniforms within <parameter>program</parameter> whose parameter <parameter>pname</parameter> should be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the property of each uniform in <parameter>uniformIndices</parameter> that should be written into the corresponding element of <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Specifies the address of an array of <parameter>uniformCount</parameter> integers which are to receive the value of <parameter>pname</parameter> for each uniform in <parameter>uniformIndices</parameter>.</para> </listitem>"
      }
    },
    "glGetAttachedShaders": {
      "signature": "void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)",
      "purpose": "Returns the handles of the shader objects attached to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "maxCount": "<listitem> <para>Specifies the size of the array for storing the returned object names.</para> </listitem>",
        "count": "<listitem> <para>Returns the number of names actually returned in <parameter>shaders</parameter>.</para> </listitem>",
        "shaders": "<listitem> <para>Specifies an array that is used to return the names of attached shader objects.</para> </listitem>"
      }
    },
    "glGetAttribLocation": {
      "signature": "GLint glGetAttribLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of an attribute variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetBufferParameteriv": {
      "signature": "void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "value": "<listitem> <para> Specifies the name of the buffer object parameter to query. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferParameteri64v": {
      "signature": "void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "value": "<listitem> <para> Specifies the name of the buffer object parameter to query. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetNamedBufferParameteriv": {
      "signature": "void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint *params)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "value": "<listitem> <para> Specifies the name of the buffer object parameter to query. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetNamedBufferParameteri64v": {
      "signature": "void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 *params)",
      "purpose": "return parameters of a buffer object",
      "parameters": {
        "value": "<listitem> <para> Specifies the name of the buffer object parameter to query. </para> </listitem>",
        "data": "<listitem> <para> Returns the requested parameter. </para> </listitem>"
      }
    },
    "glGetBufferPointerv": {
      "signature": "void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)",
      "purpose": "return the pointer to a mapped buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glGetBufferPointerv</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "pname": "<listitem> <para> Specifies the name of the pointer to be returned. Must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetNamedBufferPointerv": {
      "signature": "void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params)",
      "purpose": "return the pointer to a mapped buffer object's data store",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glGetNamedBufferPointerv</function>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the pointer to be returned. Must be `GL_BUFFER_MAP_POINTER`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetBufferSubData": {
      "signature": "void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data)",
      "purpose": "returns a subset of a buffer object's data store",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glGetBufferSubData</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being returned. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the location where buffer object data is returned. </para> </listitem>"
      }
    },
    "glGetNamedBufferSubData": {
      "signature": "void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data)",
      "purpose": "returns a subset of a buffer object's data store",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glGetNamedBufferSubData</function>. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size in bytes of the data store region being returned. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the location where buffer object data is returned. </para> </listitem>"
      }
    },
    "glGetCompressedTexImage": {
      "signature": "void glGetCompressedTexImage(GLenum target, GLint level, void * pixels)",
      "purpose": "return a compressed texture image",
      "parameters": {
        "level": "<listitem> <para>Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the compressed texture image.</para> </listitem>"
      }
    },
    "glGetnCompressedTexImage": {
      "signature": "void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels)",
      "purpose": "return a compressed texture image",
      "parameters": {
        "level": "<listitem> <para>Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the compressed texture image.</para> </listitem>"
      }
    },
    "glGetCompressedTextureImage": {
      "signature": "void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels)",
      "purpose": "return a compressed texture image",
      "parameters": {
        "texture": "<listitem> <para>Specifies the texture object name for <function>glGetCompressedTextureImage</function> function.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the compressed texture image.</para> </listitem>"
      }
    },
    "glGetCompressedTextureSubImage": {
      "signature": "void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels)",
      "purpose": "retrieve a sub-region of a compressed texture image from a    compressed texture object",
      "parameters": {
        "texture": "<listitem> <para>Specifies the name of the source texture object. Must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific, buffer and multisample textures are not permitted.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "zoffset": "<listitem> <para>Specifies a texel offset in the z direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the <parameter>offset</parameter> is zero and the size equals the texture image size.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the <parameter>offset</parameter> is zero and the size equals the texture image size.</para> </listitem>",
        "depth": "<listitem> <para>Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the <parameter>offset</parameter> is zero and the size equals the texture image size.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer to receive the retrieved pixel data.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the texture subimage. Should be a pointer to an array of the type specified by type.</para> </listitem>"
      }
    },
    "glGetDebugMessageLog": {
      "signature": "GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)",
      "purpose": "retrieve messages from the debug message log",
      "parameters": {
        "count": "<listitem> <para> The number of debug messages to retrieve from the log. </para> </listitem>",
        "bufSize": "<listitem> <para> The size of the buffer whose address is given by <parameter>messageLog</parameter>. </para> </listitem>",
        "sources": "<listitem> <para> The address of an array of variables to receive the sources of the retrieved messages. </para> </listitem>",
        "types": "<listitem> <para> The address of an array of variables to receive the types of the retrieved messages. </para> </listitem>",
        "ids": "<listitem> <para> The address of an array of unsigned integers to receive the ids of the retrieved messages. </para> </listitem>",
        "severities": "<listitem> <para> The address of an array of variables to receive the severites of the retrieved messages. </para> </listitem>",
        "lengths": "<listitem> <para> The address of an array of variables to receive the lengths of the received messages. </para> </listitem>",
        "messageLog": "<listitem> <para> The address of an array of characters that will receive the messages. </para> </listitem>"
      }
    },
    "glGetError": {
      "signature": "GLenum glGetError( void)",
      "purpose": "return error information",
      "parameters": {}
    },
    "glGetFragDataIndex": {
      "signature": "GLint glGetFragDataIndex(GLuint program, const char * name)",
      "purpose": "query the bindings of color indices to user-defined varying out variables",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to query </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose index to query </para> </listitem>"
      }
    },
    "glGetFragDataLocation": {
      "signature": "GLint glGetFragDataLocation(GLuint program, const char * name)",
      "purpose": "query the bindings of color numbers to user-defined varying out variables",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing varying out variable whose binding to query </para> </listitem>",
        "name": "<listitem> <para> The name of the user-defined varying out variable whose binding to query </para> </listitem>"
      }
    },
    "glGetFramebufferAttachmentParameteriv": {
      "signature": "void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)",
      "purpose": "retrieve information about attachments of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer object is bound for <function>glGetFramebufferAttachmentParameteriv</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment of the framebuffer object to query. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of <parameter>attachment</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> Returns the value of parameter <parameter>pname</parameter> for <parameter>attachment</parameter>. </para> </listitem>"
      }
    },
    "glGetNamedFramebufferAttachmentParameteriv": {
      "signature": "void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)",
      "purpose": "retrieve information about attachments of a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glGetNamedFramebufferAttachmentParameteriv</function>. </para> </listitem>",
        "attachment": "<listitem> <para> Specifies the attachment of the framebuffer object to query. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of <parameter>attachment</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> Returns the value of parameter <parameter>pname</parameter> for <parameter>attachment</parameter>. </para> </listitem>"
      }
    },
    "glGetFramebufferParameteriv": {
      "signature": "void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)",
      "purpose": "query a named parameter of a framebuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer object is bound for <function>glGetFramebufferParameteriv</function>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of the framebuffer object to query. </para> </listitem>",
        "params": "<listitem> <para> Returns the value of parameter <parameter>pname</parameter> for the framebuffer object. </para> </listitem>"
      }
    },
    "glGetNamedFramebufferParameteriv": {
      "signature": "void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint *param)",
      "purpose": "query a named parameter of a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glGetNamedFramebufferParameteriv</function>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of the framebuffer object to query. </para> </listitem>",
        "params": "<listitem> <para> Returns the value of parameter <parameter>pname</parameter> for the framebuffer object. </para> </listitem>"
      }
    },
    "glGetGraphicsResetStatus": {
      "signature": "GLenum glGetGraphicsResetStatus(void)",
      "purpose": "check if the rendering context has not been lost due to software or hardware issues",
      "parameters": {}
    },
    "glGetInternalformativ": {
      "signature": "void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)",
      "purpose": "retrieve information about implementation-dependent support for internal formats",
      "parameters": {
        "target": "<listitem> <para> Indicates the usage of the internal format. <parameter>target</parameter> must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format about which to retrieve information. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the type of information to query. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of integers of the specified width that may be written to <parameter>params</parameter> by the function. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
      }
    },
    "glGetInternalformati64v": {
      "signature": "void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)",
      "purpose": "retrieve information about implementation-dependent support for internal formats",
      "parameters": {
        "target": "<listitem> <para> Indicates the usage of the internal format. <parameter>target</parameter> must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format about which to retrieve information. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the type of information to query. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of integers of the specified width that may be written to <parameter>params</parameter> by the function. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which to write the retrieved information. </para> </listitem>"
      }
    },
    "glGetMultisamplefv": {
      "signature": "void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)",
      "purpose": "retrieve the location of a sample",
      "parameters": {
        "pname": "<listitem> <para> Specifies the sample parameter name. <parameter>pname</parameter> must be `GL_SAMPLE_POSITION`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the sample whose position to query. </para> </listitem>",
        "val": "<listitem> <para> Specifies the address of an array to receive the position of the sample. </para> </listitem>"
      }
    },
    "glGetObjectLabel": {
      "signature": "void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label)",
      "purpose": "retrieve the label of a named object identified within a namespace",
      "parameters": {
        "identifier": "<listitem> <para> The namespace from which the name of the object is allocated. </para> </listitem>",
        "name": "<listitem> <para> The name of the object whose label to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The length of the buffer whose address is in <parameter>label</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable to receive the length of the object label. </para> </listitem>",
        "label": "<listitem> <para> The address of a string that will receive the object label. </para> </listitem>"
      }
    },
    "glGetObjectPtrLabel": {
      "signature": "void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label)",
      "purpose": "retrieve the label of a sync object identified by a pointer",
      "parameters": {
        "ptr": "<listitem> <para> The name of the sync object whose label to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The length of the buffer whose address is in <parameter>label</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable to receive the length of the object label. </para> </listitem>",
        "label": "<listitem> <para> The address of a string that will receive the object label. </para> </listitem>"
      }
    },
    "glGetPointerv": {
      "signature": "void glGetPointerv(GLenum pname, void ** params)",
      "purpose": "return the address of the specified pointer",
      "parameters": {
        "pname": "<listitem> <para> Specifies the pointer to be returned. Must be one of `GL_DEBUG_CALLBACK_FUNCTION` or `GL_DEBUG_CALLBACK_USER_PARAM`. </para> </listitem>",
        "params": "<listitem> <para> Returns the pointer value specified by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramiv": {
      "signature": "void glGetProgramiv(GLuint program, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_DELETE_STATUS`, `GL_LINK_STATUS`, `GL_VALIDATE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_COMPUTE_WORK_GROUP_SIZE`, `GL_PROGRAM_BINARY_LENGTH`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, `GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE`, and `GL_GEOMETRY_OUTPUT_TYPE`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetProgramBinary": {
      "signature": "void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary)",
      "purpose": "return a binary representation of a program object's compiled and linked executable source",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose binary representation to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given by <parameter>binary</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable to receive the number of bytes written into <parameter>binary</parameter>. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address an array into which the GL will return <parameter>program</parameter>'s binary representation. </para> </listitem>"
      }
    },
    "glGetProgramInfoLog": {
      "signature": "void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetProgramInterfaceiv": {
      "signature": "void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params)",
      "purpose": "query a property of an interface in a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose interface to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> to query. </para> </listitem>",
        "pname": "<listitem> <para> The name of the parameter within <parameter>programInterface</parameter> to query. </para> </listitem>",
        "params": "<listitem> <para> The address of a variable to retrieve the value of <parameter>pname</parameter> for the program interface. </para> </listitem>"
      }
    },
    "glGetProgramPipelineiv": {
      "signature": "void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)",
      "purpose": "retrieve properties of a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object whose parameter retrieve. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to retrieve. </para> </listitem>",
        "params": "<listitem> <para> Specifies the address of a variable into which will be written the value or values of <parameter>pname</parameter> for <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramPipelineInfoLog": {
      "signature": "void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)",
      "purpose": "retrieve the info log string from a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object from which to retrieve the info log. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the maximum number of characters, including the null terminator, that may be written into <parameter>infoLog</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of a variable into which will be written the number of characters written into <parameter>infoLog</parameter>. </para> </listitem>",
        "infoLog": "<listitem> <para> Specifies the address of an array of characters into which will be written the info log for <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramResourceiv": {
      "signature": "void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params)",
      "purpose": "retrieve values for multiple properties of a single active resource within a program object",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>"
      }
    },
    "glGetProgramResourceIndex": {
      "signature": "GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the index of a named resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the index of. </para> </listitem>"
      }
    },
    "glGetProgramResourceLocation": {
      "signature": "GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the location of a named resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the location of. </para> </listitem>"
      }
    },
    "glGetProgramResourceLocationIndex": {
      "signature": "GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name)",
      "purpose": "query the fragment color index of a named variable within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the resource named <parameter>name</parameter>. </para> </listitem>",
        "name": "<listitem> <para> The name of the resource to query the location of. </para> </listitem>"
      }
    },
    "glGetProgramResourceName": {
      "signature": "void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name)",
      "purpose": "query the name of an indexed resource within a program",
      "parameters": {
        "program": "<listitem> <para> The name of a program object whose resources to query. </para> </listitem>",
        "programInterface": "<listitem> <para> A token identifying the interface within <parameter>program</parameter> containing the indexed resource. </para> </listitem>",
        "index": "<listitem> <para> The index of the resource within <parameter>programInterface</parameter> of <parameter>program</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> The size of the character array whose address is given by <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the length of the resource name. </para> </listitem>",
        "name": "<listitem> <para> The address of a character array into which will be written the name of the resource. </para> </listitem>"
      }
    },
    "glGetProgramStageiv": {
      "signature": "void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values)",
      "purpose": "retrieve properties of a program object corresponding to a specified shader stage",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of the program containing shader stage. </para> </listitem>",
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for the subroutine parameter. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of the shader to query. <parameter>pname</parameter> must be `GL_ACTIVE_SUBROUTINE_UNIFORMS`, `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`, `GL_ACTIVE_SUBROUTINES`, `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, or `GL_ACTIVE_SUBROUTINE_MAX_LENGTH`. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of a variable into which the queried value or values will be placed. </para> </listitem>"
      }
    },
    "glGetQueryIndexediv": {
      "signature": "void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params)",
      "purpose": "return parameters of an indexed query object target",
      "parameters": {
        "target": "<listitem> <para> Specifies a query object target. Must be `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the query object target. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryiv": {
      "signature": "void glGetQueryiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object target",
      "parameters": {
        "target": "<listitem> <para> Specifies a query object target. Must be `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`. </para> </listitem>",
        "params": "<listitem> <para> Returns the requested data. </para> </listitem>"
      }
    },
    "glGetQueryObjectiv": {
      "signature": "void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryObjectuiv": {
      "signature": "void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryObjecti64v": {
      "signature": "void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryObjectui64v": {
      "signature": "void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryBufferObjectiv": {
      "signature": "void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryBufferObjectuiv": {
      "signature": "void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryBufferObjecti64v": {
      "signature": "void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetQueryBufferObjectui64v": {
      "signature": "void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)",
      "purpose": "return parameters of a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies the name of a query object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of a buffer object. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`. </para> </listitem>",
        "params": "<listitem> <para> If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then <parameter>params</parameter> is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then <parameter>params</parameter> is treated as an address in client memory of a variable to receive the resulting data. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the byte offset into <parameter>buffer</parameter>'s data store where the queried result will be written. </para> </listitem>"
      }
    },
    "glGetRenderbufferParameteriv": {
      "signature": "void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)",
      "purpose": "query a named parameter of a renderbuffer object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the renderbuffer object is bound for <function>glGetRenderbufferParameteriv</function>. <parameter>target</parameter> must be `GL_RENDERBUFFER`. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of the renderbuffer object to query. </para> </listitem>",
        "params": "<listitem> <para> Returns the value of parameter <parameter>pname</parameter> for the renderbuffer object. </para> </listitem>"
      }
    },
    "glGetNamedRenderbufferParameteriv": {
      "signature": "void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint *params)",
      "purpose": "query a named parameter of a renderbuffer object",
      "parameters": {
        "renderbuffer": "<listitem> <para> Specifies the name of the renderbuffer object for <function>glGetNamedRenderbufferParameteriv</function>. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter of the renderbuffer object to query. </para> </listitem>",
        "params": "<listitem> <para> Returns the value of parameter <parameter>pname</parameter> for the renderbuffer object. </para> </listitem>"
      }
    },
    "glGetSamplerParameterfv": {
      "signature": "void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameteriv": {
      "signature": "void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameterIiv": {
      "signature": "void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetSamplerParameterIuiv": {
      "signature": "void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params)",
      "purpose": "return sampler parameter values",
      "parameters": {
        "sampler": "<listitem> <para> Specifies name of the sampler object from which to retrieve parameters. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted. </para> </listitem>",
        "params": "<listitem> <para> Returns the sampler parameters. </para> </listitem>"
      }
    },
    "glGetShaderiv": {
      "signature": "void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)",
      "purpose": "Returns a parameter from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested object parameter.</para> </listitem>"
      }
    },
    "glGetShaderInfoLog": {
      "signature": "void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)",
      "purpose": "Returns the information log for a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object whose information log is to be queried.</para> </listitem>",
        "maxLength": "<listitem> <para>Specifies the size of the character buffer for storing the returned information log.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>infoLog</parameter> (excluding the null terminator).</para> </listitem>",
        "infoLog": "<listitem> <para>Specifies an array of characters that is used to return the information log.</para> </listitem>"
      }
    },
    "glGetShaderPrecisionFormat": {
      "signature": "void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)",
      "purpose": "retrieve the range and precision for numeric formats supported by the shader compiler",
      "parameters": {
        "shaderType": "<listitem> <para> Specifies the type of shader whose precision to query. <parameter>shaderType</parameter> must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "precisionType": "<listitem> <para> Specifies the numeric format whose precision and range to query. </para> </listitem>",
        "range": "<listitem> <para> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </para> </listitem>",
        "precision": "<listitem> <para> Specifies the address of an integer into which the numeric precision of the implementation is written. </para> </listitem>"
      }
    },
    "glGetShaderSource": {
      "signature": "void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)",
      "purpose": "Returns the source code string from a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the shader object to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the character buffer for storing the returned source code string.</para> </listitem>",
        "length": "<listitem> <para>Returns the length of the string returned in <parameter>source</parameter> (excluding the null terminator).</para> </listitem>",
        "source": "<listitem> <para>Specifies an array of characters that is used to return the source code string.</para> </listitem>"
      }
    },
    "glGetString": {
      "signature": "const GLubyte *glGetString(GLenum name)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, or `GL_SHADING_LANGUAGE_VERSION`. Additionally, <function>glGetStringi</function> accepts the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetStringi": {
      "signature": "const GLubyte *glGetStringi(GLenum name, GLuint index)",
      "purpose": "return a string describing the current GL connection",
      "parameters": {
        "name": "<listitem> <para> Specifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, or `GL_SHADING_LANGUAGE_VERSION`. Additionally, <function>glGetStringi</function> accepts the `GL_EXTENSIONS` token. </para> </listitem>",
        "index": "<listitem> <para> For <function>glGetStringi</function>, specifies the index of the string to return. </para> </listitem>"
      }
    },
    "glGetSubroutineIndex": {
      "signature": "GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name)",
      "purpose": "retrieve the index of a subroutine uniform of a given shader stage within a program",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of the program containing shader stage. </para> </listitem>",
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for subroutine uniform index. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "name": "<listitem> <para> Specifies the name of the subroutine uniform whose index to query. </para> </listitem>"
      }
    },
    "glGetSubroutineUniformLocation": {
      "signature": "GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name)",
      "purpose": "retrieve the location of a subroutine uniform of a given shader stage within a program",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of the program containing shader stage. </para> </listitem>",
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for subroutine uniform index. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "name": "<listitem> <para> Specifies the name of the subroutine uniform whose index to query. </para> </listitem>"
      }
    },
    "glGetSynciv": {
      "signature": "void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)",
      "purpose": "query the properties of a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose properties to query. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the parameter whose value to retrieve from the sync object specified in <parameter>sync</parameter>. </para> </listitem>",
        "bufSize": "<listitem> <para> Specifies the size of the buffer whose address is given in <parameter>values</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the address of an variable to receive the number of integers placed in <parameter>values</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array to receive the values of the queried parameter. </para> </listitem>"
      }
    },
    "glGetTexImage": {
      "signature": "void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels)",
      "purpose": "return a texture image",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "format": "<listitem> <para>Specifies a pixel format for the returned data. The supported formats are `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.</para> </listitem>",
        "type": "<listitem> <para>Specifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the texture image. Should be a pointer to an array of the type specified by <parameter>type</parameter>.</para> </listitem>"
      }
    },
    "glGetnTexImage": {
      "signature": "void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)",
      "purpose": "return a texture image",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "format": "<listitem> <para>Specifies a pixel format for the returned data. The supported formats are `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.</para> </listitem>",
        "type": "<listitem> <para>Specifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the texture image. Should be a pointer to an array of the type specified by <parameter>type</parameter>.</para> </listitem>"
      }
    },
    "glGetTextureImage": {
      "signature": "void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)",
      "purpose": "return a texture image",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "format": "<listitem> <para>Specifies a pixel format for the returned data. The supported formats are `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.</para> </listitem>",
        "type": "<listitem> <para>Specifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the texture image. Should be a pointer to an array of the type specified by <parameter>type</parameter>.</para> </listitem>"
      }
    },
    "glGetTexLevelParameterfv": {
      "signature": "void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values for a specific level of    detail",
      "parameters": {
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and `GL_TEXTURE_BUFFER_OFFSET` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetTexLevelParameteriv": {
      "signature": "void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values for a specific level of    detail",
      "parameters": {
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and `GL_TEXTURE_BUFFER_OFFSET` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetTextureLevelParameterfv": {
      "signature": "void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat *params)",
      "purpose": "return texture parameter values for a specific level of    detail",
      "parameters": {
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and `GL_TEXTURE_BUFFER_OFFSET` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetTextureLevelParameteriv": {
      "signature": "void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint *params)",
      "purpose": "return texture parameter values for a specific level of    detail",
      "parameters": {
        "level": "<listitem> <para> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation>th mipmap reduction image. </para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and `GL_TEXTURE_BUFFER_OFFSET` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetTexParameterfv": {
      "signature": "void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTexParameteriv": {
      "signature": "void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTexParameterIiv": {
      "signature": "void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTexParameterIuiv": {
      "signature": "void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTextureParameterfv": {
      "signature": "void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat *params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTextureParameteriv": {
      "signature": "void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint *params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTextureParameterIiv": {
      "signature": "void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint *params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTextureParameterIuiv": {
      "signature": "void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint *params)",
      "purpose": "return texture parameter values",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.</para> </listitem>",
        "params": "<listitem> <para>Returns the texture parameters.</para> </listitem>"
      }
    },
    "glGetTextureSubImage": {
      "signature": "void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels)",
      "purpose": "retrieve a sub-region of a texture image from a texture    object",
      "parameters": {
        "texture": "<listitem> <para>Specifies the name of the source texture object. Must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific, buffer and multisample textures are not permitted.</para> </listitem>",
        "level": "<listitem> <para>Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</para> </listitem>",
        "xoffset": "<listitem> <para>Specifies a texel offset in the x direction within the texture array.</para> </listitem>",
        "yoffset": "<listitem> <para>Specifies a texel offset in the y direction within the texture array.</para> </listitem>",
        "zoffset": "<listitem> <para>Specifies a texel offset in the z direction within the texture array.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the texture subimage.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the texture subimage.</para> </listitem>",
        "depth": "<listitem> <para>Specifies the depth of the texture subimage.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT` and `GL_STENCIL_INDEX`.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer to receive the retrieved pixel data.</para> </listitem>",
        "pixels": "<listitem> <para>Returns the texture subimage. Should be a pointer to an array of the type specified by <parameter>type</parameter>.</para> </listitem>"
      }
    },
    "glGetTransformFeedbackiv": {
      "signature": "void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint *param)",
      "purpose": "query the state of a transform feedback object.",
      "parameters": {
        "xfb": "<listitem> <para>The name of an existing transform feedback object, or zero for the default transform feedback object.</para> </listitem>",
        "pname": "<listitem> <para>Property to use for the query. Must be one of the values: `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`, `GL_TRANSFORM_FEEDBACK_BUFFER_START`, `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`, `GL_TRANSFORM_FEEDBACK_PAUSED`, `GL_TRANSFORM_FEEDBACK_ACTIVE`.</para> </listitem>",
        "index": "<listitem> <para>Index of the transform feedback stream (for indexed state).</para> </listitem>",
        "param": "<listitem> <para>The address of a buffer into which will be written the requested state information.</para> </listitem>"
      }
    },
    "glGetTransformFeedbacki_v": {
      "signature": "void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint *param)",
      "purpose": "query the state of a transform feedback object.",
      "parameters": {
        "xfb": "<listitem> <para>The name of an existing transform feedback object, or zero for the default transform feedback object.</para> </listitem>",
        "pname": "<listitem> <para>Property to use for the query. Must be one of the values: `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`, `GL_TRANSFORM_FEEDBACK_BUFFER_START`, `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`, `GL_TRANSFORM_FEEDBACK_PAUSED`, `GL_TRANSFORM_FEEDBACK_ACTIVE`.</para> </listitem>",
        "index": "<listitem> <para>Index of the transform feedback stream (for indexed state).</para> </listitem>",
        "param": "<listitem> <para>The address of a buffer into which will be written the requested state information.</para> </listitem>"
      }
    },
    "glGetTransformFeedbacki64_v": {
      "signature": "void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 *param)",
      "purpose": "query the state of a transform feedback object.",
      "parameters": {
        "xfb": "<listitem> <para>The name of an existing transform feedback object, or zero for the default transform feedback object.</para> </listitem>",
        "pname": "<listitem> <para>Property to use for the query. Must be one of the values: `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`, `GL_TRANSFORM_FEEDBACK_BUFFER_START`, `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`, `GL_TRANSFORM_FEEDBACK_PAUSED`, `GL_TRANSFORM_FEEDBACK_ACTIVE`.</para> </listitem>",
        "index": "<listitem> <para>Index of the transform feedback stream (for indexed state).</para> </listitem>",
        "param": "<listitem> <para>The address of a buffer into which will be written the requested state information.</para> </listitem>"
      }
    },
    "glGetTransformFeedbackVarying": {
      "signature": "void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name)",
      "purpose": "retrieve information about varying variables selected for transform feedback",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "index": "<listitem> <para> The index of the varying variable whose information to retrieve. </para> </listitem>",
        "bufSize": "<listitem> <para> The maximum number of characters, including the null terminator, that may be written into <parameter>name</parameter>. </para> </listitem>",
        "length": "<listitem> <para> The address of a variable which will receive the number of characters written into <parameter>name</parameter>, excluding the null-terminator. If <parameter>length</parameter> is `NULL` no length is returned. </para> </listitem>",
        "size": "<listitem> <para> The address of a variable that will receive the size of the varying. </para> </listitem>",
        "type": "<listitem> <para> The address of a variable that will receive the type of the varying. </para> </listitem>",
        "name": "<listitem> <para> The address of a buffer into which will be written the name of the varying. </para> </listitem>"
      }
    },
    "glGetUniformfv": {
      "signature": "void glGetUniformfv(GLuint program, GLint location, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformiv": {
      "signature": "void glGetUniformiv(GLuint program, GLint location, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformuiv": {
      "signature": "void glGetUniformuiv(GLuint program, GLint location, GLuint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformdv": {
      "signature": "void glGetUniformdv(GLuint program, GLint location, GLdouble *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformfv": {
      "signature": "void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformiv": {
      "signature": "void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformuiv": {
      "signature": "void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetnUniformdv": {
      "signature": "void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)",
      "purpose": "Returns the value of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be queried.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>params</parameter>.</para> </listitem>",
        "params": "<listitem> <para>Returns the value of the specified uniform variable.</para> </listitem>"
      }
    },
    "glGetUniformBlockIndex": {
      "signature": "GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing the uniform block. </para> </listitem>",
        "uniformBlockName": "<listitem> <para> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </para> </listitem>"
      }
    },
    "glGetUniformIndices": {
      "signature": "void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)",
      "purpose": "retrieve the index of a named uniform block",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program containing uniforms whose indices to query. </para> </listitem>",
        "uniformCount": "<listitem> <para> Specifies the number of uniforms whose indices to query. </para> </listitem>",
        "uniformNames": "<listitem> <para> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </para> </listitem>",
        "uniformIndices": "<listitem> <para> Specifies the address of an array that will receive the indices of the uniforms. </para> </listitem>"
      }
    },
    "glGetUniformLocation": {
      "signature": "GLint glGetUniformLocation(GLuint program, const GLchar *name)",
      "purpose": "Returns the location of a uniform variable",
      "parameters": {
        "program": "<listitem> <para>Specifies the program object to be queried.</para> </listitem>",
        "name": "<listitem> <para>Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</para> </listitem>"
      }
    },
    "glGetUniformSubroutineuiv": {
      "signature": "void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *values)",
      "purpose": "retrieve the value of a subroutine uniform of a given shader stage of the current program",
      "parameters": {
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for subroutine uniform index. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "location": "<listitem> <para> Specifies the location of the subroutine uniform. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of a variable to receive the value or values of the subroutine uniform. </para> </listitem>"
      }
    },
    "glGetVertexArrayIndexed64iv": {
      "signature": "void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param)",
      "purpose": "retrieve parameters of an attribute of a vertex array    object",
      "parameters": {
        "vaobj": "<listitem> <para>Specifies the name of a vertex array object.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the vertex array object attribute. Must be a number between 0 and (`GL_MAX_VERTEX_ATTRIBS` - 1).</para> </listitem>",
        "pname": "<listitem> <para>Specifies the property to be used for the query. For <function>glGetVertexArrayIndexediv</function>, it must be one of the following values: `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`. For <function>glGetVertexArrayIndexed64v</function>, it must be equal to `GL_VERTEX_BINDING_OFFSET`.</para> </listitem>",
        "param": "<listitem> <para>Returns the requested value.</para> </listitem>"
      }
    },
    "glGetVertexArrayIndexediv": {
      "signature": "void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint *param)",
      "purpose": "retrieve parameters of an attribute of a vertex array    object",
      "parameters": {
        "vaobj": "<listitem> <para>Specifies the name of a vertex array object.</para> </listitem>",
        "index": "<listitem> <para>Specifies the index of the vertex array object attribute. Must be a number between 0 and (`GL_MAX_VERTEX_ATTRIBS` - 1).</para> </listitem>",
        "pname": "<listitem> <para>Specifies the property to be used for the query. For <function>glGetVertexArrayIndexediv</function>, it must be one of the following values: `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`. For <function>glGetVertexArrayIndexed64v</function>, it must be equal to `GL_VERTEX_BINDING_OFFSET`.</para> </listitem>",
        "param": "<listitem> <para>Returns the requested value.</para> </listitem>"
      }
    },
    "glGetVertexArrayiv": {
      "signature": "void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param)",
      "purpose": "retrieve parameters of a vertex array object",
      "parameters": {
        "vaobj": "<listitem> <para>specifies the name of the vertex array object to use for the query.</para> </listitem>",
        "pname": "<listitem> <para>Name of the property to use for the query. Must be `GL_ELEMENT_ARRAY_BUFFER_BINDING`.</para> </listitem>",
        "param": "<listitem> <para>Returns the requested value.</para> </listitem>"
      }
    },
    "glGetVertexAttribdv": {
      "signature": "void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribfv": {
      "signature": "void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribiv": {
      "signature": "void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIiv": {
      "signature": "void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribIuiv": {
      "signature": "void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribLdv": {
      "signature": "void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)",
      "purpose": "Return a generic vertex attribute parameter",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be queried.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.</para> </listitem>",
        "params": "<listitem> <para>Returns the requested data.</para> </listitem>"
      }
    },
    "glGetVertexAttribPointerv": {
      "signature": "void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)",
      "purpose": "return the address of the specified generic vertex attribute pointer",
      "parameters": {
        "index": "<listitem> <para>Specifies the generic vertex attribute parameter to be returned.</para> </listitem>",
        "pname": "<listitem> <para>Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.</para> </listitem>",
        "pointer": "<listitem> <para>Returns the pointer value.</para> </listitem>"
      }
    },
    "glHint": {
      "signature": "void glHint(GLenum target, GLenum mode)",
      "purpose": "specify implementation-specific hints",
      "parameters": {
        "target": "<listitem> <para> Specifies a symbolic constant indicating the behavior to be controlled. `GL_LINE_SMOOTH_HINT`, `GL_POLYGON_SMOOTH_HINT`, `GL_TEXTURE_COMPRESSION_HINT`, and `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` are accepted. </para> </listitem>",
        "mode": "<listitem> <para> Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted. </para> </listitem>"
      }
    },
    "glInvalidateBufferData": {
      "signature": "void glInvalidateBufferData(GLuint buffer)",
      "purpose": "invalidate the content of a buffer object's data store",
      "parameters": {
        "buffer": "<listitem> <para> The name of a buffer object whose data store to invalidate. </para> </listitem>"
      }
    },
    "glInvalidateBufferSubData": {
      "signature": "void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)",
      "purpose": "invalidate a region of a buffer object's data store",
      "parameters": {
        "buffer": "<listitem> <para> The name of a buffer object, a subrange of whose data store to invalidate. </para> </listitem>",
        "offset": "<listitem> <para> The offset within the buffer's data store of the start of the range to be invalidated. </para> </listitem>",
        "length": "<listitem> <para> The length of the range within the buffer's data store to be invalidated. </para> </listitem>"
      }
    },
    "glInvalidateFramebuffer": {
      "signature": "void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments)",
      "purpose": "invalidate the content of some or all of a framebuffer's attachments",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer object is attached for <function>glInvalidateFramebuffer</function>. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies the number of entries in the <parameter>attachments</parameter> array. </para> </listitem>",
        "attachments": "<listitem> <para> Specifies a pointer to an array identifying the attachments to be invalidated. </para> </listitem>"
      }
    },
    "glInvalidateNamedFramebufferData": {
      "signature": "void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments)",
      "purpose": "invalidate the content of some or all of a framebuffer's attachments",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glInvalidateNamedFramebufferData</function>. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies the number of entries in the <parameter>attachments</parameter> array. </para> </listitem>",
        "attachments": "<listitem> <para> Specifies a pointer to an array identifying the attachments to be invalidated. </para> </listitem>"
      }
    },
    "glInvalidateSubFramebuffer": {
      "signature": "void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height)",
      "purpose": "invalidate the content of a region of some or all of a framebuffer's attachments",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the framebuffer object is attached for <function>glInvalidateSubFramebuffer</function>. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies the number of entries in the <parameter>attachments</parameter> array. </para> </listitem>",
        "attachments": "<listitem> <para> Specifies a pointer to an array identifying the attachments to be invalidated. </para> </listitem>",
        "x": "<listitem> <para> Specifies the X offset of the region to be invalidated. </para> </listitem>",
        "y": "<listitem> <para> Specifies the Y offset of the region to be invalidated. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the region to be invalidated. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the region to be invalidated. </para> </listitem>"
      }
    },
    "glInvalidateNamedFramebufferSubData": {
      "signature": "void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "invalidate the content of a region of some or all of a framebuffer's attachments",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies the name of the framebuffer object for <function>glInvalidateNamedFramebufferSubData</function>. </para> </listitem>",
        "numAttachments": "<listitem> <para> Specifies the number of entries in the <parameter>attachments</parameter> array. </para> </listitem>",
        "attachments": "<listitem> <para> Specifies a pointer to an array identifying the attachments to be invalidated. </para> </listitem>",
        "x": "<listitem> <para> Specifies the X offset of the region to be invalidated. </para> </listitem>",
        "y": "<listitem> <para> Specifies the Y offset of the region to be invalidated. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the region to be invalidated. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the region to be invalidated. </para> </listitem>"
      }
    },
    "glInvalidateTexImage": {
      "signature": "void glInvalidateTexImage(GLuint texture, GLint level)",
      "purpose": "invalidate the entirety a texture image",
      "parameters": {
        "texture": "<listitem> <para> The name of a texture object to invalidate. </para> </listitem>",
        "level": "<listitem> <para> The level of detail of the texture object to invalidate. </para> </listitem>"
      }
    },
    "glInvalidateTexSubImage": {
      "signature": "void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)",
      "purpose": "invalidate a region of a texture image",
      "parameters": {
        "texture": "<listitem> <para> The name of a texture object a subregion of which to invalidate. </para> </listitem>",
        "level": "<listitem> <para> The level of detail of the texture object within which the region resides. </para> </listitem>",
        "xoffset": "<listitem> <para> The X offset of the region to be invalidated. </para> </listitem>",
        "yoffset": "<listitem> <para> The Y offset of the region to be invalidated. </para> </listitem>",
        "zoffset": "<listitem> <para> The Z offset of the region to be invalidated. </para> </listitem>",
        "width": "<listitem> <para> The width of the region to be invalidated. </para> </listitem>",
        "height": "<listitem> <para> The height of the region to be invalidated. </para> </listitem>",
        "depth": "<listitem> <para> The depth of the region to be invalidated. </para> </listitem>"
      }
    },
    "glIsBuffer": {
      "signature": "GLboolean glIsBuffer(GLuint buffer)",
      "purpose": "determine if a name corresponds to a buffer object",
      "parameters": {
        "buffer": "<listitem> <para> Specifies a value that may be the name of a buffer object. </para> </listitem>"
      }
    },
    "glIsEnabled": {
      "signature": "GLboolean glIsEnabled(GLenum cap)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
      }
    },
    "glIsEnabledi": {
      "signature": "GLboolean glIsEnabledi(GLenum cap, GLuint index)",
      "purpose": "test whether a capability is enabled",
      "parameters": {
        "cap": "<listitem> <para> Specifies a symbolic constant indicating a GL capability. </para> </listitem>",
        "index": "<listitem> <para> Specifies the index of the capability. </para> </listitem>"
      }
    },
    "glIsFramebuffer": {
      "signature": "GLboolean glIsFramebuffer(GLuint framebuffer)",
      "purpose": "determine if a name corresponds to a framebuffer object",
      "parameters": {
        "framebuffer": "<listitem> <para> Specifies a value that may be the name of a framebuffer object. </para> </listitem>"
      }
    },
    "glIsProgram": {
      "signature": "GLboolean glIsProgram(GLuint program)",
      "purpose": "Determines if a name corresponds to a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies a potential program object.</para> </listitem>"
      }
    },
    "glIsProgramPipeline": {
      "signature": "GLboolean glIsProgramPipeline(GLuint pipeline)",
      "purpose": "determine if a name corresponds to a program pipeline object",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies a value that may be the name of a program pipeline object. </para> </listitem>"
      }
    },
    "glIsQuery": {
      "signature": "GLboolean glIsQuery(GLuint id)",
      "purpose": "determine if a name corresponds to a query object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a query object. </para> </listitem>"
      }
    },
    "glIsRenderbuffer": {
      "signature": "GLboolean glIsRenderbuffer(GLuint renderbuffer)",
      "purpose": "determine if a name corresponds to a renderbuffer object",
      "parameters": {
        "renderbuffer": "<listitem> <para> Specifies a value that may be the name of a renderbuffer object. </para> </listitem>"
      }
    },
    "glIsSampler": {
      "signature": "GLboolean glIsSampler(GLuint id)",
      "purpose": "determine if a name corresponds to a sampler object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a sampler object. </para> </listitem>"
      }
    },
    "glIsShader": {
      "signature": "GLboolean glIsShader(GLuint shader)",
      "purpose": "Determines if a name corresponds to a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies a potential shader object.</para> </listitem>"
      }
    },
    "glIsSync": {
      "signature": "GLboolean glIsSync(GLsync sync)",
      "purpose": "determine if a name corresponds to a sync object",
      "parameters": {
        "sync": "<listitem> <para> Specifies a value that may be the name of a sync object. </para> </listitem>"
      }
    },
    "glIsTexture": {
      "signature": "GLboolean glIsTexture(GLuint texture)",
      "purpose": "determine if a name corresponds to a texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies a value that may be the name of a texture. </para> </listitem>"
      }
    },
    "glIsTransformFeedback": {
      "signature": "GLboolean glIsTransformFeedback(GLuint id)",
      "purpose": "determine if a name corresponds to a transform feedback object",
      "parameters": {
        "id": "<listitem> <para> Specifies a value that may be the name of a transform feedback object. </para> </listitem>"
      }
    },
    "glIsVertexArray": {
      "signature": "GLboolean glIsVertexArray(GLuint array)",
      "purpose": "determine if a name corresponds to a vertex array object",
      "parameters": {
        "array": "<listitem> <para> Specifies a value that may be the name of a vertex array object. </para> </listitem>"
      }
    },
    "glLineWidth": {
      "signature": "void glLineWidth(GLfloat width)",
      "purpose": "specify the width of rasterized lines",
      "parameters": {
        "width": "<listitem> <para> Specifies the width of rasterized lines. The initial value is 1. </para> </listitem>"
      }
    },
    "glLinkProgram": {
      "signature": "void glLinkProgram(GLuint program)",
      "purpose": "Links a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be linked.</para> </listitem>"
      }
    },
    "glLogicOp": {
      "signature": "void glLogicOp(GLenum opcode)",
      "purpose": "specify a logical pixel operation for rendering",
      "parameters": {
        "opcode": "<listitem> <para> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: `GL_CLEAR`, `GL_SET`, `GL_COPY`, `GL_COPY_INVERTED`, `GL_NOOP`, `GL_INVERT`, `GL_AND`, `GL_NAND`, `GL_OR`, `GL_NOR`, `GL_XOR`, `GL_EQUIV`, `GL_AND_REVERSE`, `GL_AND_INVERTED`, `GL_OR_REVERSE`, and `GL_OR_INVERTED`. The initial value is `GL_COPY`. </para> </listitem>"
      }
    },
    "glMapBuffer": {
      "signature": "void *glMapBuffer(GLenum target, GLenum access)",
      "purpose": "map all of a buffer object's data store into the client's address space",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glMapBuffer</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>"
      }
    },
    "glMapNamedBuffer": {
      "signature": "void *glMapNamedBuffer(GLuint buffer, GLenum access)",
      "purpose": "map all of a buffer object's data store into the client's address space",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glMapNamedBuffer</function>. </para> </listitem>"
      }
    },
    "glMapBufferRange": {
      "signature": "void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)",
      "purpose": "map all or part of a buffer object's data store into the client's address space",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glMapBufferRange</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the mapped range. </para> </listitem>"
      }
    },
    "glMapNamedBufferRange": {
      "signature": "void *glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)",
      "purpose": "map all or part of a buffer object's data store into the client's address space",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glMapNamedBufferRange</function>. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the starting offset within the buffer of the range to be mapped. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the range to be mapped. </para> </listitem>",
        "access": "<listitem> <para> Specifies a combination of access flags indicating the desired access to the mapped range. </para> </listitem>"
      }
    },
    "glMemoryBarrier": {
      "signature": "void glMemoryBarrier(GLbitfield barriers)",
      "purpose": "defines a barrier ordering memory transactions",
      "parameters": {
        "barriers": "<listitem> <para> Specifies the barriers to insert. </para> <para> For <function>glMemoryBarrier</function>, must be a bitwise combination of any of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. </para> <para> For <function>glMemoryBarrier</function>, must be a bitwise combination of any of `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_SHADER_STORAGE_BARRIER_BIT`. `GL_TEXTURE_FETCH_BARRIER_BIT`, or `GL_UNIFORM_BARRIER_BIT`. </para> <para> If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers for the corresponding command will be inserted. </para> </listitem>"
      }
    },
    "glMemoryBarrierByRegion": {
      "signature": "void glMemoryBarrierByRegion(GLbitfield barriers)",
      "purpose": "defines a barrier ordering memory transactions",
      "parameters": {
        "barriers": "<listitem> <para> Specifies the barriers to insert. </para> <para> For <function>glMemoryBarrier</function>, must be a bitwise combination of any of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`. </para> <para> For <function>glMemoryBarrier</function>, must be a bitwise combination of any of `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_SHADER_STORAGE_BARRIER_BIT`. `GL_TEXTURE_FETCH_BARRIER_BIT`, or `GL_UNIFORM_BARRIER_BIT`. </para> <para> If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers for the corresponding command will be inserted. </para> </listitem>"
      }
    },
    "glMinSampleShading": {
      "signature": "void glMinSampleShading(GLfloat value)",
      "purpose": "specifies minimum rate at which sample shading takes place",
      "parameters": {
        "value": "<listitem> <para> Specifies the rate at which samples are shaded within each covered pixel. </para> </listitem>"
      }
    },
    "glMultiDrawArrays": {
      "signature": "void glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount)",
      "purpose": "render multiple sets of primitives from array data",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "first": "<listitem> <para> Points to an array of starting indices in the enabled arrays. </para> </listitem>",
        "count": "<listitem> <para> Points to an array of the number of indices to be rendered. </para> </listitem>",
        "drawcount": "<listitem> <para> Specifies the size of the first and count </para> </listitem>"
      }
    },
    "glMultiDrawArraysIndirect": {
      "signature": "void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride)",
      "purpose": "render multiple sets of primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of an array of structures containing the draw parameters. </para> </listitem>",
        "drawcount": "<listitem> <para> Specifies the number of elements in the array of draw parameter structures. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the distance in basic machine units between elements of the draw parameter array. </para> </listitem>"
      }
    },
    "glMultiDrawElements": {
      "signature": "void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount)",
      "purpose": "render multiple sets of primitives by specifying indices of array data elements",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Points to an array of the elements counts. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "drawcount": "<listitem> <para> Specifies the size of the <parameter>count</parameter> and <parameter>indices</parameter> arrays. </para> </listitem>"
      }
    },
    "glMultiDrawElementsBaseVertex": {
      "signature": "void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const void * const *indices, GLsizei drawcount, const GLint *basevertex)",
      "purpose": "render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted. </para> </listitem>",
        "count": "<listitem> <para> Points to an array of the elements counts. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of the values in <parameter>indices</parameter>. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`. </para> </listitem>",
        "indices": "<listitem> <para> Specifies a pointer to the location where the indices are stored. </para> </listitem>",
        "drawcount": "<listitem> <para> Specifies the size of the <parameter>count</parameter>, <parameter>indices</parameter> and <parameter>basevertex</parameter> arrays. </para> </listitem>",
        "basevertex": "<listitem> <para> Specifies a pointer to the location where the base vertices are stored. </para> </listitem>"
      }
    },
    "glMultiDrawElementsIndirect": {
      "signature": "void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride)",
      "purpose": "render indexed primitives from array data, taking parameters from memory",
      "parameters": {
        "mode": "<listitem> <para> Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted. </para> </listitem>",
        "type": "<listitem> <para> Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding. </para> </listitem>",
        "indirect": "<listitem> <para> Specifies the address of a structure containing an array of draw parameters. </para> </listitem>",
        "drawcount": "<listitem> <para> Specifies the number of elements in the array addressed by <parameter>indirect</parameter>. </para> </listitem>",
        "stride": "<listitem> <para> Specifies the distance in basic machine units between elements of the draw parameter array. </para> </listitem>"
      }
    },
    "glObjectLabel": {
      "signature": "void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label)",
      "purpose": "label a named object identified within a namespace",
      "parameters": {
        "identifier": "<listitem> <para> The namespace from which the name of the object is allocated. </para> </listitem>",
        "name": "<listitem> <para> The name of the object to label. </para> </listitem>",
        "length": "<listitem> <para> The length of the label to be used for the object. </para> </listitem>",
        "label": "<listitem> <para> The address of a string containing the label to assign to the object. </para> </listitem>"
      }
    },
    "glObjectPtrLabel": {
      "signature": "void glObjectPtrLabel(void * ptr, GLsizei length, const char * label)",
      "purpose": "label a sync object identified by a pointer",
      "parameters": {
        "ptr": "<listitem> <para> A pointer identifying a sync object. </para> </listitem>",
        "length": "<listitem> <para> The length of the label to be used for the object. </para> </listitem>",
        "label": "<listitem> <para> The address of a string containing the label to assign to the object. </para> </listitem>"
      }
    },
    "glPatchParameteri": {
      "signature": "void glPatchParameteri(GLenum pname, GLint value)",
      "purpose": "specifies the parameters for patch primitives",
      "parameters": {
        "pname": "<listitem> <para> Specifies the name of the parameter to set. The symbolc constants `GL_PATCH_VERTICES`, `GL_PATCH_DEFAULT_OUTER_LEVEL`, and `GL_PATCH_DEFAULT_INNER_LEVEL` are accepted. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value for the parameter given by <parameter>pname</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array containing the new values for the parameter given by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glPatchParameterfv": {
      "signature": "void glPatchParameterfv(GLenum pname, const GLfloat *values)",
      "purpose": "specifies the parameters for patch primitives",
      "parameters": {
        "pname": "<listitem> <para> Specifies the name of the parameter to set. The symbolc constants `GL_PATCH_VERTICES`, `GL_PATCH_DEFAULT_OUTER_LEVEL`, and `GL_PATCH_DEFAULT_INNER_LEVEL` are accepted. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value for the parameter given by <parameter>pname</parameter>. </para> </listitem>",
        "values": "<listitem> <para> Specifies the address of an array containing the new values for the parameter given by <parameter>pname</parameter>. </para> </listitem>"
      }
    },
    "glPauseTransformFeedback": {
      "signature": "void glPauseTransformFeedback(void)",
      "purpose": "pause transform feedback operations",
      "parameters": {}
    },
    "glPixelStoref": {
      "signature": "void glPixelStoref(GLenum pname, GLfloat param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`, `GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPixelStorei": {
      "signature": "void glPixelStorei(GLenum pname, GLint param)",
      "purpose": "set pixel storage modes",
      "parameters": {
        "pname": "<listitem> <para> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`, `GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data <emphasis>from</emphasis> memory: `GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`. </para> </listitem>",
        "param": "<listitem> <para> Specifies the value that <parameter>pname</parameter> is set to. </para> </listitem>"
      }
    },
    "glPointParameterf": {
      "signature": "void glPointParameterf(GLenum pname, GLfloat param)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> For <function>glPointParameterf</function> and <function>glPointParameteri</function>, specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>",
        "params": "<listitem> <para> For <function>glPointParameterfv</function> and <function>glPointParameteriv</function>, specifies a pointer to an array where the value or values to be assigned to <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glPointParameteri": {
      "signature": "void glPointParameteri(GLenum pname, GLint param)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> For <function>glPointParameterf</function> and <function>glPointParameteri</function>, specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>",
        "params": "<listitem> <para> For <function>glPointParameterfv</function> and <function>glPointParameteriv</function>, specifies a pointer to an array where the value or values to be assigned to <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glPointParameterfv": {
      "signature": "void glPointParameterfv(GLenum pname, const GLfloat * params)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> For <function>glPointParameterf</function> and <function>glPointParameteri</function>, specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>",
        "params": "<listitem> <para> For <function>glPointParameterfv</function> and <function>glPointParameteriv</function>, specifies a pointer to an array where the value or values to be assigned to <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glPointParameteriv": {
      "signature": "void glPointParameteriv(GLenum pname, const GLint * params)",
      "purpose": "specify point parameters",
      "parameters": {
        "pname": "<listitem> <para> Specifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted. </para> </listitem>",
        "param": "<listitem> <para> For <function>glPointParameterf</function> and <function>glPointParameteri</function>, specifies the value that <parameter>pname</parameter> will be set to. </para> </listitem>",
        "params": "<listitem> <para> For <function>glPointParameterfv</function> and <function>glPointParameteriv</function>, specifies a pointer to an array where the value or values to be assigned to <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glPointSize": {
      "signature": "void glPointSize(GLfloat size)",
      "purpose": "specify the diameter of rasterized points",
      "parameters": {
        "size": "<listitem> <para> Specifies the diameter of rasterized points. The initial value is 1. </para> </listitem>"
      }
    },
    "glPolygonMode": {
      "signature": "void glPolygonMode(GLenum face, GLenum mode)",
      "purpose": "select a polygon rasterization mode",
      "parameters": {
        "face": "<listitem> <para> Specifies the polygons that <parameter>mode</parameter> applies to. Must be `GL_FRONT_AND_BACK` for front- and back-facing polygons. </para> </listitem>",
        "mode": "<listitem> <para> Specifies how polygons will be rasterized. Accepted values are `GL_POINT`, `GL_LINE`, and `GL_FILL`. The initial value is `GL_FILL` for both front- and back-facing polygons. </para> </listitem>"
      }
    },
    "glPolygonOffset": {
      "signature": "void glPolygonOffset(GLfloat factor, GLfloat units)",
      "purpose": "set the scale and units used to calculate depth values",
      "parameters": {
        "factor": "<listitem> <para> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </para> </listitem>",
        "units": "<listitem> <para> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </para> </listitem>"
      }
    },
    "glPopDebugGroup": {
      "signature": "void glPopDebugGroup(void)",
      "purpose": "pop the active debug group",
      "parameters": {}
    },
    "glPrimitiveRestartIndex": {
      "signature": "void glPrimitiveRestartIndex(GLuint index)",
      "purpose": "specify the primitive restart index",
      "parameters": {
        "index": "<listitem> <para> Specifies the value to be interpreted as the primitive restart index. </para> </listitem>"
      }
    },
    "glProgramBinary": {
      "signature": "void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load a program object with a program binary",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object into which to load a program binary. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the binary data in binary. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address an array containing the binary to be loaded into <parameter>program</parameter>. </para> </listitem>",
        "length": "<listitem> <para> Specifies the number of bytes contained in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glProgramParameteri": {
      "signature": "void glProgramParameteri(GLuint program, GLenum pname, GLint value)",
      "purpose": "specify a parameter for a program object",
      "parameters": {
        "program": "<listitem> <para> Specifies the name of a program object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the name of the parameter to modify. </para> </listitem>",
        "value": "<listitem> <para> Specifies the new value of the parameter specified by <parameter>pname</parameter> for <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glProgramUniform1f": {
      "signature": "void glProgramUniform1f(GLuint program, GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2f": {
      "signature": "void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3f": {
      "signature": "void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4f": {
      "signature": "void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1i": {
      "signature": "void glProgramUniform1i(GLuint program, GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2i": {
      "signature": "void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3i": {
      "signature": "void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4i": {
      "signature": "void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1ui": {
      "signature": "void glProgramUniform1ui(GLuint program, GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2ui": {
      "signature": "void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3ui": {
      "signature": "void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4ui": {
      "signature": "void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1fv": {
      "signature": "void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2fv": {
      "signature": "void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3fv": {
      "signature": "void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4fv": {
      "signature": "void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1iv": {
      "signature": "void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2iv": {
      "signature": "void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3iv": {
      "signature": "void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4iv": {
      "signature": "void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform1uiv": {
      "signature": "void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform2uiv": {
      "signature": "void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform3uiv": {
      "signature": "void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniform4uiv": {
      "signature": "void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2fv": {
      "signature": "void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3fv": {
      "signature": "void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4fv": {
      "signature": "void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2x3fv": {
      "signature": "void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3x2fv": {
      "signature": "void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix2x4fv": {
      "signature": "void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4x2fv": {
      "signature": "void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix3x4fv": {
      "signature": "void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProgramUniformMatrix4x3fv": {
      "signature": "void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for a specified program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program containing the uniform variable to be modified.</para> </listitem>",
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector commands (<function>glProgramUniform*v</function>), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix commands (<function>glProgramUniformMatrix*</function>), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glProvokingVertex": {
      "signature": "void glProvokingVertex(GLenum provokeMode)",
      "purpose": "specifiy the vertex to be used as the source of data for flat shaded varyings",
      "parameters": {
        "provokeMode": "<listitem> <para> Specifies the vertex to be used as the source of data for flat shaded varyings. </para> </listitem>"
      }
    },
    "glPushDebugGroup": {
      "signature": "void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message)",
      "purpose": "push a named debug group into the command stream",
      "parameters": {
        "source": "<listitem> <para> The source of the debug message. </para> </listitem>",
        "id": "<listitem> <para> The identifier of the message. </para> </listitem>",
        "length": "<listitem> <para> The length of the message to be sent to the debug output stream. </para> </listitem>",
        "message": "<listitem> <para> The a string containing the message to be sent to the debug output stream. </para> </listitem>"
      }
    },
    "glQueryCounter": {
      "signature": "void glQueryCounter(GLuint id, GLenum target)",
      "purpose": "record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.",
      "parameters": {
        "id": "<listitem> <para> Specify the name of a query object into which to record the GL time. </para> </listitem>",
        "target": "<listitem> <para> Specify the counter to query. <parameter>target</parameter> must be `GL_TIMESTAMP`. </para> </listitem>"
      }
    },
    "glReadBuffer": {
      "signature": "void glReadBuffer(GLenum mode)",
      "purpose": "select a color buffer source for pixels",
      "parameters": {
        "mode": "<listitem> <para>Specifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and the constants `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>.</para> </listitem>"
      }
    },
    "glNamedFramebufferReadBuffer": {
      "signature": "void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode)",
      "purpose": "select a color buffer source for pixels",
      "parameters": {
        "framebuffer": "<listitem> <para>Specifies the name of the framebuffer object for <function>glNamedFramebufferReadBuffer</function> function.</para> </listitem>",
        "mode": "<listitem> <para>Specifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and the constants `GL_COLOR_ATTACHMENT`<emphasis>i</emphasis>.</para> </listitem>"
      }
    },
    "glReadPixels": {
      "signature": "void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para>Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</para> </listitem>",
        "width": "<listitem> <para>Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the pixel data. The following symbolic values are accepted: `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.</para> </listitem>",
        "data": "<listitem> <para>Returns the pixel data.</para> </listitem>"
      }
    },
    "glReadnPixels": {
      "signature": "void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data)",
      "purpose": "read a block of pixels from the frame buffer",
      "parameters": {
        "x": "<listitem> <para>Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</para> </listitem>",
        "width": "<listitem> <para>Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and <parameter>height</parameter> of one correspond to a single pixel.</para> </listitem>",
        "format": "<listitem> <para>Specifies the format of the pixel data. The following symbolic values are accepted: `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.</para> </listitem>",
        "bufSize": "<listitem> <para>Specifies the size of the buffer <parameter>data</parameter> for <function>glReadnPixels</function> function.</para> </listitem>",
        "data": "<listitem> <para>Returns the pixel data.</para> </listitem>"
      }
    },
    "glReleaseShaderCompiler": {
      "signature": "void glReleaseShaderCompiler(void)",
      "purpose": "release resources consumed by the implementation's shader compiler",
      "parameters": {}
    },
    "glRenderbufferStorage": {
      "signature": "void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format and dimensions of a    renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para>Specifies a binding target of the allocation for <function>glRenderbufferStorage</function> function. Must be `GL_RENDERBUFFER`.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the internal format to use for the renderbuffer object's image.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the renderbuffer, in pixels.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the renderbuffer, in pixels.</para> </listitem>"
      }
    },
    "glNamedRenderbufferStorage": {
      "signature": "void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format and dimensions of a    renderbuffer object's image",
      "parameters": {
        "renderbuffer": "<listitem> <para>Specifies the name of the renderbuffer object for <function>glNamedRenderbufferStorage</function> function.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the internal format to use for the renderbuffer object's image.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the renderbuffer, in pixels.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the renderbuffer, in pixels.</para> </listitem>"
      }
    },
    "glRenderbufferStorageMultisample": {
      "signature": "void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format, dimensions and sample count of    a renderbuffer object's image",
      "parameters": {
        "target": "<listitem> <para>Specifies a binding target of the allocation for <function>glRenderbufferStorageMultisample</function> function. Must be `GL_RENDERBUFFER`.</para> </listitem>",
        "samples": "<listitem> <para>Specifies the number of samples to be used for the renderbuffer object's storage.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the internal format to use for the renderbuffer object's image.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the renderbuffer, in pixels.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the renderbuffer, in pixels.</para> </listitem>"
      }
    },
    "glNamedRenderbufferStorageMultisample": {
      "signature": "void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "establish data storage, format, dimensions and sample count of    a renderbuffer object's image",
      "parameters": {
        "renderbuffer": "<listitem> <para>Specifies the name of the renderbuffer object for <function>glNamedRenderbufferStorageMultisample</function> function.</para> </listitem>",
        "samples": "<listitem> <para>Specifies the number of samples to be used for the renderbuffer object's storage.</para> </listitem>",
        "internalformat": "<listitem> <para>Specifies the internal format to use for the renderbuffer object's image.</para> </listitem>",
        "width": "<listitem> <para>Specifies the width of the renderbuffer, in pixels.</para> </listitem>",
        "height": "<listitem> <para>Specifies the height of the renderbuffer, in pixels.</para> </listitem>"
      }
    },
    "glResumeTransformFeedback": {
      "signature": "void glResumeTransformFeedback(void)",
      "purpose": "resume transform feedback operations",
      "parameters": {}
    },
    "glSampleCoverage": {
      "signature": "void glSampleCoverage(GLfloat value, GLboolean invert)",
      "purpose": "specify multisample coverage parameters",
      "parameters": {
        "value": "<listitem> <para> Specify a single floating-point sample coverage value. The value is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mn>1</mn> </mfenced> </math></inlineequation>. The initial value is 1.0. </para> </listitem>",
        "invert": "<listitem> <para> Specify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`. </para> </listitem>"
      }
    },
    "glSampleMaski": {
      "signature": "void glSampleMaski(GLuint maskNumber, GLbitfield mask)",
      "purpose": "set the value of a sub-word of the sample mask",
      "parameters": {
        "maskNumber": "<listitem> <para> Specifies which 32-bit sub-word of the sample mask to update. </para> </listitem>",
        "mask": "<listitem> <para> Specifies the new value of the mask sub-word. </para> </listitem>"
      }
    },
    "glSamplerParameterf": {
      "signature": "void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteri": {
      "signature": "void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterfv": {
      "signature": "void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameteriv": {
      "signature": "void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterIiv": {
      "signature": "void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glSamplerParameterIuiv": {
      "signature": "void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)",
      "purpose": "set sampler parameters",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler object whose parameter to modify. </para> </listitem>",
        "pname": "<listitem> <para> Specifies the symbolic name of a sampler parameter. <parameter>pname</parameter> can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`. </para> </listitem>",
        "param": "<listitem> <para> For the scalar commands, specifies the value of <parameter>pname</parameter>. </para> </listitem>",
        "params": "<listitem> <para> For the vector commands (<function>glSamplerParameter*v</function>), specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored. </para> </listitem>"
      }
    },
    "glScissor": {
      "signature": "void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the scissor box. Initially (0, 0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the scissor box. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glScissorArrayv": {
      "signature": "void glScissorArrayv(GLuint first, GLsizei count, const GLint *v)",
      "purpose": "define the scissor box for multiple viewports",
      "parameters": {
        "first": "<listitem> <para> Specifies the index of the first viewport whose scissor box to modify. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of scissor boxes to modify. </para> </listitem>",
        "v": "<listitem> <para> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </para> </listitem>"
      }
    },
    "glScissorIndexed": {
      "signature": "void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)",
      "purpose": "define the scissor box for a specific viewport",
      "parameters": {
        "index": "<listitem> <para> Specifies the index of the viewport whose scissor box to modify. </para> </listitem>",
        "left": "<listitem> <para> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify ths dimensions of the scissor box, in pixels. </para> </listitem>",
        "v": "<listitem> <para> For <function>glScissorIndexedv</function>, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </para> </listitem>"
      }
    },
    "glScissorIndexedv": {
      "signature": "void glScissorIndexedv(GLuint index, const GLint *v)",
      "purpose": "define the scissor box for a specific viewport",
      "parameters": {
        "index": "<listitem> <para> Specifies the index of the viewport whose scissor box to modify. </para> </listitem>",
        "left": "<listitem> <para> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </para> </listitem>",
        "width": "<listitem> <para> Specify ths dimensions of the scissor box, in pixels. </para> </listitem>",
        "v": "<listitem> <para> For <function>glScissorIndexedv</function>, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </para> </listitem>"
      }
    },
    "glShaderBinary": {
      "signature": "void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)",
      "purpose": "load pre-compiled shader binaries",
      "parameters": {
        "count": "<listitem> <para> Specifies the number of shader object handles contained in <parameter>shaders</parameter>. </para> </listitem>",
        "shaders": "<listitem> <para> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </para> </listitem>",
        "binaryFormat": "<listitem> <para> Specifies the format of the shader binaries contained in <parameter>binary</parameter>. </para> </listitem>",
        "binary": "<listitem> <para> Specifies the address of an array of bytes containing pre-compiled binary shader code. </para> </listitem>",
        "length": "<listitem> <para> Specifies the length of the array whose address is given in <parameter>binary</parameter>. </para> </listitem>"
      }
    },
    "glShaderSource": {
      "signature": "void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)",
      "purpose": "Replaces the source code in a shader object",
      "parameters": {
        "shader": "<listitem> <para>Specifies the handle of the shader object whose source code is to be replaced.</para> </listitem>",
        "count": "<listitem> <para>Specifies the number of elements in the <parameter>string</parameter> and <parameter>length</parameter> arrays.</para> </listitem>",
        "string": "<listitem> <para>Specifies an array of pointers to strings containing the source code to be loaded into the shader.</para> </listitem>",
        "length": "<listitem> <para>Specifies an array of string lengths.</para> </listitem>"
      }
    },
    "glShaderStorageBlockBinding": {
      "signature": "void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)",
      "purpose": "change an active shader storage block binding",
      "parameters": {
        "program": "<listitem> <para> The name of the program containing the block whose binding to change. </para> </listitem>",
        "storageBlockIndex": "<listitem> <para> The index storage block within the program. </para> </listitem>",
        "storageBlockBinding": "<listitem> <para> The index storage block binding to associate with the specified storage block. </para> </listitem>"
      }
    },
    "glStencilFunc": {
      "signature": "void glStencilFunc(GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and back function and reference value for stencil testing",
      "parameters": {
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilFuncSeparate": {
      "signature": "void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)",
      "purpose": "set front and/or back function and reference value for stencil testing",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "func": "<listitem> <para> Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`. </para> </listitem>",
        "ref": "<listitem> <para> Specifies the reference value for the stencil test. <parameter>ref</parameter> is clamped to the range <inlineequation><math overflow=\"scroll\"> <mfenced open=\"[\" close=\"]\"> <mn>0</mn> <mrow> <msup><mn>2</mn> <mi mathvariant=\"italic\">n</mi> </msup> <mo>-</mo> <mn>1</mn> </mrow> </mfenced> </math></inlineequation>, where <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the number of bitplanes in the stencil buffer. The initial value is 0. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </para> </listitem>"
      }
    },
    "glStencilMask": {
      "signature": "void glStencilMask(GLuint mask)",
      "purpose": "control the front and back writing of individual bits in the stencil planes",
      "parameters": {
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilMaskSeparate": {
      "signature": "void glStencilMaskSeparate(GLenum face, GLuint mask)",
      "purpose": "control the front and/or back writing of individual bits in the stencil planes",
      "parameters": {
        "face": "<listitem> <para> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "mask": "<listitem> <para> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </para> </listitem>"
      }
    },
    "glStencilOp": {
      "signature": "void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and back stencil test actions",
      "parameters": {
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glStencilOpSeparate": {
      "signature": "void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)",
      "purpose": "set front and/or back stencil test actions",
      "parameters": {
        "face": "<listitem> <para> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`. </para> </listitem>",
        "sfail": "<listitem> <para> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`. </para> </listitem>",
        "dpfail": "<listitem> <para> Specifies the stencil action when the stencil test passes, but the depth test fails. <parameter>dpfail</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>",
        "dppass": "<listitem> <para> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. <parameter>dppass</parameter> accepts the same symbolic constants as <parameter>sfail</parameter>. The initial value is `GL_KEEP`. </para> </listitem>"
      }
    },
    "glTexBuffer": {
      "signature": "void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)",
      "purpose": "attach a buffer object's data store to a buffer texture object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound for <function>glTexBuffer</function>. Must be `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the data in the store belonging to <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </para> </listitem>"
      }
    },
    "glTextureBuffer": {
      "signature": "void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer)",
      "purpose": "attach a buffer object's data store to a buffer texture object",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureBuffer</function>. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the data in the store belonging to <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </para> </listitem>"
      }
    },
    "glTexBufferRange": {
      "signature": "void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)",
      "purpose": "attach a range of a buffer object's data store to a buffer texture object",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexBufferRange</function>. Must be `GL_TEXTURE_BUFFER`. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the data in the store belonging to <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset of the start of the range of the buffer's data store to attach. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size of the range of the buffer's data store to attach. </para> </listitem>"
      }
    },
    "glTextureBufferRange": {
      "signature": "void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size)",
      "purpose": "attach a range of a buffer object's data store to a buffer texture object",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureBufferRange</function>. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format of the data in the store belonging to <parameter>buffer</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset of the start of the range of the buffer's data store to attach. </para> </listitem>",
        "size": "<listitem> <para> Specifies the size of the range of the buffer's data store to attach. </para> </listitem>"
      }
    },
    "glTexImage1D": {
      "signature": "void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a one-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage2D": {
      "signature": "void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a two-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. If <parameter>target</parameter> is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`, <parameter>level</parameter> must be 0. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the `GL_TEXTURE_1D_ARRAY` and `GL_PROXY_TEXTURE_1D_ARRAY` targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage2DMultisample": {
      "signature": "void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)",
      "purpose": "establish the data storage, format, dimensions, and number of samples of a multisample texture's image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the operation. <parameter>target</parameter> must be `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`. </para> </listitem>",
        "samples": "<listitem> <para> The number of samples in the multisample texture's image. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format to be used to store the multisample texture's image. <parameter>internalformat</parameter> must specify a color-renderable, depth-renderable, or stencil-renderable format. </para> </listitem>",
        "width": "<listitem> <para> The width of the multisample texture's image, in texels. </para> </listitem>",
        "height": "<listitem> <para> The height of the multisample texture's image, in texels. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexImage3D": {
      "signature": "void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data)",
      "purpose": "specify a three-dimensional texture image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target texture. Must be one of `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <inlineequation><math overflow=\"scroll\"><mi mathvariant=\"italic\">n</mi></math></inlineequation> is the <inlineequation><math overflow=\"scroll\"> <msup><mi mathvariant=\"italic\">n</mi> <mi mathvariant=\"italic\">th</mi> </msup> </math></inlineequation> mipmap reduction image. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </para> </listitem>",
        "border": "<listitem> <para> This value must be 0. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "data": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexImage3DMultisample": {
      "signature": "void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)",
      "purpose": "establish the data storage, format, dimensions, and number of samples of a multisample texture's image",
      "parameters": {
        "target": "<listitem> <para> Specifies the target of the operation. <parameter>target</parameter> must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "samples": "<listitem> <para> The number of samples in the multisample texture's image. </para> </listitem>",
        "internalformat": "<listitem> <para> The internal format to be used to store the multisample texture's image. <parameter>internalformat</parameter> must specify a color-renderable, depth-renderable, or stencil-renderable format. </para> </listitem>",
        "width": "<listitem> <para> The width of the multisample texture's image, in texels. </para> </listitem>",
        "height": "<listitem> <para> The height of the multisample texture's image, in texels. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexParameterf": {
      "signature": "void glTexParameterf(GLenum target, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTexParameteri": {
      "signature": "void glTexParameteri(GLenum target, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTextureParameterf": {
      "signature": "void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTextureParameteri": {
      "signature": "void glTextureParameteri(GLuint texture, GLenum pname, GLint param)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTexParameterfv": {
      "signature": "void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTexParameteriv": {
      "signature": "void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTexParameterIiv": {
      "signature": "void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTexParameterIuiv": {
      "signature": "void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTextureParameterfv": {
      "signature": "void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat *params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTextureParameteriv": {
      "signature": "void glTextureParameteriv(GLuint texture, GLenum pname, const GLint *params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTextureParameterIiv": {
      "signature": "void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint *params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTextureParameterIuiv": {
      "signature": "void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint *params)",
      "purpose": "set texture parameters",
      "parameters": {
        "pname": "<listitem> <para>Specifies the symbolic name of a single-valued texture parameter. <parameter>pname</parameter> can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.</para> <para>For the vector commands (<function>glTexParameter*v</function>), <parameter>pname</parameter> can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.</para> </listitem>",
        "param": "<listitem> <para>For the scalar commands, specifies the value of <parameter>pname</parameter>.</para> </listitem>",
        "params": "<listitem> <para>For the vector commands, specifies a pointer to an array where the value or values of <parameter>pname</parameter> are stored.</para> </listitem>"
      }
    },
    "glTexStorage1D": {
      "signature": "void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)",
      "purpose": "simultaneously specify storage for all levels of a one-dimensional texture",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexStorage1D</function>. Must be one of `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>"
      }
    },
    "glTextureStorage1D": {
      "signature": "void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width)",
      "purpose": "simultaneously specify storage for all levels of a one-dimensional texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureStorage1D</function>. The effective target of <parameter>texture</parameter> must be one of the valid non-proxy <parameter>target</parameter> values above. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage2D": {
      "signature": "void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexStorage2D</function>. Must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>"
      }
    },
    "glTextureStorage2D": {
      "signature": "void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)",
      "purpose": "simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureStorage2D</function>. The effective target of <parameter>texture</parameter> must be one of the valid non-proxy <parameter>target</parameter> values above. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage2DMultisample": {
      "signature": "void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample texture",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexStorage2DMultisample</function>. Must be one of `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTextureStorage2DMultisample": {
      "signature": "void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureStorage2DMultisample</function>. The effective target of <parameter>texture</parameter> must be one of the valid non-proxy <parameter>target</parameter> values above. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexStorage3D": {
      "signature": "void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)",
      "purpose": "simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexStorage3D</function>. Must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in texels. </para> </listitem>"
      }
    },
    "glTextureStorage3D": {
      "signature": "void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)",
      "purpose": "simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureStorage3D</function>. The effective target of <parameter>texture</parameter> must be one of the valid non-proxy <parameter>target</parameter> values above. </para> </listitem>",
        "levels": "<listitem> <para> Specify the number of texture levels. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in texels. </para> </listitem>"
      }
    },
    "glTexStorage3DMultisample": {
      "signature": "void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample array texture",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture object is bound for <function>glTexStorage3DMultisample</function>. Must be one of `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in layers. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTextureStorage3DMultisample": {
      "signature": "void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)",
      "purpose": "specify storage for a two-dimensional multisample array texture",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureStorage3DMultisample</function>. The effective target of <parameter>texture</parameter> must be one of the valid non-proxy <parameter>target</parameter> values above. </para> </listitem>",
        "samples": "<listitem> <para> Specify the number of samples in the texture. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the sized internal format to be used to store texture image data. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture, in texels. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture, in texels. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture, in layers. </para> </listitem>",
        "fixedsamplelocations": "<listitem> <para> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </para> </listitem>"
      }
    },
    "glTexSubImage1D": {
      "signature": "void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)",
      "purpose": "specify a one-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound for <function>glTexSubImage1D</function>. Must be `GL_TEXTURE_1D`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "pixels": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTextureSubImage1D": {
      "signature": "void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels)",
      "purpose": "specify a one-dimensional texture subimage",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureSubImage1D</function>. The effective target of <parameter>texture</parameter> must be one of the valid <parameter>target</parameter> values above. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "pixels": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage2D": {
      "signature": "void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound for <function>glTexSubImage2D</function>. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "pixels": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTextureSubImage2D": {
      "signature": "void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels)",
      "purpose": "specify a two-dimensional texture subimage",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureSubImage2D</function>. The effective target of <parameter>texture</parameter> must be one of the valid <parameter>target</parameter> values above. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "pixels": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTexSubImage3D": {
      "signature": "void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)",
      "purpose": "specify a three-dimensional texture subimage",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the texture is bound for <function>glTexSubImage3D</function>. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "pixels": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTextureSubImage3D": {
      "signature": "void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels)",
      "purpose": "specify a three-dimensional texture subimage",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object name for <function>glTextureSubImage3D</function>. The effective target of <parameter>texture</parameter> must be one of the valid <parameter>target</parameter> values above. </para> </listitem>",
        "level": "<listitem> <para> Specifies the level-of-detail number. Level 0 is the base image level. Level <emphasis>n</emphasis> is the <emphasis>n</emphasis>th mipmap reduction image. </para> </listitem>",
        "xoffset": "<listitem> <para> Specifies a texel offset in the x direction within the texture array. </para> </listitem>",
        "yoffset": "<listitem> <para> Specifies a texel offset in the y direction within the texture array. </para> </listitem>",
        "zoffset": "<listitem> <para> Specifies a texel offset in the z direction within the texture array. </para> </listitem>",
        "width": "<listitem> <para> Specifies the width of the texture subimage. </para> </listitem>",
        "height": "<listitem> <para> Specifies the height of the texture subimage. </para> </listitem>",
        "depth": "<listitem> <para> Specifies the depth of the texture subimage. </para> </listitem>",
        "format": "<listitem> <para> Specifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`. </para> </listitem>",
        "type": "<listitem> <para> Specifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`. </para> </listitem>",
        "pixels": "<listitem> <para> Specifies a pointer to the image data in memory. </para> </listitem>"
      }
    },
    "glTextureBarrier": {
      "signature": "void glTextureBarrier(void)",
      "purpose": "controls the ordering of reads and writes to rendered fragments across drawing commands",
      "parameters": {}
    },
    "glTextureView": {
      "signature": "void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)",
      "purpose": "initialize a texture as a data alias of another texture's data store",
      "parameters": {
        "texture": "<listitem> <para> Specifies the texture object to be initialized as a view. </para> </listitem>",
        "target": "<listitem> <para> Specifies the target to be used for the newly initialized texture. </para> </listitem>",
        "origtexture": "<listitem> <para> Specifies the name of a texture object of which to make a view. </para> </listitem>",
        "internalformat": "<listitem> <para> Specifies the internal format for the newly created view. </para> </listitem>",
        "minlevel": "<listitem> <para> Specifies lowest level of detail of the view. </para> </listitem>",
        "numlevels": "<listitem> <para> Specifies the number of levels of detail to include in the view. </para> </listitem>",
        "minlayer": "<listitem> <para> Specifies the index of the first layer to include in the view. </para> </listitem>",
        "numlayers": "<listitem> <para> Specifies the number of layers to include in the view. </para> </listitem>"
      }
    },
    "glTransformFeedbackBufferBase": {
      "signature": "void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer)",
      "purpose": "bind a buffer object to a transform feedback buffer object",
      "parameters": {
        "xfb": "<listitem> <para> Name of the transform feedback buffer object. </para> </listitem>",
        "index": "<listitem> <para> Index of the binding point within <parameter>xfb</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Name of the buffer object to bind to the specified binding point. </para> </listitem>"
      }
    },
    "glTransformFeedbackBufferRange": {
      "signature": "void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size)",
      "purpose": "bind a range within a buffer object to a transform feedback buffer object",
      "parameters": {
        "xfb": "<listitem> <para> Name of the transform feedback buffer object. </para> </listitem>",
        "index": "<listitem> <para> Index of the binding point within <parameter>xfb</parameter>. </para> </listitem>",
        "buffer": "<listitem> <para> Name of the buffer object to bind to the specified binding point. </para> </listitem>",
        "offset": "<listitem> <para> The starting offset in basic machine units into the buffer object. </para> </listitem>",
        "size": "<listitem> <para> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </para> </listitem>"
      }
    },
    "glTransformFeedbackVaryings": {
      "signature": "void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char **varyings, GLenum bufferMode)",
      "purpose": "specify values to record in transform feedback buffers",
      "parameters": {
        "program": "<listitem> <para> The name of the target program object. </para> </listitem>",
        "count": "<listitem> <para> The number of varying variables used for transform feedback. </para> </listitem>",
        "varyings": "<listitem> <para> An array of <parameter>count</parameter> zero-terminated strings specifying the names of the varying variables to use for transform feedback. </para> </listitem>",
        "bufferMode": "<listitem> <para> Identifies the mode used to capture the varying variables when transform feedback is active. <parameter>bufferMode</parameter> must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`. </para> </listitem>"
      }
    },
    "glUniform1f": {
      "signature": "void glUniform1f(GLint location, GLfloat v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2f": {
      "signature": "void glUniform2f(GLint location, GLfloat v0, GLfloat v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3f": {
      "signature": "void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4f": {
      "signature": "void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1i": {
      "signature": "void glUniform1i(GLint location, GLint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2i": {
      "signature": "void glUniform2i(GLint location, GLint v0, GLint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3i": {
      "signature": "void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4i": {
      "signature": "void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1ui": {
      "signature": "void glUniform1ui(GLint location, GLuint v0)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2ui": {
      "signature": "void glUniform2ui(GLint location, GLuint v0, GLuint v1)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3ui": {
      "signature": "void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4ui": {
      "signature": "void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1fv": {
      "signature": "void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2fv": {
      "signature": "void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3fv": {
      "signature": "void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4fv": {
      "signature": "void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1iv": {
      "signature": "void glUniform1iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2iv": {
      "signature": "void glUniform2iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3iv": {
      "signature": "void glUniform3iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4iv": {
      "signature": "void glUniform4iv(GLint location, GLsizei count, const GLint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform1uiv": {
      "signature": "void glUniform1uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform2uiv": {
      "signature": "void glUniform2uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform3uiv": {
      "signature": "void glUniform3uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniform4uiv": {
      "signature": "void glUniform4uiv(GLint location, GLsizei count, const GLuint *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2fv": {
      "signature": "void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3fv": {
      "signature": "void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4fv": {
      "signature": "void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x3fv": {
      "signature": "void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x2fv": {
      "signature": "void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix2x4fv": {
      "signature": "void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x2fv": {
      "signature": "void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix3x4fv": {
      "signature": "void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformMatrix4x3fv": {
      "signature": "void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)",
      "purpose": "Specify the value of a uniform variable for the current program object",
      "parameters": {
        "location": "<listitem> <para>Specifies the location of the uniform variable to be modified.</para> </listitem>",
        "count": "<listitem> <para> For the vector (<function>glUniform*v</function>) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </para> <para> For the matrix (<function>glUniformMatrix*</function>) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices. </para> </listitem>",
        "transpose": "<listitem> <para> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified uniform variable. </para> </listitem>",
        "value": "<listitem> <para> For the vector and matrix commands, specifies a pointer to an array of <parameter>count</parameter> values that will be used to update the specified uniform variable. </para> </listitem>"
      }
    },
    "glUniformBlockBinding": {
      "signature": "void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)",
      "purpose": "assign a binding point to an active uniform block",
      "parameters": {
        "program": "<listitem> <para> The name of a program object containing the active uniform block whose binding to assign. </para> </listitem>",
        "uniformBlockIndex": "<listitem> <para> The index of the active uniform block within <parameter>program</parameter> whose binding to assign. </para> </listitem>",
        "uniformBlockBinding": "<listitem> <para> Specifies the binding point to which to bind the uniform block with index <parameter>uniformBlockIndex</parameter> within <parameter>program</parameter>. </para> </listitem>"
      }
    },
    "glUniformSubroutinesuiv": {
      "signature": "void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices)",
      "purpose": "load active subroutine uniforms",
      "parameters": {
        "shadertype": "<listitem> <para> Specifies the shader stage from which to query for subroutine uniform index. <parameter>shadertype</parameter> must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`. </para> </listitem>",
        "count": "<listitem> <para> Specifies the number of uniform indices stored in <parameter>indices</parameter>. </para> </listitem>",
        "indices": "<listitem> <para> Specifies the address of an array holding the indices to load into the shader subroutine variables. </para> </listitem>"
      }
    },
    "glUnmapBuffer": {
      "signature": "GLboolean glUnmapBuffer(GLenum target)",
      "purpose": "release the mapping of a buffer object's data store into the client's address space",
      "parameters": {
        "target": "<listitem> <para> Specifies the target to which the buffer object is bound for <function>glUnmapBuffer</function>, which must be one of the following buffer bindings: `GL_ARRAY_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_COPY_READ_BUFFER`, `GL_COPY_WRITE_BUFFER`, `GL_DISPATCH_INDIRECT_BUFFER`, `GL_DRAW_INDIRECT_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`, `GL_PIXEL_PACK_BUFFER`, `GL_PIXEL_UNPACK_BUFFER`, `GL_QUERY_BUFFER`, `GL_SHADER_STORAGE_BUFFER`, `GL_TEXTURE_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` </listitem>"
      }
    },
    "glUnmapNamedBuffer": {
      "signature": "GLboolean glUnmapNamedBuffer(GLuint buffer)",
      "purpose": "release the mapping of a buffer object's data store into the client's address space",
      "parameters": {
        "buffer": "<listitem> <para> Specifies the name of the buffer object for <function>glUnmapNamedBuffer</function>. </para> </listitem>"
      }
    },
    "glUseProgram": {
      "signature": "void glUseProgram(GLuint program)",
      "purpose": "Installs a program object as part of current rendering state",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object whose executables are to be used as part of current rendering state.</para> </listitem>"
      }
    },
    "glUseProgramStages": {
      "signature": "void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)",
      "purpose": "bind stages of a program object to a program pipeline",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the program pipeline object to which to bind stages from <parameter>program</parameter>. </para> </listitem>",
        "stages": "<listitem> <para> Specifies a set of program stages to bind to the program pipeline object. </para> </listitem>",
        "program": "<listitem> <para> Specifies the program object containing the shader executables to use in <parameter>pipeline</parameter>. </para> </listitem>"
      }
    },
    "glValidateProgram": {
      "signature": "void glValidateProgram(GLuint program)",
      "purpose": "Validates a program object",
      "parameters": {
        "program": "<listitem> <para>Specifies the handle of the program object to be validated.</para> </listitem>"
      }
    },
    "glValidateProgramPipeline": {
      "signature": "void glValidateProgramPipeline(GLuint pipeline)",
      "purpose": "validate a program pipeline object against current GL state",
      "parameters": {
        "pipeline": "<listitem> <para> Specifies the name of a program pipeline object to validate. </para> </listitem>"
      }
    },
    "glVertexArrayElementBuffer": {
      "signature": "void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer)",
      "purpose": "configures element array buffer binding of a vertex array object",
      "parameters": {
        "vaobj": "<listitem> <para> Specifies the name of the vertex array object. </para> </listitem>",
        "buffer": "<listitem> <para> Specifies the name of the buffer object to use for the element array buffer binding. </para> </listitem>"
      }
    },
    "glVertexAttrib1f": {
      "signature": "void glVertexAttrib1f(GLuint index, GLfloat v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1s": {
      "signature": "void glVertexAttrib1s(GLuint index, GLshort v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1d": {
      "signature": "void glVertexAttrib1d(GLuint index, GLdouble v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI1i": {
      "signature": "void glVertexAttribI1i(GLuint index, GLint v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI1ui": {
      "signature": "void glVertexAttribI1ui(GLuint index, GLuint v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2f": {
      "signature": "void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2s": {
      "signature": "void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2d": {
      "signature": "void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI2i": {
      "signature": "void glVertexAttribI2i(GLuint index, GLint v0, GLint v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI2ui": {
      "signature": "void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3f": {
      "signature": "void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3s": {
      "signature": "void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3d": {
      "signature": "void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI3i": {
      "signature": "void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI3ui": {
      "signature": "void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4f": {
      "signature": "void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4s": {
      "signature": "void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4d": {
      "signature": "void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Nub": {
      "signature": "void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4i": {
      "signature": "void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4ui": {
      "signature": "void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL1d": {
      "signature": "void glVertexAttribL1d(GLuint index, GLdouble v0)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL2d": {
      "signature": "void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL3d": {
      "signature": "void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL4d": {
      "signature": "void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1fv": {
      "signature": "void glVertexAttrib1fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1sv": {
      "signature": "void glVertexAttrib1sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib1dv": {
      "signature": "void glVertexAttrib1dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI1iv": {
      "signature": "void glVertexAttribI1iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI1uiv": {
      "signature": "void glVertexAttribI1uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2fv": {
      "signature": "void glVertexAttrib2fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2sv": {
      "signature": "void glVertexAttrib2sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib2dv": {
      "signature": "void glVertexAttrib2dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI2iv": {
      "signature": "void glVertexAttribI2iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI2uiv": {
      "signature": "void glVertexAttribI2uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3fv": {
      "signature": "void glVertexAttrib3fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3sv": {
      "signature": "void glVertexAttrib3sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib3dv": {
      "signature": "void glVertexAttrib3dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI3iv": {
      "signature": "void glVertexAttribI3iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI3uiv": {
      "signature": "void glVertexAttribI3uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4fv": {
      "signature": "void glVertexAttrib4fv(GLuint index, const GLfloat *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4sv": {
      "signature": "void glVertexAttrib4sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4dv": {
      "signature": "void glVertexAttrib4dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4iv": {
      "signature": "void glVertexAttrib4iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4bv": {
      "signature": "void glVertexAttrib4bv(GLuint index, const GLbyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4ubv": {
      "signature": "void glVertexAttrib4ubv(GLuint index, const GLubyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4usv": {
      "signature": "void glVertexAttrib4usv(GLuint index, const GLushort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4uiv": {
      "signature": "void glVertexAttrib4uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Nbv": {
      "signature": "void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Nsv": {
      "signature": "void glVertexAttrib4Nsv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Niv": {
      "signature": "void glVertexAttrib4Niv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Nubv": {
      "signature": "void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Nusv": {
      "signature": "void glVertexAttrib4Nusv(GLuint index, const GLushort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttrib4Nuiv": {
      "signature": "void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4bv": {
      "signature": "void glVertexAttribI4bv(GLuint index, const GLbyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4ubv": {
      "signature": "void glVertexAttribI4ubv(GLuint index, const GLubyte *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4sv": {
      "signature": "void glVertexAttribI4sv(GLuint index, const GLshort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4usv": {
      "signature": "void glVertexAttribI4usv(GLuint index, const GLushort *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4iv": {
      "signature": "void glVertexAttribI4iv(GLuint index, const GLint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribI4uiv": {
      "signature": "void glVertexAttribI4uiv(GLuint index, const GLuint *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL1dv": {
      "signature": "void glVertexAttribL1dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL2dv": {
      "signature": "void glVertexAttribL2dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL3dv": {
      "signature": "void glVertexAttribL3dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribL4dv": {
      "signature": "void glVertexAttribL4dv(GLuint index, const GLdouble *v)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribP1ui": {
      "signature": "void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribP2ui": {
      "signature": "void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribP3ui": {
      "signature": "void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribP4ui": {
      "signature": "void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)",
      "purpose": "Specifies the value of a generic vertex attribute",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "v0": "<listitem> <para> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </para> </listitem>",
        "v": "<listitem> <para> For the vector commands (<function>glVertexAttrib*v</function>), specifies a pointer to an array of values to be used for the generic vertex attribute. </para> </listitem>",
        "type": "<listitem> <para> For the packed commands (<function>glVertexAttribP*</function>), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data. </para> </listitem>",
        "normalized": "<listitem> <para> For the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If <parameter>type</parameter> indicates a floating-pont format, then <parameter>normalized</parameter> value must be `GL_FALSE`. </para> </listitem>",
        "value": "<listitem> <para> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribBinding": {
      "signature": "void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)",
      "purpose": "associate a vertex attribute and a vertex buffer binding for a vertex array object",
      "parameters": {
        "attribindex": "<listitem> <para> The index of the attribute to associate with a vertex buffer binding. </para> </listitem>",
        "bindingindex": "<listitem> <para> The index of the vertex buffer binding with which to associate the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexArrayAttribBinding": {
      "signature": "void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex)",
      "purpose": "associate a vertex attribute and a vertex buffer binding for a vertex array object",
      "parameters": {
        "vaobj": "<listitem> <para> Specifies the name of the vertex array object for <function>glVertexArrayAttribBinding</function>. </para> </listitem>",
        "attribindex": "<listitem> <para> The index of the attribute to associate with a vertex buffer binding. </para> </listitem>",
        "bindingindex": "<listitem> <para> The index of the vertex buffer binding with which to associate the generic vertex attribute. </para> </listitem>"
      }
    },
    "glVertexAttribDivisor": {
      "signature": "void glVertexAttribDivisor(GLuint index, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes advance during instanced rendering",
      "parameters": {
        "index": "<listitem> <para> Specify the index of the generic vertex attribute. </para> </listitem>",
        "divisor": "<listitem> <para> Specify the number of instances that will pass between updates of the generic attribute at slot <parameter>index</parameter>. </para> </listitem>"
      }
    },
    "glVertexAttribFormat": {
      "signature": "void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para>The generic vertex attribute array being described.</para> </listitem>",
        "size": "<listitem> <para>The number of values per vertex that are stored in the array.</para> </listitem>",
        "type": "<listitem> <para>The type of the data stored in the array.</para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexAttribIFormat": {
      "signature": "void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para>The generic vertex attribute array being described.</para> </listitem>",
        "size": "<listitem> <para>The number of values per vertex that are stored in the array.</para> </listitem>",
        "type": "<listitem> <para>The type of the data stored in the array.</para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexAttribLFormat": {
      "signature": "void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para>The generic vertex attribute array being described.</para> </listitem>",
        "size": "<listitem> <para>The number of values per vertex that are stored in the array.</para> </listitem>",
        "type": "<listitem> <para>The type of the data stored in the array.</para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexArrayAttribFormat": {
      "signature": "void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para>The generic vertex attribute array being described.</para> </listitem>",
        "size": "<listitem> <para>The number of values per vertex that are stored in the array.</para> </listitem>",
        "type": "<listitem> <para>The type of the data stored in the array.</para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexArrayAttribIFormat": {
      "signature": "void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para>The generic vertex attribute array being described.</para> </listitem>",
        "size": "<listitem> <para>The number of values per vertex that are stored in the array.</para> </listitem>",
        "type": "<listitem> <para>The type of the data stored in the array.</para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexArrayAttribLFormat": {
      "signature": "void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)",
      "purpose": "specify the organization of vertex arrays",
      "parameters": {
        "attribindex": "<listitem> <para>The generic vertex attribute array being described.</para> </listitem>",
        "size": "<listitem> <para>The number of values per vertex that are stored in the array.</para> </listitem>",
        "type": "<listitem> <para>The type of the data stored in the array.</para> </listitem>",
        "normalized": "<listitem> <para> Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if <parameter>type</parameter> is `GL_FIXED`. </para> </listitem>",
        "relativeoffset": "<listitem> <para>The distance between elements within the buffer.</para> </listitem>"
      }
    },
    "glVertexAttribPointer": {
      "signature": "void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by <function>glVertexAttribPointer</function>. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by <function>glVertexAttribPointer</function> and <function>glVertexAttribIPointer</function>. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by <function>glVertexAttribPointer</function>. `GL_DOUBLE` is also accepted by <function>glVertexAttribLPointer</function> and is the only token accepted by the <parameter>type</parameter> parameter for that function. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0.</para> </listitem>"
      }
    },
    "glVertexAttribIPointer": {
      "signature": "void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by <function>glVertexAttribPointer</function>. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by <function>glVertexAttribPointer</function> and <function>glVertexAttribIPointer</function>. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by <function>glVertexAttribPointer</function>. `GL_DOUBLE` is also accepted by <function>glVertexAttribLPointer</function> and is the only token accepted by the <parameter>type</parameter> parameter for that function. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0.</para> </listitem>"
      }
    },
    "glVertexAttribLPointer": {
      "signature": "void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)",
      "purpose": "define an array of generic vertex attribute data",
      "parameters": {
        "index": "<listitem> <para>Specifies the index of the generic vertex attribute to be modified.</para> </listitem>",
        "size": "<listitem> <para>Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by <function>glVertexAttribPointer</function>. The initial value is 4.</para> </listitem>",
        "type": "<listitem> <para>Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by <function>glVertexAttribPointer</function> and <function>glVertexAttribIPointer</function>. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by <function>glVertexAttribPointer</function>. `GL_DOUBLE` is also accepted by <function>glVertexAttribLPointer</function> and is the only token accepted by the <parameter>type</parameter> parameter for that function. The initial value is `GL_FLOAT`.</para> </listitem>",
        "normalized": "<listitem> <para>For <function>glVertexAttribPointer</function>, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.</para> </listitem>",
        "stride": "<listitem> <para>Specifies the byte offset between consecutive generic vertex attributes. If <parameter>stride</parameter> is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</para> </listitem>",
        "pointer": "<listitem> <para>Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0.</para> </listitem>"
      }
    },
    "glVertexBindingDivisor": {
      "signature": "void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes    advance",
      "parameters": {
        "bindingindex": "<listitem> <para>The index of the binding whose divisor to modify.</para> </listitem>",
        "divisor": "<listitem> <para>The new value for the instance step rate to apply.</para> </listitem>"
      }
    },
    "glVertexArrayBindingDivisor": {
      "signature": "void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor)",
      "purpose": "modify the rate at which generic vertex attributes    advance",
      "parameters": {
        "vaobj": "<listitem> <para>Specifies the name of the vertex array object for <function>glVertexArrayBindingDivisor</function> function.</para> </listitem>",
        "bindingindex": "<listitem> <para>The index of the binding whose divisor to modify.</para> </listitem>",
        "divisor": "<listitem> <para>The new value for the instance step rate to apply.</para> </listitem>"
      }
    },
    "glViewport": {
      "signature": "void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)",
      "purpose": "set the viewport",
      "parameters": {
        "x": "<listitem> <para> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "width": "<listitem> <para> Specify the width and height of the viewport. When a GL context is first attached to a window, <parameter>width</parameter> and <parameter>height</parameter> are set to the dimensions of that window. </para> </listitem>"
      }
    },
    "glViewportArrayv": {
      "signature": "void glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)",
      "purpose": "set multiple viewports",
      "parameters": {
        "first": "<listitem> <para> Specify the first viewport to set. </para> </listitem>",
        "count": "<listitem> <para> Specify the number of viewports to set. </para> </listitem>",
        "v": "<listitem> <para> Specify the address of an array containing the viewport parameters. </para> </listitem>"
      }
    },
    "glViewportIndexedf": {
      "signature": "void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)",
      "purpose": "set a specified viewport",
      "parameters": {
        "index": "<listitem> <para> Specify the first viewport to set. </para> </listitem>",
        "x": "<listitem> <para> For <function>glViewportIndexedf</function>, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "w": "<listitem> <para> For <function>glViewportIndexedf</function>, specifies the width and height of the viewport. When a GL context is first attached to a window, <parameter>w</parameter> and <parameter>h</parameter> are set to the dimensions of that window. </para> </listitem>",
        "v": "<listitem> <para> For <function>glViewportIndexedfv</function>, specifies the address of an array containing the viewport parameters. </para> </listitem>"
      }
    },
    "glViewportIndexedfv": {
      "signature": "void glViewportIndexedfv(GLuint index, const GLfloat *v)",
      "purpose": "set a specified viewport",
      "parameters": {
        "index": "<listitem> <para> Specify the first viewport to set. </para> </listitem>",
        "x": "<listitem> <para> For <function>glViewportIndexedf</function>, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </para> </listitem>",
        "w": "<listitem> <para> For <function>glViewportIndexedf</function>, specifies the width and height of the viewport. When a GL context is first attached to a window, <parameter>w</parameter> and <parameter>h</parameter> are set to the dimensions of that window. </para> </listitem>",
        "v": "<listitem> <para> For <function>glViewportIndexedfv</function>, specifies the address of an array containing the viewport parameters. </para> </listitem>"
      }
    },
    "glWaitSync": {
      "signature": "void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)",
      "purpose": "instruct the GL server to block until the specified sync object becomes signaled",
      "parameters": {
        "sync": "<listitem> <para> Specifies the sync object whose status to wait on. </para> </listitem>",
        "flags": "<listitem> <para> A bitfield controlling the command flushing behavior. <parameter>flags</parameter> may be zero. </para> </listitem>",
        "timeout": "<listitem> <para> Specifies the timeout that the server should wait before continuing. <parameter>timeout</parameter> must be `GL_TIMEOUT_IGNORED`. </para> </listitem>"
      }
    },
    "greaterThan": {
      "signature": "bvec greaterThan(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "greaterThanEqual": {
      "signature": "bvec greaterThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise greater-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "groupMemoryBarrier": {
      "signature": "void groupMemoryBarrier(void)",
      "purpose": "controls the ordering of memory transaction issued shader invocation relative to a work group",
      "parameters": {}
    },
    "imageAtomicAdd": {
      "signature": "int imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, int data)",
      "purpose": "atomically add a value to an existing value in memory and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to add <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to add the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to add into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to add into the image. </para> </listitem>"
      }
    },
    "imageAtomicAnd": {
      "signature": "int imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, int data)",
      "purpose": "atomically compute the logical AND of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to logically AND into the image. </para> </listitem>"
      }
    },
    "imageAtomicCompSwap": {
      "signature": "int imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, int compare, int data)",
      "purpose": "atomically compares supplied data with that in memory and conditionally stores it to memory",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to compare and conditionally store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to compare and conditionally store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to compare and conditionally store into. </para> </listitem>",
        "compare": "<listitem> <para> Specifies the value to compare with the content of the image. </para> </listitem>",
        "data": "<listitem> <para> Specifies the value to store in the image if <parameter>compare</parameter> is equal to the existing image content. </para> </listitem>"
      }
    },
    "imageAtomicExchange": {
      "signature": "int imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, float data)",
      "purpose": "atomically store supplied data into memory and return the original value from memory",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to exchange with that stored in the image. </para> </listitem>"
      }
    },
    "imageAtomicMax": {
      "signature": "int imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, int data)",
      "purpose": "atomically compute the maximum of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data of which to take the maximum with that stored in the image. </para> </listitem>"
      }
    },
    "imageAtomicMin": {
      "signature": "int imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, int data)",
      "purpose": "atomically compute the minimum of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data of which to take the minimum with that stored in the image. </para> </listitem>"
      }
    },
    "imageAtomicOr": {
      "signature": "int imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, int data)",
      "purpose": "atomically compute the logical OR of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to logically OR into the image. </para> </listitem>"
      }
    },
    "imageAtomicXor": {
      "signature": "int imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, int data)",
      "purpose": "atomically compute the logical exclusive OR of a value with an existing value in memory, store that value and return the original value",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store <parameter>data</parameter>. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the data. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to logically XOR into the image. </para> </listitem>"
      }
    },
    "imageLoad": {
      "signature": "gvec4 imageLoad(gimage2DMSArray image, ivec3 P, int sample)",
      "purpose": "load a single texel from an image",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit from which to load a texel. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate from which to load the texel. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to load </para> </listitem>"
      }
    },
    "imageSamples": {
      "signature": "int imageSamples(gimage2DMSArray image)",
      "purpose": "return the number of samples of an image",
      "parameters": {
        "image": "<listitem> <para> Specifies the image to which the texture is bound. </para> </listitem>"
      }
    },
    "imageSize": {
      "signature": "ivec3 imageSize(gimage2DMSArray image)",
      "purpose": "retrieve the dimensions of an image",
      "parameters": {
        "image": "<listitem> <para> Specifies the image to which the texture whose dimensions to retrieve is bound. </para> </listitem>"
      }
    },
    "imageStore": {
      "signature": "void imageStore(gimage2DMSArray image, ivec3 P, int sample, gvec4 data)",
      "purpose": "write a single texel into an image",
      "parameters": {
        "image": "<listitem> <para> Specify the image unit into which to store a texel. </para> </listitem>",
        "P": "<listitem> <para> Specify the coordinate at which to store the texel. </para> </listitem>",
        "sample": "<listitem> <para> When present, specifies the sample within the image to store into. </para> </listitem>",
        "data": "<listitem> <para> Specifies the data to store into the image. </para> </listitem>"
      }
    },
    "intBitsToFloat": {
      "signature": "genType intBitsToFloat(genIType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "uintBitsToFloat": {
      "signature": "genType uintBitsToFloat(genUType x)",
      "purpose": "produce a floating point using an encoding supplied as an integer",
      "parameters": {
        "x": "<listitem> <para> Specifies the bit encoding to return as a floating point value. </para> </listitem>"
      }
    },
    "interpolateAtCentroid": {
      "signature": "vec4 interpolateAtCentroid(vec4 interpolant)",
      "purpose": "sample a varying at the centroid of a pixel",
      "parameters": {
        "interpolant": "<listitem> <para> Specifies the interpolant to be sampled at the pixel centroid. </para> </listitem>"
      }
    },
    "interpolateAtOffset": {
      "signature": "vec4 interpolateAtOffset(vec4 interpolant, vec2 offset)",
      "purpose": "sample a varying at specified offset from the center of a pixel",
      "parameters": {
        "interpolant": "<listitem> <para> Specifies the interpolant to be sampled at the specified offset. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset from the center of the pixel at which to sample <parameter>interpolant</parameter>. </para> </listitem>"
      }
    },
    "interpolateAtSample": {
      "signature": "vec4 interpolateAtSample(vec4 interpolant, int sample)",
      "purpose": "sample a varying at the location of a specified sample",
      "parameters": {
        "interpolant": "<listitem> <para> Specifies the interpolant to be sampled at the location of sample <parameter>sample</parameter>. </para> </listitem>",
        "sample": "<listitem> <para> Specifies the index of the sample whose location will be used to sample <parameter>interpolant</parameter>. </para> </listitem>"
      }
    },
    "inverse": {
      "signature": "dmat4 inverse(dmat4 m)",
      "purpose": "calculate the inverse of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the inverse. </para> </listitem>"
      }
    },
    "inversesqrt": {
      "signature": "genDType inversesqrt(genDType x)",
      "purpose": "return the inverse of the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the inverse of the square root. </para> </listitem>"
      }
    },
    "isinf": {
      "signature": "genBType isinf(genDType x)",
      "purpose": "determine whether the parameter is positive or negative infinity",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for infinity. </para> </listitem>"
      }
    },
    "isnan": {
      "signature": "genBType isnan(genDType x)",
      "purpose": "determine whether the parameter is a number",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to test for NaN. </para> </listitem>"
      }
    },
    "ldexp": {
      "signature": "genDType ldexp(genDType x, genIType exp)",
      "purpose": "assemble a floating point number from a value and exponent",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used as a source of significand. </para> </listitem>",
        "out exp": "<listitem> <para> Specifies the value to be used as a source of exponent. </para> </listitem>"
      }
    },
    "length": {
      "signature": "double length(genDType x)",
      "purpose": "calculate the length of a vector",
      "parameters": {
        "x": "<listitem> <para> Specifies a vector of which to calculate the length. </para> </listitem>"
      }
    },
    "lessThan": {
      "signature": "bvec lessThan(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "lessThanEqual": {
      "signature": "bvec lessThanEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise less-than-or-equal comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "log": {
      "signature": "genType log(genType x)",
      "purpose": "return the natural logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the natural logarithm. </para> </listitem>"
      }
    },
    "log2": {
      "signature": "genType log2(genType x)",
      "purpose": "return the base 2 logarithm of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the base 2 logarithm. </para> </listitem>"
      }
    },
    "matrixCompMult": {
      "signature": "dmat matrixCompMult(dmat x, dmat y)",
      "purpose": "perform a component-wise multiplication of two matrices",
      "parameters": {
        "x": "<listitem> <para> Specifies the first matrix multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second matrix multiplicand. </para> </listitem>"
      }
    },
    "max": {
      "signature": "genUType max(genUType x, uint y)",
      "purpose": "return the greater of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "memoryBarrier": {
      "signature": "void memoryBarrier(void)",
      "purpose": "controls the ordering of memory transactions issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierAtomicCounter": {
      "signature": "void memoryBarrierAtomicCounter(void)",
      "purpose": "controls the ordering of operations on atomic counters issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierBuffer": {
      "signature": "void memoryBarrierBuffer(void)",
      "purpose": "controls the ordering of operations on buffer variables issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierImage": {
      "signature": "void memoryBarrierImage(void)",
      "purpose": "controls the ordering of operations on image variables issued by a single shader invocation",
      "parameters": {}
    },
    "memoryBarrierShared": {
      "signature": "void memoryBarrierShared(void)",
      "purpose": "controls the ordering of operations on shared variables issued by a single shader invocation",
      "parameters": {}
    },
    "min": {
      "signature": "genUType min(genUType x, uint y)",
      "purpose": "return the lesser of two values",
      "parameters": {
        "x": "<listitem> <para> Specify the first value to compare. </para> </listitem>",
        "y": "<listitem> <para> Specify the second value to compare. </para> </listitem>"
      }
    },
    "mix": {
      "signature": "genBType mix(genBType x, genBType y, genBType a)",
      "purpose": "linearly interpolate between two values",
      "parameters": {
        "x": "<listitem> <para> Specify the start of the range in which to interpolate. </para> </listitem>",
        "y": "<listitem> <para> Specify the end of the range in which to interpolate. </para> </listitem>",
        "a": "<listitem> <para> Specify the value to use to interpolate between <parameter>x</parameter> and <parameter>y</parameter>. </para> </listitem>"
      }
    },
    "mod": {
      "signature": "genDType mod(genDType x, genDType y)",
      "purpose": "compute value of one parameter modulo another",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "modf": {
      "signature": "genDType modf(genDType x, out genDType i)",
      "purpose": "separate a value into its integer and fractional components",
      "parameters": {
        "x": "<listitem> <para> Specify the value to separate. </para> </listitem>",
        "out i": "<listitem> <para> A variable that receives the integer part of the argument. </para> </listitem>"
      }
    },
    "noise1": {
      "signature": "float noise1(genType x)",
      "purpose": "generate values with a pseudo-random noise function",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used to seed the noise function. </para> </listitem>"
      }
    },
    "noise2": {
      "signature": "vec2 noise2(genType x)",
      "purpose": "generate values with a pseudo-random noise function",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used to seed the noise function. </para> </listitem>"
      }
    },
    "noise3": {
      "signature": "vec3 noise3(genType x)",
      "purpose": "generate values with a pseudo-random noise function",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used to seed the noise function. </para> </listitem>"
      }
    },
    "noise4": {
      "signature": "vec4 noise4(genType x)",
      "purpose": "generate values with a pseudo-random noise function",
      "parameters": {
        "x": "<listitem> <para> Specifies the value to be used to seed the noise function. </para> </listitem>"
      }
    },
    "normalize": {
      "signature": "genDType normalize(genDType v)",
      "purpose": "calculates the unit vector in the same direction as the original vector",
      "parameters": {
        "v": "<listitem> <para> Specifies the vector to normalize. </para> </listitem>"
      }
    },
    "not": {
      "signature": "bvec not(bvec x)",
      "purpose": "logically invert a boolean vector",
      "parameters": {
        "x": "<listitem> <para> Specifies the vector to be inverted. </para> </listitem>"
      }
    },
    "notEqual": {
      "signature": "bvec notEqual(uvec x, uvec y)",
      "purpose": "perform a component-wise not-equal-to comparison of two vectors",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the comparison operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the comparison operation. </para> </listitem>"
      }
    },
    "outerProduct": {
      "signature": "dmat4x3 outerProduct(dvec3 c, dvec4 r)",
      "purpose": "calculate the outer product of a pair of vectors",
      "parameters": {
        "c": "<listitem> <para> Specifies the parameter to be treated as a column vector. </para> </listitem>",
        "r": "<listitem> <para> Specifies the parameter to be treated as a row vector. </para> </listitem>"
      }
    },
    "packDouble2x32": {
      "signature": "double packDouble2x32(uvec2 v)",
      "purpose": "create a double-precision value from a pair of unsigned integers",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of two unsigned integers to be packed into a single double-precision result. </para> </listitem>"
      }
    },
    "packHalf2x16": {
      "signature": "uint packHalf2x16(vec2 v)",
      "purpose": "convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer",
      "parameters": {
        "v": "<listitem> <para> Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result. </para> </listitem>"
      }
    },
    "packUnorm2x16": {
      "signature": "uint packUnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm2x16": {
      "signature": "uint packSnorm2x16(vec2 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packUnorm4x8": {
      "signature": "uint packUnorm4x8(vec4 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "packSnorm4x8": {
      "signature": "uint packSnorm4x8(vec4 v)",
      "purpose": "pack floating-point values into an unsigned integer",
      "parameters": {
        "v": "<listitem> <para> Specifies a vector of values to be packed into an unsigned integer. </para> </listitem>"
      }
    },
    "pow": {
      "signature": "genType pow(genType x, genType y)",
      "purpose": "return the value of the first parameter raised to the power of the second",
      "parameters": {
        "x": "<listitem> <para> Specify the value to raise to the power <parameter>y</parameter>. </para> </listitem>",
        "y": "<listitem> <para> Specify the power to which to raise <parameter>x</parameter>. </para> </listitem>"
      }
    },
    "radians": {
      "signature": "genType radians(genType degrees)",
      "purpose": "convert a quantity in degrees to radians",
      "parameters": {
        "degrees": "<listitem> <para> Specify the quantity, in degrees, to be converted to radians. </para> </listitem>"
      }
    },
    "reflect": {
      "signature": "genDType reflect(genDType I, genDType N)",
      "purpose": "calculate the reflection direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>"
      }
    },
    "refract": {
      "signature": "genDType refract(genDType I, genDType N, float eta)",
      "purpose": "calculate the refraction direction for an incident vector",
      "parameters": {
        "I": "<listitem> <para> Specifies the incident vector. </para> </listitem>",
        "N": "<listitem> <para> Specifies the normal vector. </para> </listitem>",
        "eta": "<listitem> <para> Specifies the ratio of indices of refraction. </para> </listitem>"
      }
    },
    "round": {
      "signature": "genDType round(genDType x)",
      "purpose": "find the nearest integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "roundEven": {
      "signature": "genDType roundEven(genDType x)",
      "purpose": "find the nearest even integer to the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "sign": {
      "signature": "genDType sign(genDType x)",
      "purpose": "extract the sign of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value from which to extract the sign. </para> </listitem>"
      }
    },
    "sin": {
      "signature": "genType sin(genType angle)",
      "purpose": "return the sine of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the sine. </para> </listitem>"
      }
    },
    "sinh": {
      "signature": "genType sinh(genType x)",
      "purpose": "return the hyperbolic sine of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic sine to return. </para> </listitem>"
      }
    },
    "smoothstep": {
      "signature": "genDType smoothstep(double edge0, double edge1, genDType x)",
      "purpose": "perform Hermite interpolation between two values",
      "parameters": {
        "edge0": "<listitem> <para> Specifies the value of the lower edge of the Hermite function. </para> </listitem>",
        "edge1": "<listitem> <para> Specifies the value of the upper edge of the Hermite function. </para> </listitem>",
        "x": "<listitem> <para> Specifies the source value for interpolation. </para> </listitem>"
      }
    },
    "sqrt": {
      "signature": "genDType sqrt(genDType x)",
      "purpose": "return the square root of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value of which to take the square root. </para> </listitem>"
      }
    },
    "step": {
      "signature": "genDType step(double edge, genDType x)",
      "purpose": "generate a step function by comparing two values",
      "parameters": {
        "edge": "<listitem> <para> Specifies the location of the edge of the step function. </para> </listitem>",
        "x": "<listitem> <para> Specify the value to be used to generate the step function. </para> </listitem>"
      }
    },
    "tan": {
      "signature": "genType tan(genType angle)",
      "purpose": "return the tangent of the parameter",
      "parameters": {
        "angle": "<listitem> <para> Specify the quantity, in radians, of which to return the tangent. </para> </listitem>"
      }
    },
    "tanh": {
      "signature": "genType tanh(genType x)",
      "purpose": "return the hyperbolic tangent of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value whose hyperbolic tangent to return. </para> </listitem>"
      }
    },
    "texelFetch": {
      "signature": "gvec4 texelFetch(gsampler2DMSArray sampler, ivec3 P, int sample)",
      "purpose": "perform a lookup of a single texel within a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "sample": "<listitem> <para> For multisampled fetches, specifies which sample within the texel from which will be returned. </para> </listitem>"
      }
    },
    "texelFetchOffset": {
      "signature": "gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)",
      "purpose": "perform a lookup of a single texel within a texture with an offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> If present, specifies the level-of-detail within the texture from which the texel will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>"
      }
    },
    "texture": {
      "signature": "float texture(samplerCubeArrayShadow sampler, vec4 P, float compare)",
      "purpose": "retrieves texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>",
        "compare": "<listitem> <para> Specifies the value to which the fetched texel will be compared when sampling from <code>samplerCubeArrayShadow</code>. </para> </listitem>"
      }
    },
    "textureGather": {
      "signature": "vec4 textureGather(sampler2DRectShadow sampler, vec2 P, float refZ)",
      "purpose": "gathers four texels from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>"
      }
    },
    "textureGatherOffset": {
      "signature": "vec4 textureGatherOffset(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offset)",
      "purpose": "gathers four texels from a texture with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset from the specified texture coordinate <parameter>P</parameter> from which the texels will be gathered. </para> </listitem>"
      }
    },
    "textureGatherOffsets": {
      "signature": "vec4 textureGatherOffsets(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offsets[4])",
      "purpose": "gathers four texels from a texture with an array of offsets",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "comp": "<listitem> <para> Specifies the component of the source texture that will be used to generate the resulting vector. </para> </listitem>",
        "refZ": "<listitem> <para> Specifies the reference Z value used in the comparison for shadow forms. </para> </listitem>",
        "offsets": "<listitem> <para> Specifies an array of offsets from the specified texture coordinate <parameter>P</parameter> from which the texels will be gathered. </para> </listitem>"
      }
    },
    "textureGrad": {
      "signature": "gvec4 textureGrad(gsamplerCubeArray sampler, vec4 P, vec3 dPdx, vec3 dPdy)",
      "purpose": "perform a texture lookup with explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureGradOffset": {
      "signature": "float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset to be applied to the texture coordinates before sampling. </para> </listitem>"
      }
    },
    "textureLod": {
      "signature": "gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod)",
      "purpose": "perform a texture lookup with explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail </para> </listitem>"
      }
    },
    "textureLodOffset": {
      "signature": "float textureLodOffset(sampler1DArrayShadow sampler, vec3 P, float lod, int offset)",
      "purpose": "perform a texture lookup with explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which texels will be fetched. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that will be applied to <parameter>P</parameter> before texels are fetched. </para> </listitem>"
      }
    },
    "textureOffset": {
      "signature": "float textureOffset(sampler2DArrayShadow sampler, vec4 P, vec2 offset)",
      "purpose": "perform a texture lookup with offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies offset, in texels that will be applied to <parameter>P</parameter> before looking up the texel. </para> </listitem>"
      }
    },
    "textureProj": {
      "signature": "float textureProj(sampler2DRectShadow sampler, vec4 P)",
      "purpose": "perform a texture lookup with projection",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureProjGrad": {
      "signature": "float textureProjGrad(sampler2DRectShadow sampler, vec4 P, vec2 pDx, vec2 pDy)",
      "purpose": "perform a texture lookup with projection and explicit gradients",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>"
      }
    },
    "textureProjGradOffset": {
      "signature": "float textureProjGradOffset(sampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)",
      "purpose": "perform a texture lookup with projection, explicit gradients and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "dPdx": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window x. </para> </listitem>",
        "dPdy": "<listitem> <para> Specifies the partial derivative of <parameter>P</parameter> with respect to window y. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offsets, in texels at which the texture will be sampled relative to the projection of <parameter>P</parameter>. </para> </listitem>"
      }
    },
    "textureProjLod": {
      "signature": "float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>"
      }
    },
    "textureProjLodOffset": {
      "signature": "float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)",
      "purpose": "perform a texture lookup with projection and explicit level-of-detail and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which texture will be sampled. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the explicit level-of-detail from which to fetch texels. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset, in texels, to be applied to <parameter>P</parameter> before fetching texels. </para> </listitem>"
      }
    },
    "textureProjOffset": {
      "signature": "float textureProjOffset(sampler2DRectShadow sampler, vec4 P, ivec2 offset)",
      "purpose": "perform a texture lookup with projection and offset",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture from which texels will be retrieved is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the texture will be sampled. </para> </listitem>",
        "offset": "<listitem> <para> Specifies the offset that is applied to <parameter>P</parameter> before sampling occurs. </para> </listitem>",
        "bias": "<listitem> <para> Specifies an optional bias to be applied during level-of-detail computation. </para> </listitem>"
      }
    },
    "textureQueryLevels": {
      "signature": "int textureQueryLevels(samplerCubeArrayShadow sampler)",
      "purpose": "compute the number of accessible mipmap levels of a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture whose mipmap level count will be queried is bound. </para> </listitem>"
      }
    },
    "textureQueryLod": {
      "signature": "vec2 textureQueryLod(samplerCubeArrayShadow sampler, vec3 P)",
      "purpose": "compute the level-of-detail that would be used to sample from a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture whose level-of-detail will be queried is bound. </para> </listitem>",
        "P": "<listitem> <para> Specifies the texture coordinates at which the level-of-detail will be queried. </para> </listitem>"
      }
    },
    "textureSamples": {
      "signature": "int textureSamples(gsampler2DMSArray sampler)",
      "purpose": "return the number of samples of a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture is bound. </para> </listitem>"
      }
    },
    "textureSize": {
      "signature": "ivec3 textureSize(gsampler2DMSArray sampler)",
      "purpose": "retrieve the dimensions of a level of a texture",
      "parameters": {
        "sampler": "<listitem> <para> Specifies the sampler to which the texture whose dimensions to retrieve is bound. </para> </listitem>",
        "lod": "<listitem> <para> Specifies the level of the texture for which to retrieve the dimensions. </para> </listitem>"
      }
    },
    "transpose": {
      "signature": "dmat4x3 transpose(dmat3x4 m)",
      "purpose": "calculate the transpose of a matrix",
      "parameters": {
        "m": "<listitem> <para> Specifies the matrix of which to take the transpose. </para> </listitem>"
      }
    },
    "trunc": {
      "signature": "genDType trunc(genDType x)",
      "purpose": "find the truncated value of the parameter",
      "parameters": {
        "x": "<listitem> <para> Specify the value to evaluate. </para> </listitem>"
      }
    },
    "uaddCarry": {
      "signature": "genUType uaddCarry(genUType x, genUType y, out genUType carry)",
      "purpose": "add unsigned integers and generate carry",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the summation operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the summation operation. </para> </listitem>",
        "carry": "<listitem> <para> Specifies the variable to receive the carry output of the sum. </para> </listitem>"
      }
    },
    "umulExtended": {
      "signature": "void umulExtended(genUType x, genUType y, out genUType msb, out genUType lsb)",
      "purpose": "perform a 32- by 32-bit multiply to produce a 64-bit result",
      "parameters": {
        "x": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second multiplicand. </para> </listitem>",
        "msb": "<listitem> <para> Specifies the variable to receive the most significant word of the product. </para> </listitem>",
        "lsb": "<listitem> <para> Specifies the variable to receive the least significant word of the product. </para> </listitem>"
      }
    },
    "imulExtended": {
      "signature": "void imulExtended(genIType x, genIType y, out genIType msb, out genIType lsb)",
      "purpose": "perform a 32- by 32-bit multiply to produce a 64-bit result",
      "parameters": {
        "x": "<listitem> <para> Specifies the first multiplicand. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second multiplicand. </para> </listitem>",
        "msb": "<listitem> <para> Specifies the variable to receive the most significant word of the product. </para> </listitem>",
        "lsb": "<listitem> <para> Specifies the variable to receive the least significant word of the product. </para> </listitem>"
      }
    },
    "unpackDouble2x32": {
      "signature": "uvec2 unpackDouble2x32(double d)",
      "purpose": "produce two unsigned integers containing the bit encoding of a double precision floating point value",
      "parameters": {
        "d": "<listitem> <para> Specifies double precision value to break into a pair of unsigned integers. </para> </listitem>"
      }
    },
    "unpackHalf2x16": {
      "signature": "vec2 unpackHalf2x16(uint v)",
      "purpose": "convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities",
      "parameters": {
        "v": "<listitem> <para> Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked. </para> </listitem>"
      }
    },
    "unpackUnorm2x16": {
      "signature": "vec2 unpackUnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm2x16": {
      "signature": "vec2 unpackSnorm2x16(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackUnorm4x8": {
      "signature": "vec4 unpackUnorm4x8(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "unpackSnorm4x8": {
      "signature": "vec4 unpackSnorm4x8(uint p)",
      "purpose": "unpack floating-point values from an unsigned integer",
      "parameters": {
        "p": "<listitem> <para> Specifies an unsigned integer containing packed floating-point values. </para> </listitem>"
      }
    },
    "usubBorrow": {
      "signature": "genUType usubBorrow(genUType x, genUType y, out genUType borrow)",
      "purpose": "subtract unsigned integers and generate borrow",
      "parameters": {
        "x": "<listitem> <para> Specifies the first vector to be used in the subtraction operation. </para> </listitem>",
        "y": "<listitem> <para> Specifies the second vector to be used in the subtraction operation. </para> </listitem>",
        "borrow": "<listitem> <para> Specifies the variable to receive the borrow output of the difference. </para> </listitem>"
      }
    }
  }
}